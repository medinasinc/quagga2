(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 105);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(23);

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(178);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(58),
  create: __webpack_require__(59),
  clone: __webpack_require__(110),
  fromValues: __webpack_require__(111),
  copy: __webpack_require__(112),
  set: __webpack_require__(113),
  equals: __webpack_require__(114),
  exactEquals: __webpack_require__(115),
  add: __webpack_require__(116),
  subtract: __webpack_require__(60),
  sub: __webpack_require__(117),
  multiply: __webpack_require__(61),
  mul: __webpack_require__(118),
  divide: __webpack_require__(62),
  div: __webpack_require__(119),
  inverse: __webpack_require__(120),
  min: __webpack_require__(121),
  max: __webpack_require__(122),
  rotate: __webpack_require__(123),
  floor: __webpack_require__(124),
  ceil: __webpack_require__(125),
  round: __webpack_require__(126),
  scale: __webpack_require__(127),
  scaleAndAdd: __webpack_require__(128),
  distance: __webpack_require__(63),
  dist: __webpack_require__(129),
  squaredDistance: __webpack_require__(64),
  sqrDist: __webpack_require__(130),
  length: __webpack_require__(65),
  len: __webpack_require__(131),
  squaredLength: __webpack_require__(66),
  sqrLen: __webpack_require__(132),
  negate: __webpack_require__(133),
  normalize: __webpack_require__(134),
  dot: __webpack_require__(135),
  cross: __webpack_require__(136),
  lerp: __webpack_require__(137),
  random: __webpack_require__(138),
  transformMat2: __webpack_require__(139),
  transformMat2d: __webpack_require__(140),
  transformMat3: __webpack_require__(141),
  transformMat4: __webpack_require__(142),
  forEach: __webpack_require__(143),
  limit: __webpack_require__(144)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "imageRef", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function() { return /* binding */ computeIntegralImage2; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage", function() { return /* binding */ computeIntegralImage; });
__webpack_require__.d(__webpack_exports__, "thresholdImage", function() { return /* binding */ thresholdImage; });
__webpack_require__.d(__webpack_exports__, "computeHistogram", function() { return /* binding */ computeHistogram; });
__webpack_require__.d(__webpack_exports__, "sharpenLine", function() { return /* binding */ sharpenLine; });
__webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function() { return /* binding */ determineOtsuThreshold; });
__webpack_require__.d(__webpack_exports__, "otsuThreshold", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "computeBinaryImage", function() { return /* binding */ computeBinaryImage; });
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "Tracer", function() { return /* binding */ Tracer; });
__webpack_require__.d(__webpack_exports__, "DILATE", function() { return /* binding */ DILATE; });
__webpack_require__.d(__webpack_exports__, "ERODE", function() { return /* binding */ ERODE; });
__webpack_require__.d(__webpack_exports__, "dilate", function() { return /* binding */ dilate; });
__webpack_require__.d(__webpack_exports__, "erode", function() { return /* binding */ erode; });
__webpack_require__.d(__webpack_exports__, "subtract", function() { return /* binding */ subtract; });
__webpack_require__.d(__webpack_exports__, "bitwiseOr", function() { return /* binding */ bitwiseOr; });
__webpack_require__.d(__webpack_exports__, "countNonZero", function() { return /* binding */ countNonZero; });
__webpack_require__.d(__webpack_exports__, "topGeneric", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function() { return /* binding */ grayArrayFromImage; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function() { return /* binding */ grayArrayFromContext; });
__webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "computeGray", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return /* binding */ loadImageArray; });
__webpack_require__.d(__webpack_exports__, "halfSample", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "_computeDivisors", function() { return /* binding */ _computeDivisors; });
__webpack_require__.d(__webpack_exports__, "calculatePatchSize", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function() { return /* binding */ _parseCSSDimensionValues; });
__webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function() { return /* binding */ _dimensionsConverters; });
__webpack_require__.d(__webpack_exports__, "computeImageArea", function() { return /* binding */ computeImageArea; });

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(100);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(38);
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = Object.create(__webpack_require__(27));
util.inherits = __webpack_require__(22);
/*</replacement>*/

var Readable = __webpack_require__(94);

var Writable = __webpack_require__(55);

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(179),
    createAssigner = __webpack_require__(234);
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
module.exports = merge;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(244);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(245);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(80);
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),
/* 23 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(32),
    getRawTag = __webpack_require__(192),
    objectToString = __webpack_require__(193);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(277);

var ieee754 = __webpack_require__(278);

var isArray = __webpack_require__(279);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(26).Buffer))

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(102);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(103);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if ( true && _config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if ( true && _config.debug.showPatches) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if ( true && _config.debug.boxFromPatches.showTransformed) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if ( true && _config.debug.boxFromPatches.showTransformedBox) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if ( true && _config.debug.boxFromPatches.showBB) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if ( true && _config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if ( true && _config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      } // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if ( true && _config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if ( true && _config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
          _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if ( true && _config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));
  }
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if ( true && _config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
        _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

    if (true) {
      console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(181),
    listCacheDelete = __webpack_require__(182),
    listCacheGet = __webpack_require__(183),
    listCacheHas = __webpack_require__(184),
    listCacheSet = __webpack_require__(185);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(31);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(20);
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(206);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(221),
    isObjectLike = __webpack_require__(21);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(14),
    isKey = __webpack_require__(249),
    stringToPath = __webpack_require__(250),
    toString = __webpack_require__(253);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(107);

var iterableToArrayLimit = __webpack_require__(108);

var unsupportedIterableToArray = __webpack_require__(56);

var nonIterableRest = __webpack_require__(109);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(241);

var iterableToArray = __webpack_require__(242);

var unsupportedIterableToArray = __webpack_require__(56);

var nonIterableSpread = __webpack_require__(243);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(265),
  transpose: __webpack_require__(266),
  multiply: __webpack_require__(267),
  identity: __webpack_require__(268),
  adjoint: __webpack_require__(269),
  rotate: __webpack_require__(270),
  invert: __webpack_require__(271),
  create: __webpack_require__(272),
  scale: __webpack_require__(273),
  copy: __webpack_require__(274),
  frob: __webpack_require__(275),
  ldu: __webpack_require__(276)
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(191),
    getValue = __webpack_require__(197);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(25),
    isObject = __webpack_require__(13);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(83);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(44),
    isLength = __webpack_require__(48);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(25),
    isObjectLike = __webpack_require__(21);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(49);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var iota = __webpack_require__(281);

var isBuffer = __webpack_require__(282);

var hasTypedArrays = typeof Float64Array !== "undefined";

function compare1st(a, b) {
  return a[0] - b[0];
}

function order() {
  var stride = this.stride;
  var terms = new Array(stride.length);
  var i;

  for (i = 0; i < terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i];
  }

  terms.sort(compare1st);
  var result = new Array(terms.length);

  for (i = 0; i < result.length; ++i) {
    result[i] = terms[i][1];
  }

  return result;
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("");

  if (dimension < 0) {
    className = "View_Nil" + dtype;
  }

  var useGetters = dtype === "generic";

  if (dimension === -1) {
    //Special case for trivial arrays
    var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
    var procedure = new Function(code);
    return procedure();
  } else if (dimension === 0) {
    //Special case for 0d arrays
    var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
    var procedure = new Function("TrivialArray", code);
    return procedure(CACHED_CONSTRUCTORS[dtype][0]);
  }

  var code = ["'use strict'"]; //Create constructor for view

  var indices = iota(dimension);
  var args = indices.map(function (i) {
    return "i" + i;
  });
  var index_str = "this.offset+" + indices.map(function (i) {
    return "this.stride[" + i + "]*i" + i;
  }).join("+");
  var shapeArg = indices.map(function (i) {
    return "b" + i;
  }).join(",");
  var strideArg = indices.map(function (i) {
    return "c" + i;
  }).join(",");
  code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension); //view.size:

  code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function (i) {
    return "this.shape[" + i + "]";
  }).join("*"), "}})"); //view.order:

  if (dimension === 1) {
    code.push("proto.order=[0]");
  } else {
    code.push("Object.defineProperty(proto,'order',{get:");

    if (dimension < 4) {
      code.push("function " + className + "_order(){");

      if (dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
      } else if (dimension === 3) {
        code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
      }
    } else {
      code.push("ORDER})");
    }
  } //view.set(i0, ..., v):


  code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");

  if (useGetters) {
    code.push("return this.data.set(" + index_str + ",v)}");
  } else {
    code.push("return this.data[" + index_str + "]=v}");
  } //view.get(i0, ...):


  code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");

  if (useGetters) {
    code.push("return this.data.get(" + index_str + ")}");
  } else {
    code.push("return this.data[" + index_str + "]}");
  } //view.index:


  code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}"); //view.hi():

  code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function (i) {
    return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("");
  }).join(",") + "," + indices.map(function (i) {
    return "this.stride[" + i + "]";
  }).join(",") + ",this.offset)}"); //view.lo():

  var a_vars = indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  });
  var c_vars = indices.map(function (i) {
    return "c" + i + "=this.stride[" + i + "]";
  });
  code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
  }

  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "c" + i;
  }).join(",") + ",b)}"); //view.step():

  code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i + "=this.stride[" + i + "]";
  }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
  }

  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i;
  }).join(",") + ",c)}"); //view.transpose():

  var tShape = new Array(dimension);
  var tStride = new Array(dimension);

  for (var i = 0; i < dimension; ++i) {
    tShape[i] = "a[i" + i + "]";
    tStride[i] = "b[i" + i + "]";
  }

  code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function (n, idx) {
    return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
  }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"); //view.pick():

  code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
  }

  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"); //Add return statement

  code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function (i) {
    return "shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "stride[" + i + "]";
  }).join(",") + ",offset)}"); //Compile procedure

  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
  return procedure(CACHED_CONSTRUCTORS[dtype], order);
}

function arrayDType(data) {
  if (isBuffer(data)) {
    return "buffer";
  }

  if (hasTypedArrays) {
    switch (Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64";

      case "[object Float32Array]":
        return "float32";

      case "[object Int8Array]":
        return "int8";

      case "[object Int16Array]":
        return "int16";

      case "[object Int32Array]":
        return "int32";

      case "[object Uint8Array]":
        return "uint8";

      case "[object Uint16Array]":
        return "uint16";

      case "[object Uint32Array]":
        return "uint32";

      case "[object Uint8ClampedArray]":
        return "uint8_clamped";

      case "[object BigInt64Array]":
        return "bigint64";

      case "[object BigUint64Array]":
        return "biguint64";
    }
  }

  if (Array.isArray(data)) {
    return "array";
  }

  return "generic";
}

var CACHED_CONSTRUCTORS = {
  "float32": [],
  "float64": [],
  "int8": [],
  "int16": [],
  "int32": [],
  "uint8": [],
  "uint16": [],
  "uint32": [],
  "array": [],
  "uint8_clamped": [],
  "bigint64": [],
  "biguint64": [],
  "buffer": [],
  "generic": []
};

(function () {
  for (var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if (data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0];
    return ctor([]);
  } else if (typeof data === "number") {
    data = [data];
  }

  if (shape === undefined) {
    shape = [data.length];
  }

  var d = shape.length;

  if (stride === undefined) {
    stride = new Array(d);

    for (var i = d - 1, sz = 1; i >= 0; --i) {
      stride[i] = sz;
      sz *= shape[i];
    }
  }

  if (offset === undefined) {
    offset = 0;

    for (var i = 0; i < d; ++i) {
      if (stride[i] < 0) {
        offset -= (shape[i] - 1) * stride[i];
      }
    }
  }

  var dtype = arrayDType(data);
  var ctor_list = CACHED_CONSTRUCTORS[dtype];

  while (ctor_list.length <= d + 1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
  }

  var ctor = ctor_list[d + 1];
  return ctor(data, shape, stride, offset);
}

module.exports = wrappedNDArrayCtor;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(94);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(55);
exports.Duplex = __webpack_require__(16);
exports.Transform = __webpack_require__(98);
exports.PassThrough = __webpack_require__(300);

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(26);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(38);
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(__webpack_require__(27));
util.inherits = __webpack_require__(22);
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(298)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(95);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(54).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(96);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(16);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(16); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(296).setImmediate, __webpack_require__(12)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(57);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43),
    root = __webpack_require__(20);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(198),
    mapCacheDelete = __webpack_require__(205),
    mapCacheGet = __webpack_require__(207),
    mapCacheHas = __webpack_require__(208),
    mapCacheSet = __webpack_require__(209);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(45),
    eq = __webpack_require__(31);
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(220);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 85 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(20),
    stubFalse = __webpack_require__(223);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)(module)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(225),
    baseUnary = __webpack_require__(226),
    nodeUtil = __webpack_require__(227);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(45),
    eq = __webpack_require__(31);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(230),
    baseKeysIn = __webpack_require__(232),
    isArrayLike = __webpack_require__(47);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 91 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(236);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(237),
    shortOut = __webpack_require__(239);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(38);
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(292);
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(52).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(95);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(54).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = Object.create(__webpack_require__(27));
util.inherits = __webpack_require__(22);
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(293);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


var BufferList = __webpack_require__(294);

var destroyImpl = __webpack_require__(96);

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(16);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(97).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(16);
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(97).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12), __webpack_require__(15)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(52).EventEmitter;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(38);
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(299).Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(16);
/*<replacement>*/


var util = Object.create(__webpack_require__(27));
util.inherits = __webpack_require__(22);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var CVUtils = __webpack_require__(8);

var Ndarray = __webpack_require__(51);

var Interp2D = __webpack_require__(306).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream) {
  var _that = {};

  var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

  var _topRight = inputStream.getTopRight();

  var _data = new Uint8Array(_size.x * _size.y);

  var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

  var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
  /* eslint-disable new-cap */


  var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

  var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

  var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

  var _stepSizeX = _videoSize.x / _canvasSize.x;

  var _stepSizeY = _videoSize.y / _canvasSize.y;

  if (true) {
    console.log('FrameGrabber', JSON.stringify({
      videoSize: _grayImageArray.shape,
      canvasSize: _canvasImageArray.shape,
      stepSize: [_stepSizeX, _stepSizeY],
      size: _targetImageArray.shape,
      topRight: _topRight
    }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var frame = inputStream.getFrame();

    if (frame) {
      this.scaleAndCrop(frame);
      return true;
    }

    return false;
  }; // eslint-disable-next-line


  _that.scaleAndCrop = function (frame) {
    // 1. compute full-sized gray image
    CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

    for (var y = 0; y < _canvasSize.y; y++) {
      for (var x = 0; x < _canvasSize.x; x++) {
        // eslint-disable-next-line no-bitwise
        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
      }
    } // targetImageArray must be equal to targetSize


    if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
      throw new Error('Shapes do not match!');
    } // 3. crop


    for (var _y = 0; _y < _size.y; _y++) {
      for (var _x = 0; _x < _size.x; _x++) {
        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
      }
    }
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(67),
  create: __webpack_require__(68),
  clone: __webpack_require__(145),
  angle: __webpack_require__(146),
  fromValues: __webpack_require__(69),
  copy: __webpack_require__(147),
  set: __webpack_require__(148),
  equals: __webpack_require__(149),
  exactEquals: __webpack_require__(150),
  add: __webpack_require__(151),
  subtract: __webpack_require__(72),
  sub: __webpack_require__(152),
  multiply: __webpack_require__(73),
  mul: __webpack_require__(153),
  divide: __webpack_require__(74),
  div: __webpack_require__(154),
  min: __webpack_require__(155),
  max: __webpack_require__(156),
  floor: __webpack_require__(157),
  ceil: __webpack_require__(158),
  round: __webpack_require__(159),
  scale: __webpack_require__(160),
  scaleAndAdd: __webpack_require__(161),
  distance: __webpack_require__(75),
  dist: __webpack_require__(162),
  squaredDistance: __webpack_require__(76),
  sqrDist: __webpack_require__(163),
  length: __webpack_require__(77),
  len: __webpack_require__(164),
  squaredLength: __webpack_require__(78),
  sqrLen: __webpack_require__(165),
  negate: __webpack_require__(166),
  inverse: __webpack_require__(167),
  normalize: __webpack_require__(70),
  dot: __webpack_require__(71),
  cross: __webpack_require__(168),
  lerp: __webpack_require__(169),
  random: __webpack_require__(170),
  transformMat4: __webpack_require__(171),
  transformMat3: __webpack_require__(172),
  transformQuat: __webpack_require__(173),
  rotateX: __webpack_require__(174),
  rotateY: __webpack_require__(175),
  rotateZ: __webpack_require__(176),
  forEach: __webpack_require__(177)
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(246),
    flatRest = __webpack_require__(260);
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

var path = __webpack_require__(280);

var ndarray = __webpack_require__(51);

var GifReader = __webpack_require__(283).GifReader;

var pack = __webpack_require__(284);

var through = __webpack_require__(290);

var parseDataURI = __webpack_require__(305);

function defaultImage(url, cb) {
  var img = new Image();
  img.crossOrigin = "Anonymous";

  img.onload = function () {
    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var context = canvas.getContext('2d');
    context.drawImage(img, 0, 0);
    var pixels = context.getImageData(0, 0, img.width, img.height);
    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0));
  };

  img.onerror = function (err) {
    cb(err);
  };

  img.src = url;
} //Animated gif loading


function handleGif(data, cb) {
  var reader;

  try {
    reader = new GifReader(data);
  } catch (err) {
    cb(err);
    return;
  }

  if (reader.numFrames() > 0) {
    var nshape = [reader.numFrames(), reader.height, reader.width, 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);
    var result = ndarray(ndata, nshape);

    try {
      for (var i = 0; i < reader.numFrames(); ++i) {
        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(result.index(i, 0, 0, 0), result.index(i + 1, 0, 0, 0)));
      }
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, result.transpose(0, 2, 1));
  } else {
    var nshape = [reader.height, reader.width, 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
    var result = ndarray(ndata, nshape);

    try {
      reader.decodeAndBlitFrameRGBA(0, ndata);
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, result.transpose(1, 0));
  }
}

function httpGif(url, cb) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url, true);
  xhr.responseType = 'arraybuffer';

  if (xhr.overrideMimeType) {
    xhr.overrideMimeType('application/binary');
  }

  xhr.onerror = function (err) {
    cb(err);
  };

  xhr.onload = function () {
    if (xhr.readyState !== 4) {
      return;
    }

    var data = new Uint8Array(xhr.response);
    handleGif(data, cb);
    return;
  };

  xhr.send();
}

function copyBuffer(buffer) {
  if (buffer[0] === undefined) {
    var n = buffer.length;
    var result = new Uint8Array(n);

    for (var i = 0; i < n; ++i) {
      result[i] = buffer.get(i);
    }

    return result;
  } else {
    return new Uint8Array(buffer);
  }
}

function dataGif(url, cb) {
  process.nextTick(function () {
    try {
      var buffer = parseDataURI(url);

      if (buffer) {
        handleGif(copyBuffer(buffer), cb);
      } else {
        cb(new Error('Error parsing data URI'));
      }
    } catch (err) {
      cb(err);
    }
  });
}

module.exports = function getPixels(url, type, cb) {
  if (!cb) {
    cb = type;
    type = '';
  }

  var ext = path.extname(url);

  switch (type || ext.toUpperCase()) {
    case '.GIF':
      httpGif(url, cb);
      break;

    default:
      if (Buffer.isBuffer(url)) {
        url = 'data:' + type + ';base64,' + url.toString('base64');
      }

      if (url.indexOf('data:image/gif;') === 0) {
        dataGif(url, cb);
      } else {
        defaultImage(url, cb);
      }

  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(26).Buffer))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(307);


/***/ }),
/* 106 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(58);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(60);

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(61);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(62);

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(63);

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(64);

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(65);

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(66);

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(59)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(69);

var normalize = __webpack_require__(70);

var dot = __webpack_require__(71);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 147 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(67);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(72);

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(73);

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(74);

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(75);

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(76);

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(77);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(78);

/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 175 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(68)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 178 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(180),
    assignMergeValue = __webpack_require__(82),
    baseFor = __webpack_require__(210),
    baseMergeDeep = __webpack_require__(212),
    isObject = __webpack_require__(13),
    keysIn = __webpack_require__(90),
    safeGet = __webpack_require__(88);
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(29),
    stackClear = __webpack_require__(186),
    stackDelete = __webpack_require__(187),
    stackGet = __webpack_require__(188),
    stackHas = __webpack_require__(189),
    stackSet = __webpack_require__(190);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 181 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(29);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 187 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 188 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 189 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(29),
    Map = __webpack_require__(79),
    MapCache = __webpack_require__(81);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(44),
    isMasked = __webpack_require__(194),
    isObject = __webpack_require__(13),
    toSource = __webpack_require__(196);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(32);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 193 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(195);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(20);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 196 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 197 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(199),
    ListCache = __webpack_require__(29),
    Map = __webpack_require__(79);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(200),
    hashDelete = __webpack_require__(201),
    hashGet = __webpack_require__(202),
    hashHas = __webpack_require__(203),
    hashSet = __webpack_require__(204);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(33);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 201 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(33);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(33);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(33);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(34);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 206 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(34);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(34);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(34);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(211);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 211 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(82),
    cloneBuffer = __webpack_require__(213),
    cloneTypedArray = __webpack_require__(214),
    copyArray = __webpack_require__(217),
    initCloneObject = __webpack_require__(218),
    isArguments = __webpack_require__(35),
    isArray = __webpack_require__(14),
    isArrayLikeObject = __webpack_require__(222),
    isBuffer = __webpack_require__(86),
    isFunction = __webpack_require__(44),
    isObject = __webpack_require__(13),
    isPlainObject = __webpack_require__(224),
    isTypedArray = __webpack_require__(87),
    safeGet = __webpack_require__(88),
    toPlainObject = __webpack_require__(228);
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(20);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)(module)))

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(215);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(216);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(20);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 217 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(219),
    getPrototype = __webpack_require__(84),
    isPrototype = __webpack_require__(85);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(13);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 220 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(25),
    isObjectLike = __webpack_require__(21);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(47),
    isObjectLike = __webpack_require__(21);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 223 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(25),
    getPrototype = __webpack_require__(84),
    isObjectLike = __webpack_require__(21);
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(25),
    isLength = __webpack_require__(48),
    isObjectLike = __webpack_require__(21);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 226 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(80);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)(module)))

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(229),
    keysIn = __webpack_require__(90);
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(89),
    baseAssignValue = __webpack_require__(45);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(231),
    isArguments = __webpack_require__(35),
    isArray = __webpack_require__(14),
    isBuffer = __webpack_require__(86),
    isIndex = __webpack_require__(36),
    isTypedArray = __webpack_require__(87);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 231 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(13),
    isPrototype = __webpack_require__(85),
    nativeKeysIn = __webpack_require__(233);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 233 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(235),
    isIterateeCall = __webpack_require__(240);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(91),
    overRest = __webpack_require__(92),
    setToString = __webpack_require__(93);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 236 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(238),
    defineProperty = __webpack_require__(83),
    identity = __webpack_require__(91);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 238 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 239 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(31),
    isArrayLike = __webpack_require__(47),
    isIndex = __webpack_require__(36),
    isObject = __webpack_require__(13);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(57);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 242 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 243 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(247),
    hasIn = __webpack_require__(257);
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(248),
    baseSet = __webpack_require__(256),
    castPath = __webpack_require__(37);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(37),
    toKey = __webpack_require__(50);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(14),
    isSymbol = __webpack_require__(49);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(251);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(252);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(81);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(254);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(32),
    arrayMap = __webpack_require__(255),
    isArray = __webpack_require__(14),
    isSymbol = __webpack_require__(49);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 255 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(89),
    castPath = __webpack_require__(37),
    isIndex = __webpack_require__(36),
    isObject = __webpack_require__(13),
    toKey = __webpack_require__(50);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(258),
    hasPath = __webpack_require__(259);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 258 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(37),
    isArguments = __webpack_require__(35),
    isArray = __webpack_require__(14),
    isIndex = __webpack_require__(36),
    isLength = __webpack_require__(48),
    toKey = __webpack_require__(50);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(261),
    overRest = __webpack_require__(92),
    setToString = __webpack_require__(93);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(262);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(263),
    isFlattenable = __webpack_require__(264);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 263 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(32),
    isArguments = __webpack_require__(35),
    isArray = __webpack_require__(14);
/** Built-in value references. */


var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 265 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 267 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 268 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 269 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 270 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 271 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 272 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 273 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 274 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 275 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 278 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 279 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47
  /*/*/
  ;
  var end = -1;
  var matchedSlash = true;

  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';

  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }

  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';
  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
} // Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here


exports.basename = function (path, ext) {
  var f = basename(path);

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find

  var preDotState = 0;

  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }

    if (code === 46
    /*.*/
    ) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }

  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function iota(n) {
  var result = new Array(n);

  for (var i = 0; i < n; ++i) {
    result[i] = i;
  }

  return result;
}

module.exports = iota;

/***/ }),
/* 282 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.


function GifWriter(buf, width, height, gopts) {
  var p = 0;
  var gopts = gopts === undefined ? {} : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;
  if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;

    if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
      throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
    }

    return num_colors;
  } // - Header.


  buf[p++] = 0x47;
  buf[p++] = 0x49;
  buf[p++] = 0x46; // GIF

  buf[p++] = 0x38;
  buf[p++] = 0x39;
  buf[p++] = 0x61; // 89a
  // Handling of Global Color Table (palette) and background index.

  var gp_num_colors_pow2 = 0;
  var background = 0;

  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);

    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;

    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;

    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors) throw new Error("Background index out of range."); // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).

      if (background === 0) throw new Error("Background index explicitly passed as 0.");
    }
  } // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.


  buf[p++] = width & 0xff;
  buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff;
  buf[p++] = height >> 8 & 0xff; // NOTE: Indicates 0-bpp original color resolution (unused?).

  buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.
  gp_num_colors_pow2; // NOTE: No sort flag (unused?).

  buf[p++] = background; // Background Color Index.

  buf[p++] = 0; // Pixel aspect ratio (unused?).
  // - Global Color Table

  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {
    // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid."); // Extension code, label, and length.

    buf[p++] = 0x21;
    buf[p++] = 0xff;
    buf[p++] = 0x0b; // NETSCAPE2.0

    buf[p++] = 0x4e;
    buf[p++] = 0x45;
    buf[p++] = 0x54;
    buf[p++] = 0x53;
    buf[p++] = 0x43;
    buf[p++] = 0x41;
    buf[p++] = 0x50;
    buf[p++] = 0x45;
    buf[p++] = 0x32;
    buf[p++] = 0x2e;
    buf[p++] = 0x30; // Sub-block

    buf[p++] = 0x03;
    buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff;
    buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00; // Terminator.
  }

  var ended = false;

  this.addFrame = function (x, y, w, h, indexed_pixels, opts) {
    if (ended === true) {
      --p;
      ended = false;
    } // Un-end.


    opts = opts === undefined ? {} : opts; // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?

    if (x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
    if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
    if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
    var using_local_palette = true;
    var palette = opts.palette;

    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null) throw new Error("Must supply either a local or global palette.");
    var num_colors = check_palette_and_num_colors(palette); // Compute the min_code_size (power of 2), destroying num_colors.

    var min_code_size = 0;

    while (num_colors >>= 1) ++min_code_size;

    num_colors = 1 << min_code_size; // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay; // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.

    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3) // 4-7 is reserved.
      throw new Error("Disposal out of range.");
    var use_transparency = false;
    var transparent_index = 0;

    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors) throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21;
      buf[p++] = 0xf9; // Extension / Label.

      buf[p++] = 4; // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff;
      buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index; // Transparent color index.

      buf[p++] = 0; // Block Terminator.
    } // - Image Descriptor


    buf[p++] = 0x2c; // Image Seperator.

    buf[p++] = x & 0xff;
    buf[p++] = x >> 8 & 0xff; // Left.

    buf[p++] = y & 0xff;
    buf[p++] = y >> 8 & 0xff; // Top.

    buf[p++] = w & 0xff;
    buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff;
    buf[p++] = h >> 8 & 0xff; // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.

    buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0; // - Local Color Table

    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
    return p;
  };

  this.end = function () {
    if (ended === false) {
      buf[p++] = 0x3b; // Trailer.

      ended = true;
    }

    return p;
  };

  this.getOutputBuffer = function () {
    return buf;
  };

  this.setOutputBuffer = function (v) {
    buf = v;
  };

  this.getOutputBufferPosition = function () {
    return p;
  };

  this.setOutputBufferPosition = function (v) {
    p = v;
  };
} // Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.


function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++; // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1; // Number of bits per code.

  var cur_shift = 0; // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).

  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8;
      cur_shift -= 8;

      if (p === cur_subblock + 256) {
        // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  } // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.
  // Output code for the current contents of the index buffer.


  var ib_code = index_stream[0] & code_mask; // Load first input index.

  var code_table = {}; // Key'd on our 20-bit "tuple".

  emit_code(clear_code); // Spec says first code should be a clear code.
  // First index already loaded, process the rest of the stream.

  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.

    var cur_code = code_table[cur_key]; // buffer + k.
    // Check if we have to create a new code table entry.

    if (cur_code === undefined) {
      // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;

      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8;
        cur_shift -= 8;

        if (p === cur_subblock + 256) {
          // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {
        // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = {};
      } else {
        // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= 1 << cur_code_size) ++cur_code_size;
        code_table[cur_key] = next_code++; // Insert into code table.
      }

      ib_code = k; // Index buffer to single input k.
    } else {
      ib_code = cur_code; // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code); // There will still be something in the index buffer.

  emit_code(eoi_code); // End Of Information.
  // Flush / finalize the sub-blocks stream to the buffer.

  emit_bytes_to_buffer(1); // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.

  if (cur_subblock + 1 === p) {
    // Started but unused.
    buf[cur_subblock] = 0;
  } else {
    // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }

  return p;
}

function GifReader(buf) {
  var p = 0; // - Header (GIF87a or GIF89a).

  if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 || buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  } // - Logical Screen Descriptor.


  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++]; // <Packed Fields>.

  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << num_global_colors_pow2 + 1;
  var background = buf[p++];
  buf[p++]; // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3; // Seek past palette.
  }

  var no_eof = true;
  var frames = [];
  var delay = 0;
  var transparent_index = null;
  var disposal = 0; // 0 - No disposal specified.

  var loop_count = null;
  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:
        // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:
            // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p] !== 0x0b || // 21 FF already read, check block size.
            // NETSCAPE2.0
            buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 && buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 && buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 && buf[p + 10] == 0x2e && buf[p + 11] == 0x30 && // Sub-block
            buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++; // Skip terminator.
            } else {
              // We don't know what it is, just try to get past it.
              p += 12;

              while (true) {
                // Seek through subblocks.
                var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break; // 0 size is terminator

                p += block_size;
              }
            }

            break;

          case 0xf9:
            // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p + 4] !== 0) throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++; // Skip terminator.

            break;

          case 0xfe:
            // Comment Extension.
            while (true) {
              // Seek through subblocks.
              var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break; // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));

              p += block_size;
            }

            break;

          default:
            throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
        }

        break;

      case 0x2c:
        // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << num_local_colors_pow2 + 1;
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;

        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p; // Override with local palette.

          palette_size = num_local_colors;
          p += num_local_colors * 3; // Seek past palette.
        }

        var data_offset = p;
        p++; // codesize

        while (true) {
          var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break; // 0 size is terminator

          p += block_size;
        }

        frames.push({
          x: x,
          y: y,
          width: w,
          height: h,
          has_local_palette: has_local_palette,
          palette_offset: palette_offset,
          palette_size: palette_size,
          data_offset: data_offset,
          data_length: p - data_offset,
          transparent_index: transparent_index,
          interlaced: !!interlace_flag,
          delay: delay,
          disposal: disposal
        });
        break;

      case 0x3b:
        // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
        break;
    }
  }

  this.numFrames = function () {
    return frames.length;
  };

  this.loopCount = function () {
    return loop_count;
  };

  this.frameInfo = function (frame_num) {
    if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
    return frames[frame_num];
  };

  this.decodeAndBlitFrameBGRA = function (frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.

    var trans = frame.transparent_index;
    if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.

    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth; // Number of subrect pixels left in scanline.
    // Output indicies of the top left and bottom right corners of the subrect.

    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.

    if (frame.interlaced === true) {
      scanstride += width * 4 * 7; // Pass 1.
    }

    var interlaceskip = 8; // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {
        // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;

        if (op >= opend) {
          // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }

      --xleft;
    }
  }; // I will go to copy and paste hell one day...


  this.decodeAndBlitFrameRGBA = function (frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.

    var trans = frame.transparent_index;
    if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.

    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth; // Number of subrect pixels left in scanline.
    // Output indicies of the top left and bottom right corners of the subrect.

    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.

    if (frame.interlaced === true) {
      scanstride += width * 4 * 7; // Pass 1.
    }

    var interlaceskip = 8; // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {
        // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;

        if (op >= opend) {
          // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }

      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];
  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1; // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.

  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;
  var op = 0; // Output pointer.

  var subblock_size = code_stream[p++]; // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);

  var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.

  var prev_code = null; // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break; // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {
        // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++]; // Next subblock.
      } else {
        --subblock_size;
      }
    } // TODO(deanm): We should never really get here, we should have received
    // and EOI.


    if (cur_shift < cur_code_size) break;
    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size; // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.

    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.
      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1; // Don't update prev_code ?

      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    } // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.


    var chase_code = code < next_code ? code : prev_code; // Chase what we will output, either {CODE} or {CODE-1}.

    var chase_length = 0;
    var chase = chase_code;

    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;
    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);

    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    } // Already have the first byte from the chase, might as well write it fast.


    output[op++] = k;
    op += chase_length;
    var b = op; // Track pointer, writing backwards.

    if (chase_code !== code) // The case of emitting {CODE-1} + k.
      output[op++] = k;
    chase = chase_code;

    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff; // Write backwards.

      chase >>= 8; // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k; // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).

      if (next_code >= code_mask + 1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
} // CommonJS.


try {
  exports.GifWriter = GifWriter;
  exports.GifReader = GifReader;
} catch (e) {}

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ndarray = __webpack_require__(51);

var do_convert = __webpack_require__(285);

module.exports = function convert(arr, result) {
  var shape = [],
      c = arr,
      sz = 1;

  while (Array.isArray(c)) {
    shape.push(c.length);
    sz *= c.length;
    c = c[0];
  }

  if (shape.length === 0) {
    return ndarray();
  }

  if (!result) {
    result = ndarray(new Float64Array(sz), shape);
  }

  do_convert(result, arr);
  return result;
};

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(286)({
  "args": ["array", "scalar", "index"],
  "pre": {
    "body": "{}",
    "args": [],
    "thisVars": [],
    "localVars": []
  },
  "body": {
    "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
    "args": [{
      "name": "_inline_1_arg0_",
      "lvalue": true,
      "rvalue": false,
      "count": 1
    }, {
      "name": "_inline_1_arg1_",
      "lvalue": false,
      "rvalue": true,
      "count": 1
    }, {
      "name": "_inline_1_arg2_",
      "lvalue": false,
      "rvalue": true,
      "count": 4
    }],
    "thisVars": [],
    "localVars": ["_inline_1_i", "_inline_1_v"]
  },
  "post": {
    "body": "{}",
    "args": [],
    "thisVars": [],
    "localVars": []
  },
  "funcName": "convert",
  "blockSize": 64
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createThunk = __webpack_require__(287);

function Procedure() {
  this.argTypes = [];
  this.shimArgs = [];
  this.arrayArgs = [];
  this.arrayBlockIndices = [];
  this.scalarArgs = [];
  this.offsetArgs = [];
  this.offsetArgIndex = [];
  this.indexArgs = [];
  this.shapeArgs = [];
  this.funcName = "";
  this.pre = null;
  this.body = null;
  this.post = null;
  this.debug = false;
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure(); //Parse blocks

  proc.pre = user_args.pre;
  proc.body = user_args.body;
  proc.post = user_args.post; //Parse arguments

  var proc_args = user_args.args.slice(0);
  proc.argTypes = proc_args;

  for (var i = 0; i < proc_args.length; ++i) {
    var arg_type = proc_args[i];

    if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
      proc.argTypes[i] = "array";
      proc.arrayArgs.push(i);
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
      proc.shimArgs.push("array" + i);

      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array args");
      }

      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array args");
      }
    } else if (arg_type === "scalar") {
      proc.scalarArgs.push(i);
      proc.shimArgs.push("scalar" + i);
    } else if (arg_type === "index") {
      proc.indexArgs.push(i);

      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index");
      }

      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index");
      }

      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index");
      }
    } else if (arg_type === "shape") {
      proc.shapeArgs.push(i);

      if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape");
      }

      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape");
      }

      if (i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape");
      }
    } else if (typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset";
      proc.offsetArgs.push({
        array: arg_type.array,
        offset: arg_type.offset
      });
      proc.offsetArgIndex.push(i);
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
  } //Make sure at least one array argument was specified


  if (proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified");
  } //Make sure arguments are correct


  if (proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block");
  }

  if (proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block");
  }

  if (proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block");
  } //Check debug flag


  proc.debug = !!user_args.printCode || !!user_args.debug; //Retrieve name

  proc.funcName = user_args.funcName || "cwise"; //Read in block size

  proc.blockSize = user_args.blockSize || 64;
  return createThunk(proc);
}

module.exports = compileCwise;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = __webpack_require__(288);

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"];
  var vars = [];
  var thunkName = proc.funcName + "_cwise_thunk"; //Build thunk

  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
  var typesig = [];
  var string_typesig = [];
  var proc_args = [["array", proc.arrayArgs[0], ".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
  Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"].join("")];
  var shapeLengthConditions = [],
      shapeConditions = []; // Process array arguments

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i];
    vars.push(["t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order"].join(""));
    typesig.push("t" + j);
    typesig.push("r" + j);
    string_typesig.push("t" + j);
    string_typesig.push("r" + j + ".join()");
    proc_args.push("array" + j + ".data");
    proc_args.push("array" + j + ".stride");
    proc_args.push("array" + j + ".offset|0");

    if (i > 0) {
      // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
    }
  } // Check for shape equality


  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
    code.push("}");
  } // Process scalar arguments


  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i]);
  } // Check for cached function (and if not present, generate it)


  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
  vars.push("proc=CACHED[type]");
  code.push("var " + vars.join(","));
  code.push(["if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}"].join(""));

  if (proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
  } //Compile thunk


  var thunk = new Function("compile", code.join("\n"));
  return thunk(compile.bind(undefined, proc));
}

module.exports = createThunk;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uniq = __webpack_require__(289); // This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.


function innerFill(order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      has_index = proc.indexArgs.length > 0,
      code = [],
      vars = [],
      idx = 0,
      pidx = 0,
      i,
      j;

  for (i = 0; i < dimension; ++i) {
    // Iteration variables
    vars.push(["i", i, "=0"].join(""));
  } //Compute scan deltas


  for (j = 0; j < nargs; ++j) {
    for (i = 0; i < dimension; ++i) {
      pidx = idx;
      idx = order[i];

      if (i === 0) {
        // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
      } else {
        // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
      }
    }
  }

  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  } //Scan loop


  for (i = dimension - 1; i >= 0; --i) {
    // Start at largest stride and work your way inwards
    idx = order[i];
    code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
  } //Push body of inner loop


  code.push(body); //Advance scan pointers

  for (i = 0; i < dimension; ++i) {
    pidx = idx;
    idx = order[i];

    for (j = 0; j < nargs; ++j) {
      code.push(["p", j, "+=d", j, "s", i].join(""));
    }

    if (has_index) {
      if (i > 0) {
        code.push(["index[", pidx, "]-=s", pidx].join(""));
      }

      code.push(["++index[", idx, "]"].join(""));
    }

    code.push("}");
  }

  return code.join("\n");
} // Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.


function outerFill(matched, order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      blockSize = proc.blockSize,
      has_index = proc.indexArgs.length > 0,
      code = [];

  for (var i = 0; i < nargs; ++i) {
    code.push(["var offset", i, "=p", i].join(""));
  } //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).


  for (var i = matched; i < dimension; ++i) {
    code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join("")); // Iterate back to front

    code.push(["if(j", i, "<", blockSize, "){"].join("")); // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).

    code.push(["s", order[i], "=j", i].join(""));
    code.push(["j", i, "=0"].join(""));
    code.push(["}else{s", order[i], "=", blockSize].join(""));
    code.push(["j", i, "-=", blockSize, "}"].join(""));

    if (has_index) {
      code.push(["index[", order[i], "]=j", i].join(""));
    }
  }

  for (var i = 0; i < nargs; ++i) {
    var indexStr = ["offset" + i];

    for (var j = matched; j < dimension; ++j) {
      indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
    }

    code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
  }

  code.push(innerFill(order, proc, body));

  for (var i = matched; i < dimension; ++i) {
    code.push("}");
  }

  return code.join("\n");
} //Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.


function countMatches(orders) {
  var matched = 0,
      dimension = orders[0].length;

  while (matched < dimension) {
    for (var j = 1; j < orders.length; ++j) {
      if (orders[j][matched] !== orders[0][matched]) {
        return matched;
      }
    }

    ++matched;
  }

  return matched;
} //Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.


function processBlock(block, proc, dtypes) {
  var code = block.body;
  var pre = [];
  var post = [];

  for (var i = 0; i < block.args.length; ++i) {
    var carg = block.args[i];

    if (carg.count <= 0) {
      continue;
    }

    var re = new RegExp(carg.name, "g");
    var ptrStr = "";
    var arrNum = proc.arrayArgs.indexOf(i);

    switch (proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i);
        var offArg = proc.offsetArgs[offArgIndex];
        arrNum = offArg.array;
        ptrStr = "+q" + offArgIndex;
      // Adds offset to the "pointer" in the array

      case "array":
        ptrStr = "p" + arrNum + ptrStr;
        var localStr = "l" + i;
        var arrStr = "a" + arrNum;

        if (proc.arrayBlockIndices[arrNum] === 0) {
          // Argument to body is just a single value from this array
          if (carg.count === 1) {
            // Argument/array used only once(?)
            if (dtypes[arrNum] === "generic") {
              if (carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)

                code = code.replace(re, localStr);
                post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
            }
          } else if (dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

            code = code.replace(re, localStr);

            if (carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

            code = code.replace(re, localStr);

            if (carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
            }
          }
        } else {
          // Argument to body is a "block"
          var reStrArr = [carg.name],
              ptrStrArr = [ptrStr];

          for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]");
            ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j); // Matched index times stride
          }

          re = new RegExp(reStrArr.join(""), "g");
          ptrStr = ptrStrArr.join("+");

          if (dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!");
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
          }
        }

        break;

      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
        break;

      case "index":
        code = code.replace(re, "index");
        break;

      case "shape":
        code = code.replace(re, "shape");
        break;
    }
  }

  return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length);
  var allEqual = true;

  for (var i = 0; i < dtypes.length; ++i) {
    var t = dtypes[i];
    var digits = t.match(/\d+/);

    if (!digits) {
      digits = "";
    } else {
      digits = digits[0];
    }

    if (t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits;
    } else {
      summary[i] = t.charAt(0) + digits;
    }

    if (i > 0) {
      allEqual = allEqual && summary[i] === summary[i - 1];
    }
  }

  if (allEqual) {
    return summary[0];
  }

  return summary.join("");
} //Generates a cwise operator


function generateCWiseOp(proc, typesig) {
  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
  var orders = new Array(proc.arrayArgs.length);
  var dtypes = new Array(proc.arrayArgs.length);

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2 * i];
    orders[i] = typesig[2 * i + 1];
  } //Determine where block and loop indices start and end


  var blockBegin = [],
      blockEnd = []; // These indices are exposed as blocks

  var loopBegin = [],
      loopEnd = []; // These indices are iterated over

  var loopOrders = []; // orders restricted to the loop indices

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i] < 0) {
      loopBegin.push(0);
      loopEnd.push(dimension);
      blockBegin.push(dimension);
      blockEnd.push(dimension + proc.arrayBlockIndices[i]);
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]); // Non-negative

      loopEnd.push(proc.arrayBlockIndices[i] + dimension);
      blockBegin.push(0);
      blockEnd.push(proc.arrayBlockIndices[i]);
    }

    var newOrder = [];

    for (var j = 0; j < orders[i].length; j++) {
      if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
        newOrder.push(orders[i][j] - loopBegin[i]); // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }

    loopOrders.push(newOrder);
  } //First create arguments for procedure


  var arglist = ["SS"]; // SS is the overall shape over which we iterate

  var code = ["'use strict'"];
  var vars = [];

  for (var j = 0; j < dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")); // The limits for each dimension.
  }

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    arglist.push("a" + i); // Actual data array

    arglist.push("t" + i); // Strides

    arglist.push("p" + i); // Offset in the array at which the data starts (also used for iterating over the data)

    for (var j = 0; j < dimension; ++j) {
      // Unpack the strides into vars for looping
      vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
    }

    for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
      // Unpack the strides into vars for block iteration
      vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
    }
  }

  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i);
  }

  if (proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)"); // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }

  if (proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension);

    for (var i = 0; i < dimension; ++i) {
      zeros[i] = "0";
    }

    vars.push(["index=[", zeros.join(","), "]"].join(""));
  }

  for (var i = 0; i < proc.offsetArgs.length; ++i) {
    // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i];
    var init_string = [];

    for (var j = 0; j < off_arg.offset.length; ++j) {
      if (off_arg.offset[j] === 0) {
        continue;
      } else if (off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""));
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
      }
    }

    if (init_string.length === 0) {
      vars.push("q" + i + "=0");
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""));
    }
  } //Prepare this variables


  var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
  vars = vars.concat(thisVars);

  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    code.push("p" + i + "|=0");
  } //Inline prelude


  if (proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes));
  } //Process body


  var body = processBlock(proc.body, proc, dtypes);
  var matched = countMatches(loopOrders);

  if (matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)); // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body));
  } //Inline epilog


  if (proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes));
  }

  if (proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
  }

  var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
  var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
  return f();
}

module.exports = generateCWiseOp;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function unique_pred(list, compare) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];

  for (var i = 1; i < len; ++i) {
    b = a;
    a = list[i];

    if (compare(a, b)) {
      if (i === ptr) {
        ptr++;
        continue;
      }

      list[ptr++] = a;
    }
  }

  list.length = ptr;
  return list;
}

function unique_eq(list) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];

  for (var i = 1; i < len; ++i, b = a) {
    b = a;
    a = list[i];

    if (a !== b) {
      if (i === ptr) {
        ptr++;
        continue;
      }

      list[ptr++] = a;
    }
  }

  list.length = ptr;
  return list;
}

function unique(list, compare, sorted) {
  if (list.length === 0) {
    return list;
  }

  if (compare) {
    if (!sorted) {
      list.sort(compare);
    }

    return unique_pred(list, compare);
  }

  if (!sorted) {
    list.sort();
  }

  return unique_eq(list);
}

module.exports = unique;

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(291); // through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)


exports = module.exports = through;
through.through = through; //create a readable writable stream.

function through(write, end, opts) {
  write = write || function (data) {
    this.queue(data);
  };

  end = end || function () {
    this.queue(null);
  };

  var ended = false,
      destroyed = false,
      buffer = [],
      _ended = false;
  var stream = new Stream();
  stream.readable = stream.writable = true;
  stream.paused = false; //  stream.autoPause   = !(opts && opts.autoPause   === false)

  stream.autoDestroy = !(opts && opts.autoDestroy === false);

  stream.write = function (data) {
    write.call(this, data);
    return !stream.paused;
  };

  function drain() {
    while (buffer.length && !stream.paused) {
      var data = buffer.shift();
      if (null === data) return stream.emit('end');else stream.emit('data', data);
    }
  }

  stream.queue = stream.push = function (data) {
    //    console.error(ended)
    if (_ended) return stream;
    if (data === null) _ended = true;
    buffer.push(data);
    drain();
    return stream;
  }; //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'


  stream.on('end', function () {
    stream.readable = false;
    if (!stream.writable && stream.autoDestroy) process.nextTick(function () {
      stream.destroy();
    });
  });

  function _end() {
    stream.writable = false;
    end.call(stream);
    if (!stream.readable && stream.autoDestroy) stream.destroy();
  }

  stream.end = function (data) {
    if (ended) return;
    ended = true;
    if (arguments.length) stream.write(data);

    _end(); // will emit or queue


    return stream;
  };

  stream.destroy = function () {
    if (destroyed) return;
    destroyed = true;
    ended = true;
    buffer.length = 0;
    stream.writable = stream.readable = false;
    stream.emit('close');
    return stream;
  };

  stream.pause = function () {
    if (stream.paused) return;
    stream.paused = true;
    return stream;
  };

  stream.resume = function () {
    if (stream.paused) {
      stream.paused = false;
      stream.emit('resume');
    }

    drain(); //may have become paused again,
    //as drain emits 'data'.

    if (!stream.paused) stream.emit('drain');
    return stream;
  };

  return stream;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(52).EventEmitter;

var inherits = __webpack_require__(22);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(53);
Stream.Writable = __webpack_require__(301);
Stream.Duplex = __webpack_require__(302);
Stream.Transform = __webpack_require__(303);
Stream.PassThrough = __webpack_require__(304); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),
/* 292 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 293 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(54).Buffer;

var util = __webpack_require__(295);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 295 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(297); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 68
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12), __webpack_require__(15)))

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(26);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(98);
/*<replacement>*/


var util = Object.create(__webpack_require__(27));
util.inherits = __webpack_require__(22);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(16);

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53).Transform;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53).PassThrough;

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Module exports.
 */
module.exports = dataUriToBuffer;
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer(uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  } // strip newlines


  uri = uri.replace(/\r?\n/g, ''); // split the URI up into the "metadata" and the "data" portions

  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI'); // remove the "data:" scheme and parse the metadata

  var meta = uri.substring(5, firstComma).split(';');
  var base64 = false;
  var charset = 'US-ASCII';

  for (var i = 0; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else if (0 == meta[i].indexOf('charset=')) {
      charset = meta[i].substring(8);
    }
  } // get the encoded data portion and decode URI-encoded chars


  var data = unescape(uri.substring(firstComma + 1));
  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = new Buffer(data, encoding); // set `.type` property to MIME type

  buffer.type = meta[0] || 'text/plain'; // set the `.charset` property

  buffer.charset = charset;
  return buffer;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(26).Buffer))

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function interp1d(arr, x) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      w0 = s0 ? +arr.get(ix) : 0.0,
      w1 = s1 ? +arr.get(ix + 1) : 0.0;
  return (1.0 - fx) * w0 + fx * w1;
}

function interp2d(arr, x, y) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      iy = Math.floor(y),
      fy = y - iy,
      t0 = 0 <= iy && iy < arr.shape[1],
      t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
      w00 = s0 && t0 ? arr.get(ix, iy) : 0.0,
      w01 = s0 && t1 ? arr.get(ix, iy + 1) : 0.0,
      w10 = s1 && t0 ? arr.get(ix + 1, iy) : 0.0,
      w11 = s1 && t1 ? arr.get(ix + 1, iy + 1) : 0.0;
  return (1.0 - fy) * ((1.0 - fx) * w00 + fx * w10) + fy * ((1.0 - fx) * w01 + fx * w11);
}

function interp3d(arr, x, y, z) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      iy = Math.floor(y),
      fy = y - iy,
      t0 = 0 <= iy && iy < arr.shape[1],
      t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
      iz = Math.floor(z),
      fz = z - iz,
      u0 = 0 <= iz && iz < arr.shape[2],
      u1 = 0 <= iz + 1 && iz + 1 < arr.shape[2],
      w000 = s0 && t0 && u0 ? arr.get(ix, iy, iz) : 0.0,
      w010 = s0 && t1 && u0 ? arr.get(ix, iy + 1, iz) : 0.0,
      w100 = s1 && t0 && u0 ? arr.get(ix + 1, iy, iz) : 0.0,
      w110 = s1 && t1 && u0 ? arr.get(ix + 1, iy + 1, iz) : 0.0,
      w001 = s0 && t0 && u1 ? arr.get(ix, iy, iz + 1) : 0.0,
      w011 = s0 && t1 && u1 ? arr.get(ix, iy + 1, iz + 1) : 0.0,
      w101 = s1 && t0 && u1 ? arr.get(ix + 1, iy, iz + 1) : 0.0,
      w111 = s1 && t1 && u1 ? arr.get(ix + 1, iy + 1, iz + 1) : 0.0;
  return (1.0 - fz) * ((1.0 - fy) * ((1.0 - fx) * w000 + fx * w100) + fy * ((1.0 - fx) * w010 + fx * w110)) + fz * ((1.0 - fy) * ((1.0 - fx) * w001 + fx * w101) + fy * ((1.0 - fx) * w011 + fx * w111));
}

function interpNd(arr) {
  var d = arr.shape.length | 0,
      ix = new Array(d),
      fx = new Array(d),
      s0 = new Array(d),
      s1 = new Array(d),
      i,
      t;

  for (i = 0; i < d; ++i) {
    t = +arguments[i + 1];
    ix[i] = Math.floor(t);
    fx[i] = t - ix[i];
    s0[i] = 0 <= ix[i] && ix[i] < arr.shape[i];
    s1[i] = 0 <= ix[i] + 1 && ix[i] + 1 < arr.shape[i];
  }

  var r = 0.0,
      j,
      w,
      idx;

  i_loop: for (i = 0; i < 1 << d; ++i) {
    w = 1.0;
    idx = arr.offset;

    for (j = 0; j < d; ++j) {
      if (i & 1 << j) {
        if (!s1[j]) {
          continue i_loop;
        }

        w *= fx[j];
        idx += arr.stride[j] * (ix[j] + 1);
      } else {
        if (!s0[j]) {
          continue i_loop;
        }

        w *= 1.0 - fx[j];
        idx += arr.stride[j] * ix[j];
      }
    }

    r += w * arr.data[idx];
  }

  return r;
}

function interpolate(arr, x, y, z) {
  switch (arr.shape.length) {
    case 0:
      return 0.0;

    case 1:
      return interp1d(arr, x);

    case 2:
      return interp2d(arr, x, y);

    case 3:
      return interp3d(arr, x, y, z);

    default:
      return interpNd.apply(undefined, arguments);
  }
}

module.exports = interpolate;
module.exports.d1 = interp1d;
module.exports.d2 = interp2d;
module.exports.d3 = interp3d;

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "BarcodeReader", function() { return /* reexport */ barcode_reader; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(23);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(106);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(11);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  createClass_default()(BarcodeReader, null, [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this._decode(); // console.warn('* first result=', result);


      if (result === null) {
        this._row.reverse();

        result = this._decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    value: function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(17);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, merge_default()({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
        }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(40);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(18);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    // TODO (this was todo in original repo, no text was there. sorry.)
    value: function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "_decode",
    value: function _decode(row, start) {
      var result = ean_reader.prototype._decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, merge_default()({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return barcode_reader.prototype._matchPattern.call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }

      var res = 0;

      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }

      var code32 = '' + res;

      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }

      return 'A' + code32;
    } // TODO (this was todo in original repo, no text was there. sorry.)

  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!this._checkChecksum(code)) {
        return null;
      }

      var code32 = this._decodeCode32(code);

      if (!code32) {
        return null;
      }

      result.code = code32;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');

        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';

          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }

        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');

        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';

          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }

        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');

        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (true) {
          console.log('Before registering reader: ', reader);
        }

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (true) {
        console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
          return JSON.stringify({
            format: reader.FORMAT,
            config: reader.config
          });
        }).join(', ')));
      }
    }

    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];

        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if ( true && config.debug.showFrequency) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, _canvas.ctx.overlay, {
          color: 'red',
          lineWidth: 3
        });
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }

      bresenham.toBinaryLine(barcodeLine);

      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug["a" /* default */].drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(19);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(41);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(101);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./src/common/mediaDevices.ts
var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Error("enumerateDevices is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Error("getUserMedia is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts




var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Error('Unable to play video stream. Is webcam working?'));
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;
            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && (tracks === null || tracks === void 0 ? void 0 : tracks.length) ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return pickConstraints(videoConstraints);

            case 2:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    // TODO: i wonder if telling the Video element to pause() before calling MediaStreamTrack.stop() would alleviate some of the issues with the camera appearing to stay open on Android even after stopping.
    var tracks = streamRef && streamRef.getVideoTracks();

    if (tracks && tracks.length) {
      tracks[0].stop();
    }

    streamRef = null;
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  true ? config_dev : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(28);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (true) {
    console.log("image wrapper size ".concat(inputImageWrapper.size));
  }

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?
// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }

  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);

  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }

  return buffer;
}

function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();

    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };

    fileReader.readAsArrayBuffer(blob);
  });
}

function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';

    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };

    http.onerror = reject;
    http.send();
  });
}

function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];

    if (exifTag) {
      result[exifTag] = selectedTag;
    }

    return result;
  }, {});
  var offset = 2;
  var marker;

  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }

  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }

    marker = dataView.getUint8(offset + 1);

    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }

    offset += 2 + dataView.getUint16(offset + 2);
  }

  return false;
}

function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }

  var tiffOffset = start + 6;
  var bigEnd;

  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }

  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }

  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

  if (firstIFDOffset < 0x00000008) {
    return false;
  }

  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};

  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];

    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }

  return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);

  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }

  }

  return null;
}

function getStringFromBuffer(buffer, start, length) {
  var outstr = '';

  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }

  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js

var ImageLoader = {};

ImageLoader.load = function (directory, callback, offset, size, sequence) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;

  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = "".concat(directory, "image-").concat("00".concat(num).slice(-3), ".jpg");
    }
  }

  htmlImagesArray.notLoaded = [];

  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };

  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;

    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);

        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/'));

          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }

        break;
      }
    }

    if (notloadedImgs.length === 0) {
      if (true) {
        console.log('Images loaded');
      }

      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };

  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};

function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
}

/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */

var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};

    var _calculatedWidth;

    var _calculatedHeight;

    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function initSize() {
      var _config2, _config3;

      var width = video.videoWidth;
      var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

      _calculatedWidth = ((_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

      _calculatedHeight = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }

    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;

        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];

          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        var handlers = _eventHandlers[eventName];

        if (eventName === 'canrecord') {
          initSize();
        }

        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    if (video) {
      video.setAttribute('autoplay', 'true');
    }

    var that = inputStreamFactory.createVideoStream(video);

    that.ended = function ended() {
      return false;
    };

    return that;
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function loadImages() {
      var _config7;

      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;

        imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;

            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        } // eslint-disable-next-line no-nested-ternary


        calculatedWidth = ((_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config6 = _config) === null || _config6 === void 0 ? void 0 : _config6.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence);
    }

    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    } // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

          size = stream.length;
        }

        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;

        if (!loaded) {
          return null;
        }

        if (!paused) {
          var _imgArray;

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];

          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(39);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/get-pixels/dom-pixels.js
var dom_pixels = __webpack_require__(104);
var dom_pixels_default = /*#__PURE__*/__webpack_require__.n(dom_pixels);

// CONCATENATED MODULE: ./src/input/input_stream/input_stream_node.ts

// TODO: It's pretty likely that this shares code with the browser version, investigate that

var input_stream_node_inputStreamFactory = {
  createVideoStream: function createVideoStream() {
    throw new Error('createVideoStream not available');
  },
  createLiveStream: function createLiveStream() {
    throw new Error('createLiveStream not available');
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
    // TODO: there is a ts-ndarray that might work, though

    var frame = null;
    var baseUrl;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    /* eslint-disable no-unused-vars */
    // false eslint errors? weird.
    // @ts-ignore

    var size = 0; // @ts-ignore

    var frameIdx = 0; // @ts-ignore

    var paused = false;
    /* eslint-enable no-unused-vars */

    function loadImages() {
      var _config2;

      loaded = false;
      /* eslint-disable new-cap */

      dom_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
        var _config3, _config4;

        if (err) {
          console.error('**** quagga loadImages error:', err);
          throw new Error('error decoding pixels in loadImages');
        }

        loaded = true;

        if (true) {
          console.log('* InputStreamNode pixels.shape', pixels.shape);
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


        frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

        width = _pixels$shape[0];
        height = _pixels$shape[1];
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      });
    }

    function publishEvent(eventName, args) {
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (var j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args);
        }
      }
    } // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(w) {
        calculatedWidth = w;
      },
      setHeight: function setHeight(h) {
        calculatedHeight = h;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        var _config5;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
        size = 1;
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(sz) {
        _canvasSize.x = sz.x;
        _canvasSize.y = sz.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        if (!loaded) {
          return null;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_node = (input_stream_node_inputStreamFactory);
// CONCATENATED MODULE: ./src/input/input_stream_factory.ts


/* harmony default export */ var input_stream_factory = (input_stream_browser);

// EXTERNAL MODULE: ./src/input/frame_grabber_node.js
var frame_grabber_node = __webpack_require__(99);
var frame_grabber_node_default = /*#__PURE__*/__webpack_require__.n(frame_grabber_node);

// EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
var cv_utils = __webpack_require__(8);

// CONCATENATED MODULE: ./src/input/frame_grabber.js


var TO_RADIANS = Math.PI / 180;

function adjustCanvasSize(canvas, targetSize) {
  if (canvas.width !== targetSize.x) {
    if (true) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.width = targetSize.x;
  }

  if (canvas.height !== targetSize.y) {
    if (true) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.height = targetSize.y;
  }
}

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _streamConfig = inputStream.getConfig();

  var _videoSize = Object(cv_utils["imageRef"])(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = Object(cv_utils["imageRef"])(inputStream.getWidth(), inputStream.getHeight());

  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;

  var _canvas;

  var _ctx = null;
  var _data = null;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  _ctx = _canvas.getContext('2d');
  _data = new Uint8Array(_size.x * _size.y);

  if (true) {
    console.log('FrameGrabber', JSON.stringify({
      size: _size,
      topRight: topRight,
      videoSize: _videoSize,
      canvasSize: _canvasSize
    }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    var ctxData;

    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize);

      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;

        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;

            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

        _ctx.rotate(drawAngle);

        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);

        _ctx.rotate(-drawAngle);

        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }

      ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

      if (doHalfSample) {
        Object(cv_utils["grayAndHalfSampleFromCanvasData"])(ctxData, _size, _data);
      } else {
        Object(cv_utils["computeGray"])(ctxData, _data, _streamConfig);
      }

      return true;
    }

    return false;
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

/* harmony default export */ var frame_grabber = (FrameGrabber);

// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (true) {
        console.log('Worker initialized');
      }

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts

















var InputStream = typeof window === 'undefined' ? input_stream_node : input_stream_factory;
var quagga_FrameGrabber = typeof window === 'undefined' ? frame_grabber_node_default.a : frame_grabber;

var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = quagga_FrameGrabber.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), InputStream),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return ((_this$context$config3 = this.context.config) === null || _this$context$config3 === void 0 ? void 0 : _this$context$config3.locate) ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;

            _this4.update();
          }

          window.requestAnimationFrame(newFrame);
        }
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$context$config7;

      this.context.stopped = true;
      adjustWorkerPool(0);

      if (((_this$context$config7 = this.context.config) === null || _this$context$config7 === void 0 ? void 0 : _this$context$config7.inputStream) && this.context.config.inputStream.type === 'LiveStream') {
        camera_access.release();
        this.context.inputStream.clearEventHandlers();
      }
    }
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js

 // eslint-disable-line no-unused-vars











var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    instance.start();
  },
  stop: function stop() {
    instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return _context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  BarcodeReader: barcode_reader,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jdl91dGlscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3RyYWNlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyX25vZGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nZXQtcGl4ZWxzL2RvbS1waXhlbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvYWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1Yi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tdWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2VpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3VuZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbm9ybWFsaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RvdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcm9zcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZXJwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDJkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mb3JFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xpbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FuZ2xlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3ViLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdW5kLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyTGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nyb3NzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1RdWF0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2RldGVybWluYW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9tdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9hZGpvaW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZnJvYi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9sZHUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL29tZ2dpZi9vbWdnaWYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9jb252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvdW5pcS91bmlxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy90aHJvdWdoL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhL3V0aWwgKGlnbm9yZWQpP2ZiMWIiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZS9pbnRlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vZXZlbnRzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9nZXRWaWV3UG9ydC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2V4aWZfaGVscGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F3b3JrZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9zZXR1cElucHV0U3RyZWFtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvdHJhbnNmb3JtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXVhZ2dhLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EuanMiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX2dldFByb3RvdHlwZU9mIiwibyIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkVQU0lMT04iLCJjbG9uZSIsImZyb21WYWx1ZXMiLCJjb3B5Iiwic2V0IiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhZGQiLCJzdWJ0cmFjdCIsInN1YiIsIm11bHRpcGx5IiwibXVsIiwiZGl2aWRlIiwiZGl2IiwiaW52ZXJzZSIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImZsb29yIiwiY2VpbCIsInJvdW5kIiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwiZGlzdCIsInNxdWFyZWREaXN0YW5jZSIsInNxckRpc3QiLCJsZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3FyTGVuIiwibmVnYXRlIiwibm9ybWFsaXplIiwiZG90IiwiY3Jvc3MiLCJsZXJwIiwicmFuZG9tIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwidHJhbnNmb3JtTWF0MyIsInRyYW5zZm9ybU1hdDQiLCJmb3JFYWNoIiwibGltaXQiLCJ2ZWMyIiwicG9pbnQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInB1c2giLCJ1cGRhdGVDZW50ZXIiLCJzdW0iLCJNYXRoIiwiY29zIiwic2luIiwiaW5pdCIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiRCIsImF2ZyIsImNsdXN0ZXIiLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJDbHVzdGVyMiIsIlRyYWNlciIsInRyYWNlIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsInJlc3VsdCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwidG8iLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsInNjb3JlRnVuYyIsIm1pbklkeCIsInF1ZXVlIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiYXBwbHkiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FsbGJhY2siLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwiX2NvbXB1dGVEaXZpc29ycyIsIm4iLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJqIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJjbGVhclJlY3QiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiYXJyIiwidmFsIiwic2h1ZmZsZSIsInRvUG9pbnRMaXN0Iiwicm93cyIsInAiLCJyb3ciLCJqb2luIiwicHJldiIsIm5leHQiLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsImltZ1JlZiIsImJvcmRlciIsInNpemVYIiwic2l6ZVkiLCJpbmRleE1hcHBpbmciLCJsYWJlbENvdW50IiwieXNxIiwibGFiZWxTdW0iLCJsYWJlbCIsIm11MTEiLCJtdTAyIiwibXUyMCIsInhfIiwieV8iLCJ0bXAiLCJQSSIsIlBJXzQiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJtMDIiLCJtMjAiLCJ0aGV0YSIsImlzTmFOIiwiYXRhbiIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50IiwiZ2V0IiwiZnJhbWUiLCJnZXRBc1JHQkEiLCJuZXdGcmFtZSIsIkltYWdlRGF0YSIsImluU2NhbGUiLCJhZGp1c3RlZFNjYWxlIiwid2hpdGVSZ2IiLCJibGFja1JnYiIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsImlzT2JqZWN0IiwidHlwZSIsImlzQXJyYXkiLCJBcnJheSIsInByb2Nlc3MiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiYXJndW1lbnRzIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwicG5hIiwib2JqZWN0S2V5cyIsIkR1cGxleCIsInV0aWwiLCJpbmhlcml0cyIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJtZXRob2QiLCJvcHRpb25zIiwicmVhZGFibGUiLCJhbGxvd0hhbGZPcGVuIiwib25lbmQiLCJfd3JpdGFibGVTdGF0ZSIsImhpZ2hXYXRlck1hcmsiLCJlbmRlZCIsIm9uRW5kTlQiLCJfcmVhZGFibGVTdGF0ZSIsInVuZGVmaW5lZCIsImRlc3Ryb3llZCIsIl9kZXN0cm95IiwiZXJyIiwiY2IiLCJiYXNlTWVyZ2UiLCJjcmVhdGVBc3NpZ25lciIsIm1lcmdlIiwib2JqZWN0Iiwic291cmNlIiwic3JjSW5kZXgiLCJzdXBlclByb3BCYXNlIiwiX2dldCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsImlzT2JqZWN0TGlrZSIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2VhcmNoRGlyZWN0aW9ucyIsImxhYmVsV3JhcHBlciIsImxhYmVsRGF0YSIsImVkZ2VsYWJlbCIsImN5IiwiY3giLCJ2ZXJ0ZXgyRCIsImNvbnRvdXJUcmFjaW5nIiwiRnYiLCJDdiIsIlAiLCJsZGlyIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJiYXNlNjQiLCJpZWVlNzU0IiwiQnVmZmVyIiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImdsb2JhbCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiYnl0ZUxlbmd0aCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsInNwZWNpZXMiLCJhc3NlcnRTaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYnl0ZU9mZnNldCIsImlzQnVmZmVyIiwiYnVmZmVyIiwiaXNuYW4iLCJ0b1N0cmluZyIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsInN0YXJ0IiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJpbnNwZWN0Iiwic3RyIiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwiZnJvbUJ5dGVBcnJheSIsInJlcyIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJvYmplY3RXcml0ZVVJbnQzMiIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29kZSIsImNoYXJDb2RlQXQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInJlcGxhY2UiLCJ0cmltIiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwidG9CeXRlQXJyYXkiLCJkc3QiLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiaXNSZWdFeHAiLCJyZSIsImlzRGF0ZSIsImQiLCJpc0Vycm9yIiwiaXNGdW5jdGlvbiIsImlzUHJpbWl0aXZlIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsInNrZWxldG9uaXplciIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJkZWJ1ZyIsInNob3dDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJzaG93UGF0Y2hlcyIsIkltYWdlRGVidWciLCJtYXQyIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJzaG93IiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsInNob3dMYWJlbHMiLCJvdmVybGF5IiwiY291bnQiLCJkZXNjcmliZVBhdGNoIiwic2hvd0ZvdW5kUGF0Y2hlcyIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsIm1hcCIsInNvcnQiLCJmaWx0ZXIiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwic3ViSW1hZ2VBc0NvcHkiLCJzaG93U2tlbGV0b24iLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsImluZGV4IiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsInNob3dQYXRjaExhYmVscyIsImlucHV0SW1hZ2VXcmFwcGVyIiwibG9jYXRlIiwiY2hlY2tJbWFnZUNvbnN0cmFpbnRzIiwiaW5wdXRTdHJlYW0iLCJnZXRXaWR0aCIsImdldEhlaWdodCIsInRoaXNIYWxmU2FtcGxlIiwiZ2V0Q29uZmlnIiwic2V0VG9wUmlnaHQiLCJzZXRDYW52YXNTaXplIiwiY29uc29sZSIsImxvZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRXaWR0aCIsInNldEhlaWdodCIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXMiLCJlcSIsImFzc29jSW5kZXhPZiIsIm90aGVyIiwiZ2V0TmF0aXZlIiwibmF0aXZlQ3JlYXRlIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIl9fZGF0YV9fIiwiYmFzZUlzQXJndW1lbnRzIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwiY2FzdFBhdGgiLCJmbiIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFmdGVyVGlja09uZSIsImFmdGVyVGlja1R3byIsImFmdGVyVGlja1RocmVlIiwiYWZ0ZXJUaWNrIiwiYXJyYXlXaXRoSG9sZXMiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93IiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJkZXRlcm1pbmFudCIsInRyYW5zcG9zZSIsImlkZW50aXR5IiwiYWRqb2ludCIsImludmVydCIsImZyb2IiLCJsZHUiLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwidGFnIiwiYmFzZUFzc2lnblZhbHVlIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjaGlsZHJlbiIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJzeW1ib2xUYWciLCJJTkZJTklUWSIsInRvS2V5IiwiaW90YSIsImhhc1R5cGVkQXJyYXlzIiwiRmxvYXQ2NEFycmF5IiwiY29tcGFyZTFzdCIsIm9yZGVyIiwic3RyaWRlIiwidGVybXMiLCJjb21waWxlQ29uc3RydWN0b3IiLCJkdHlwZSIsInVzZUdldHRlcnMiLCJwcm9jZWR1cmUiLCJDQUNIRURfQ09OU1RSVUNUT1JTIiwiaW5kaWNlcyIsImluZGV4X3N0ciIsInNoYXBlQXJnIiwic3RyaWRlQXJnIiwiYV92YXJzIiwiY192YXJzIiwidFNoYXBlIiwidFN0cmlkZSIsImFycmF5RFR5cGUiLCJ3cmFwcGVkTkRBcnJheUN0b3IiLCJzaGFwZSIsInN6IiwiY3Rvcl9saXN0IiwiUiIsIlJlZmxlY3RBcHBseSIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwid2FybiIsIk51bWJlcklzTmFOIiwiRXZlbnRFbWl0dGVyIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsImRvRXJyb3IiLCJldmVudHMiLCJlciIsIm1lc3NhZ2UiLCJoYW5kbGVyIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwid2FybmVkIiwidyIsImVtaXR0ZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwiYmluZCIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsInBvcCIsImV2ZW50TGlzdGVuZXIiLCJlcnJvckxpc3RlbmVyIiwiU3RyZWFtIiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiV3JpdGVSZXEiLCJjaHVuayIsIkNvcmtlZFJlcXVlc3QiLCJfdGhpcyIsImZpbmlzaCIsIm9uQ29ya2VkRmluaXNoIiwiYXN5bmNXcml0ZSIsInNldEltbWVkaWF0ZSIsIldyaXRhYmxlU3RhdGUiLCJpbnRlcm5hbFV0aWwiLCJPdXJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIl9pc1VpbnQ4QXJyYXkiLCJkZXN0cm95SW1wbCIsIm5vcCIsInN0cmVhbSIsImlzRHVwbGV4Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImh3bSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZGVmYXVsdEh3bSIsImZpbmFsQ2FsbGVkIiwibmVlZERyYWluIiwiZW5kaW5nIiwiZmluaXNoZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJkZWZhdWx0RW5jb2RpbmciLCJ3cml0aW5nIiwiY29ya2VkIiwic3luYyIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwid3JpdGVjYiIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJfd3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZGVzdHJveSIsImZpbmFsIiwiX2ZpbmFsIiwicGlwZSIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwidmFsaWQiLCJpc0J1ZiIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwibGFzdCIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwicHJlZmluaXNoIiwibmVlZCIsImNvcmtSZXEiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95IiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiRmxvYXQzMkFycmF5IiwieiIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImZ1bmMiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJuYXRpdmVJc0J1ZmZlciIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJub2RlVXRpbCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzYWZlR2V0IiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5c0luIiwia2V5c0luIiwibmF0aXZlTWF4Iiwib3ZlclJlc3QiLCJ0cmFuc2Zvcm0iLCJvdGhlckFyZ3MiLCJiYXNlU2V0VG9TdHJpbmciLCJzaG9ydE91dCIsInNldFRvU3RyaW5nIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRUVsaXN0ZW5lckNvdW50IiwiZGVidWdVdGlsIiwiZGVidWdsb2ciLCJCdWZmZXJMaXN0IiwiU3RyaW5nRGVjb2RlciIsImtQcm94eUV2ZW50cyIsImV2ZW50IiwicmVhZGFibGVPYmplY3RNb2RlIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJfcmVhZCIsInNraXBDaHVua0NoZWNrIiwicmVhZGFibGVBZGRDaHVuayIsImFkZFRvRnJvbnQiLCJvbkVvZkNodW5rIiwiY2h1bmtJbnZhbGlkIiwiYWRkQ2h1bmsiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsImVuYyIsIk1BWF9IV00iLCJjb21wdXRlTmV3SGlnaFdhdGVyTWFyayIsImhvd011Y2hUb1JlYWQiLCJoZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsImRlc3QiLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZXJyb3IiLCJvbmRhdGEiLCJpbmNyZWFzZWRBd2FpdERyYWluIiwicGF1c2UiLCJyZXN1bWUiLCJkZXN0cyIsInNwbGljZSIsImV2IiwiblJlYWRpbmdOZXh0VGljayIsInJlc3VtZV8iLCJ3cmFwIiwicGF1c2VkIiwiX2Zyb21MaXN0IiwiZnJvbUxpc3RQYXJ0aWFsIiwiaGFzU3RyaW5ncyIsImNvcHlGcm9tQnVmZmVyU3RyaW5nIiwiY29weUZyb21CdWZmZXIiLCJuYiIsInRhaWwiLCJlbmRSZWFkYWJsZU5UIiwieHMiLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwiX3RyYW5zZm9ybSIsImZsdXNoIiwiX2ZsdXNoIiwiX3RoaXMyIiwiZXJyMiIsIkNWVXRpbHMiLCJOZGFycmF5IiwiSW50ZXJwMkQiLCJkMiIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3ZpZGVvU2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsImdldENhbnZhc1NpemUiLCJfc2l6ZSIsIl90b3BSaWdodCIsImdldFRvcFJpZ2h0IiwiX2RhdGEiLCJfZ3JheURhdGEiLCJfY2FudmFzRGF0YSIsIl9ncmF5SW1hZ2VBcnJheSIsIl9jYW52YXNJbWFnZUFycmF5IiwiX3RhcmdldEltYWdlQXJyYXkiLCJfc3RlcFNpemVYIiwiX3N0ZXBTaXplWSIsInZpZGVvU2l6ZSIsImNhbnZhc1NpemUiLCJzdGVwU2l6ZSIsInRvcFJpZ2h0IiwiYXR0YWNoRGF0YSIsImdldERhdGEiLCJncmFiIiwiZ2V0RnJhbWUiLCJzY2FsZUFuZENyb3AiLCJnZXRTaXplIiwiYW5nbGUiLCJ0cmFuc2Zvcm1RdWF0Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwiYmFzZVBpY2siLCJmbGF0UmVzdCIsInBpY2siLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW11bCIsImluSW1hZ2VQdHIiLCJvdXRJbWFnZVB0ciIsImFJbWFnZVB0ciIsImJJbWFnZVB0ciIsImltYWdlUHRyIiwibWVtY3B5Iiwic3JjSW1hZ2VQdHIiLCJkc3RJbWFnZVB0ciIsInN1YkltYWdlUHRyIiwiZXJvZGVkSW1hZ2VQdHIiLCJ0ZW1wSW1hZ2VQdHIiLCJza2VsSW1hZ2VQdHIiLCJuZGFycmF5IiwiR2lmUmVhZGVyIiwicGFjayIsInRocm91Z2giLCJwYXJzZURhdGFVUkkiLCJkZWZhdWx0SW1hZ2UiLCJ1cmwiLCJjcm9zc09yaWdpbiIsInBpeGVscyIsImhhbmRsZUdpZiIsInJlYWRlciIsIm51bUZyYW1lcyIsIm5zaGFwZSIsIm5kYXRhIiwiZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSIsImh0dHBHaWYiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvdmVycmlkZU1pbWVUeXBlIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlIiwic2VuZCIsImNvcHlCdWZmZXIiLCJkYXRhR2lmIiwiZ2V0UGl4ZWxzIiwiZXh0bmFtZSIsInRvVXBwZXJDYXNlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWgiLCJhbCIsImJoIiwiYmwiLCJhc3NpZ24iLCJuZXh0U291cmNlIiwibmV4dEtleSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJfbm9uSXRlcmFibGVSZXN0IiwiYTAiLCJhMSIsImIwIiwiYjEiLCJ0IiwiYXgiLCJheSIsIm1TcSIsInRlbXBBIiwidGVtcEIiLCJjb3NpbmUiLCJhY29zIiwiYTIiLCJiMiIsImF6IiwiYngiLCJieSIsImJ6IiwielNjYWxlIiwicXgiLCJxeSIsInF6IiwicXciLCJpeCIsIml5IiwiaXoiLCJpdyIsInB5IiwicHoiLCJfc2V0UHJvdG90eXBlT2YiLCJTdGFjayIsImJhc2VGb3IiLCJiYXNlTWVyZ2VEZWVwIiwiY3VzdG9taXplciIsInN0YWNrIiwic3JjVmFsdWUiLCJuZXdWYWx1ZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsImFycmF5UHJvdG8iLCJsYXN0SW5kZXgiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJpc01hc2tlZCIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInBhdHRlcm4iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJjb3JlSnNEYXRhIiwibWFza1NyY0tleSIsInVpZCIsImV4ZWMiLCJJRV9QUk9UTyIsIkhhc2giLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSEFTSF9VTkRFRklORUQiLCJjcmVhdGVCYXNlRm9yIiwiZnJvbVJpZ2h0IiwiaXRlcmF0ZWUiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJjb3B5QXJyYXkiLCJpbml0Q2xvbmVPYmplY3QiLCJpc0FycmF5TGlrZU9iamVjdCIsImlzUGxhaW5PYmplY3QiLCJ0b1BsYWluT2JqZWN0IiwibWVyZ2VGdW5jIiwic3RhY2tlZCIsImlzQ29tbW9uIiwiaXNBcnIiLCJpc0J1ZmYiLCJpc1R5cGVkIiwiaXNEZWVwIiwiY2xvbmVBcnJheUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlciIsImJhc2VDcmVhdGUiLCJvYmplY3RDcmVhdGUiLCJhcmdzVGFnIiwib2JqZWN0VGFnIiwib2JqZWN0Q3RvclN0cmluZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsInR5cGVzIiwiY29weU9iamVjdCIsImlzTmV3IiwiYmFzZVRpbWVzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlUmVzdCIsImlzSXRlcmF0ZWVDYWxsIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJ0aGlzQXJnIiwiY29uc3RhbnQiLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIkRhdGUiLCJub3ciLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIl9zdXBlclByb3BCYXNlIiwicnVudGltZSIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsInJldmVyc2UiLCJpdGVyYXRvck1ldGhvZCIsInNraXBUZW1wUmVzZXQiLCJjaGFyQXQiLCJzdG9wIiwicm9vdEVudHJ5Iiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImJhc2VQaWNrQnkiLCJoYXNJbiIsImJhc2VHZXQiLCJiYXNlU2V0IiwicHJlZGljYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsIm1lbW9pemVDYXBwZWQiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsImNhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwiYmFzZVRvU3RyaW5nIiwiYXJyYXlNYXAiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwibmVzdGVkIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJmbGF0dGVuIiwiYmFzZUZsYXR0ZW4iLCJhcnJheVB1c2giLCJpc0ZsYXR0ZW5hYmxlIiwiZGVwdGgiLCJpc1N0cmljdCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJhMyIsImIzIiwiZGV0IiwidjAiLCJ2MSIsIkwiLCJVIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiZ2V0TGVucyIsImI2NCIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiTE4yIiwibm9ybWFsaXplQXJyYXkiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwicmVzb2x2ZWRQYXRoIiwicmVzb2x2ZWRBYnNvbHV0ZSIsInNwbGl0IiwiaXNBYnNvbHV0ZSIsInRyYWlsaW5nU2xhc2giLCJyZWxhdGl2ZSIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInNlcCIsImRlbGltaXRlciIsImRpcm5hbWUiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJmIiwic3RhcnREb3QiLCJzdGFydFBhcnQiLCJwcmVEb3RTdGF0ZSIsImlzU2xvd0J1ZmZlciIsIkdpZldyaXRlciIsImdvcHRzIiwibG9vcF9jb3VudCIsImxvb3AiLCJnbG9iYWxfcGFsZXR0ZSIsInBhbGV0dGUiLCJjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzIiwibnVtX2NvbG9ycyIsImdwX251bV9jb2xvcnNfcG93MiIsImJhY2tncm91bmQiLCJncF9udW1fY29sb3JzIiwiaWwiLCJhZGRGcmFtZSIsImluZGV4ZWRfcGl4ZWxzIiwib3B0cyIsInVzaW5nX2xvY2FsX3BhbGV0dGUiLCJtaW5fY29kZV9zaXplIiwiZGVsYXkiLCJkaXNwb3NhbCIsInVzZV90cmFuc3BhcmVuY3kiLCJ0cmFuc3BhcmVudF9pbmRleCIsInRyYW5zcGFyZW50IiwiR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbSIsImdldE91dHB1dEJ1ZmZlciIsInNldE91dHB1dEJ1ZmZlciIsImdldE91dHB1dEJ1ZmZlclBvc2l0aW9uIiwic2V0T3V0cHV0QnVmZmVyUG9zaXRpb24iLCJpbmRleF9zdHJlYW0iLCJjdXJfc3ViYmxvY2siLCJjbGVhcl9jb2RlIiwiY29kZV9tYXNrIiwiZW9pX2NvZGUiLCJuZXh0X2NvZGUiLCJjdXJfY29kZV9zaXplIiwiY3VyX3NoaWZ0IiwiY3VyIiwiZW1pdF9ieXRlc190b19idWZmZXIiLCJiaXRfYmxvY2tfc2l6ZSIsImVtaXRfY29kZSIsImliX2NvZGUiLCJjb2RlX3RhYmxlIiwiY3VyX2tleSIsImN1cl9jb2RlIiwicGYwIiwiZ2xvYmFsX3BhbGV0dGVfZmxhZyIsIm51bV9nbG9iYWxfY29sb3JzX3BvdzIiLCJudW1fZ2xvYmFsX2NvbG9ycyIsImdsb2JhbF9wYWxldHRlX29mZnNldCIsImdsb2JhbF9wYWxldHRlX3NpemUiLCJub19lb2YiLCJmcmFtZXMiLCJibG9ja19zaXplIiwicGYxIiwicGYyIiwibG9jYWxfcGFsZXR0ZV9mbGFnIiwiaW50ZXJsYWNlX2ZsYWciLCJudW1fbG9jYWxfY29sb3JzX3BvdzIiLCJudW1fbG9jYWxfY29sb3JzIiwicGFsZXR0ZV9vZmZzZXQiLCJwYWxldHRlX3NpemUiLCJoYXNfbG9jYWxfcGFsZXR0ZSIsImRhdGFfb2Zmc2V0IiwiZGF0YV9sZW5ndGgiLCJpbnRlcmxhY2VkIiwibG9vcENvdW50IiwiZnJhbWVJbmZvIiwiZnJhbWVfbnVtIiwiZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSIsIm51bV9waXhlbHMiLCJHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbSIsInRyYW5zIiwiZnJhbWV3aWR0aCIsImZyYW1lc3RyaWRlIiwieGxlZnQiLCJvcGJlZyIsIm9wZW5kIiwib3AiLCJzY2Fuc3RyaWRlIiwiaW50ZXJsYWNlc2tpcCIsImNvZGVfc3RyZWFtIiwib3V0cHV0X2xlbmd0aCIsInN1YmJsb2NrX3NpemUiLCJwcmV2X2NvZGUiLCJjaGFzZV9jb2RlIiwiY2hhc2VfbGVuZ3RoIiwiY2hhc2UiLCJvcF9lbmQiLCJkb19jb252ZXJ0IiwiY29udmVydCIsImNyZWF0ZVRodW5rIiwiUHJvY2VkdXJlIiwiYXJnVHlwZXMiLCJzaGltQXJncyIsImFycmF5QXJncyIsImFycmF5QmxvY2tJbmRpY2VzIiwic2NhbGFyQXJncyIsIm9mZnNldEFyZ3MiLCJvZmZzZXRBcmdJbmRleCIsImluZGV4QXJncyIsInNoYXBlQXJncyIsImZ1bmNOYW1lIiwicHJlIiwiYm9keSIsInBvc3QiLCJjb21waWxlQ3dpc2UiLCJ1c2VyX2FyZ3MiLCJwcm9jIiwicHJvY19hcmdzIiwiYXJnX3R5cGUiLCJibG9ja0luZGljZXMiLCJsdmFsdWUiLCJwcmludENvZGUiLCJibG9ja1NpemUiLCJjb21waWxlIiwidmFycyIsInRodW5rTmFtZSIsInR5cGVzaWciLCJzdHJpbmdfdHlwZXNpZyIsInNoYXBlTGVuZ3RoQ29uZGl0aW9ucyIsInNoYXBlQ29uZGl0aW9ucyIsInRodW5rIiwidW5pcSIsImlubmVyRmlsbCIsIm5hcmdzIiwiaGFzX2luZGV4IiwicGlkeCIsIm91dGVyRmlsbCIsIm1hdGNoZWQiLCJpbmRleFN0ciIsImNvdW50TWF0Y2hlcyIsIm9yZGVycyIsInByb2Nlc3NCbG9jayIsImJsb2NrIiwiZHR5cGVzIiwiY2FyZyIsInB0clN0ciIsImFyck51bSIsIm9mZkFyZ0luZGV4Iiwib2ZmQXJnIiwibG9jYWxTdHIiLCJhcnJTdHIiLCJyZVN0ckFyciIsInB0clN0ckFyciIsInR5cGVTdW1tYXJ5Iiwic3VtbWFyeSIsImFsbEVxdWFsIiwiZGlnaXRzIiwiZ2VuZXJhdGVDV2lzZU9wIiwiYmxvY2tCZWdpbiIsImJsb2NrRW5kIiwibG9vcEJlZ2luIiwibG9vcEVuZCIsImxvb3BPcmRlcnMiLCJuZXdPcmRlciIsImFyZ2xpc3QiLCJ6ZXJvcyIsIm9mZl9hcmciLCJpbml0X3N0cmluZyIsInRoaXNWYXJzIiwibG9vcE5hbWUiLCJ1bmlxdWVfcHJlZCIsInB0ciIsInVuaXF1ZV9lcSIsInVuaXF1ZSIsInNvcnRlZCIsIl9lbmRlZCIsImF1dG9EZXN0cm95IiwiZHJhaW4iLCJfZW5kIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsImN1c3RvbSIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiY2xlYXJJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIm1zZyIsImRlcHJlY2F0ZWQiLCJsb2NhbFN0b3JhZ2UiLCJkYXRhVXJpVG9CdWZmZXIiLCJ1cmkiLCJmaXJzdENvbW1hIiwibWV0YSIsInN1YnN0cmluZyIsImNoYXJzZXQiLCJ1bmVzY2FwZSIsImludGVycDFkIiwiZngiLCJzMCIsInMxIiwidzAiLCJ3MSIsImludGVycDJkIiwiZnkiLCJ0MCIsInQxIiwidzAwIiwidzAxIiwidzEwIiwidzExIiwiaW50ZXJwM2QiLCJmeiIsInUwIiwidTEiLCJ3MDAwIiwidzAxMCIsIncxMDAiLCJ3MTEwIiwidzAwMSIsIncwMTEiLCJ3MTAxIiwidzExMSIsImludGVycE5kIiwiaV9sb29wIiwiaW50ZXJwb2xhdGUiLCJkMSIsImQzIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJkZWx0YVgiLCJkZWx0YVkiLCJ5U3RlcCIsInRvQmluYXJ5TGluZSIsInNsb3BlIiwic2xvcGUyIiwiZXh0cmVtYSIsImN1cnJlbnREaXIiLCJyVGhyZXNob2xkIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIkJhcmNvZGVEaXJlY3Rpb24iLCJCYXJjb2RlUmVhZGVyIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsInN1cHBsZW1lbnRzIiwiX3JvdyIsImNvdW50ZXIiLCJtYXhTaW5nbGVFcnJvciIsInNpbmdsZUVycm9yIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJzY2FsZWQiLCJTSU5HTEVfQ09ERV9FUlJPUiIsImNvcnJlY3Rpb24iLCJfZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbmV4dFVuc2V0IiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIm51bUNvdW50ZXJzIiwiQ29kZTEyOFJlYWRlciIsImJhciIsInNwYWNlIiwiYmVzdE1hdGNoIiwiX2NvcnJlY3QiLCJDT0RFX1BBVFRFUk4iLCJfbWF0Y2hQYXR0ZXJuIiwiQVZHX0NPREVfRVJST1IiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwiTU9EVUxFX0lORElDRVMiLCJfY29ycmVjdEJhcnMiLCJfbmV4dFNldCIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsInN0YXJ0SW5mbyIsIl9maW5kU3RhcnQiLCJkZWNvZGVkQ29kZXMiLCJjaGVja3N1bSIsImNvZGVzZXQiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJDT0RFX0IiLCJDT0RFX0MiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIl9kZWNvZGVDb2RlIiwiU1RPUF9DT0RFIiwiQ09ERV9TSElGVCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX21hdGNoUmFuZ2UiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJDT0RFX0dfU1RBUlQiLCJTVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwidHJ5SGFyZGVyIiwiZXBzaWxvbiIsImNvZGVyYW5nZSIsIl9maW5kUGF0dGVybiIsImxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQiLCJjb2RlRnJlcXVlbmN5IiwiaW5Db2RlIiwib3V0Q29kZSIsImZpcnN0RGlnaXQiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsIm1pZGRsZVBhdHRlcm4iLCJTVE9QX1BBVFRFUk4iLCJyZXN1bHRJbmZvIiwiX2RlY29kZVBheWxvYWQiLCJfZmluZEVuZCIsIl9jaGVja3N1bSIsInN1cHBsZW1lbnQiLCJfZGVjb2RlRXh0ZW5zaW9ucyIsImxhc3RDb2RlIiwiQUxQSEFCRVRIX1NUUklORyIsIkFMUEhBQkVUIiwiVWludDE2QXJyYXkiLCJjaGFyIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIkFTVEVSSVNLIiwiQ29kZTM5UmVhZGVyIiwicGF0dGVyblN0YXJ0IiwiX3RvUGF0dGVybiIsIndoaXRlU3BhY2VNdXN0U3RhcnQiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsInBhdHRlcm5TaXplIiwiZGVjb2RlZENoYXIiLCJfdG9Db3VudGVycyIsIl9wYXR0ZXJuVG9DaGFyIiwicGF0dGVybnMiLCJJT1EiLCJBWjA5IiwiQ29kZTM5VklOUmVhZGVyIiwiX2NoZWNrQ2hlY2tzdW0iLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY291bnRlcnMiLCJiYXJUaHJlc2hvbGQiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiX2lzU3RhcnRFbmQiLCJfc3VtQ291bnRlcnMiLCJzdGFydENvdW50ZXIiLCJlbmRDb3VudGVyIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJjaGFyQ29kZSIsImNhdGVnb3JpemF0aW9uIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsIl9jaGFyVG9QYXR0ZXJuIiwia2luZCIsImNhdCIsIm5ld2tpbmQiLCJ0aHJlc2hvbGRzIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJfZmlsbENvdW50ZXJzIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfdmFsaWRhdGVSZXN1bHQiLCJVUENSZWFkZXIiLCJFQU44UmVhZGVyIiwiRUFOMlJlYWRlciIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwidXBjYSIsImxhc3REaWdpdCIsIl9jb252ZXJ0VG9VUENBIiwiTiIsIlciLCJJMm9mNVJlYWRlciIsIm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgiLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJiYXJTcGFjZVJhdGlvIiwibmFycm93QmFyV2lkdGgiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiY291bnRlckxlbmd0aCIsIl9kZWNvZGVQYWlyIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJTVEFSVF9QQVRURVJOX0xFTkdUSCIsIlR3b09mRml2ZVJlYWRlciIsIkNvZGU5M1JlYWRlciIsImNoYXJBcnJheSIsIm5leHRDaGFyIiwibmV4dENoYXJDb2RlIiwibWF4V2VpZ2h0IiwiYXJyYXlUb0NoZWNrIiwid2VpZ2h0ZWRTdW1zIiwid2VpZ2h0IiwiY2hlY2tDaGFyIiwiX21hdGNoQ2hlY2tDaGFyIiwiX3ZlcmlmeUVuZCIsIl92ZXJpZnlDaGVja3N1bXMiLCJfZGVjb2RlRXh0ZW5kZWQiLCJBRUlPIiwiY29kZTMyc2V0IiwiQ29kZTMyUmVhZGVyIiwiY29kZTMyIiwiX2RlY29kZUNvZGUzMiIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJjb25maWd1cmF0aW9uIiwicmVhZGVyT2JqIiwidmlzIiwibm9kZSIsInByb3AiLCJzaG93RnJlcXVlbmN5Iiwic2hvd1BhdHRlcm4iLCJkaXNwbGF5IiwiZ2V0RXh0ZW5kZWRMaW5lIiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImluSW1hZ2VXaXRoQm9yZGVyIiwiZ2V0TGluZSIsInRyeURlY29kZSIsImJhcmNvZGVMaW5lIiwiZGVjb2RlUGF0dGVybiIsImNvZGVSZXN1bHQiLCJ0cnlEZWNvZGVCcnV0ZUZvcmNlIiwibGluZUFuZ2xlIiwic2lkZUxlbmd0aCIsInNsaWNlcyIsInhkaXIiLCJ5ZGlyIiwiZ2V0TGluZUxlbmd0aCIsImRlY29kZUZyb21JbWFnZSIsImRlY29kZUltYWdlIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwiZHJhd0JvdW5kaW5nQm94IiwibGluZUxlbmd0aCIsImF0YW4yIiwiZHJhd1NjYW5saW5lIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwic2V0UmVhZGVycyIsIkV2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnQiLCJldmVudE5hbWUiLCJzdWJzY3JpYmVycyIsImNsZWFyRXZlbnRzIiwicHVibGlzaFN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbiIsIl9zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwic3Vic2NyaWJlciIsInVuc3Vic2NyaWJlIiwiRVJST1JfREVTQyIsImVudW1lcmF0ZURldmljZXMiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJjb25zdHJhaW50cyIsInN0cmVhbVJlZiIsIndhaXRGb3JWaWRlbyIsInZpZGVvIiwiYXR0ZW1wdHMiLCJjaGVja1ZpZGVvIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaW5pdENhbWVyYSIsInNldEF0dHJpYnV0ZSIsInNyY09iamVjdCIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsInRyYWNrIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImxvY2F0b3IiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJzZWxlY3RvciIsImZpbmRPckNyZWF0ZUNhbnZhcyIsImdldENhbnZhc0FuZENvbnRleHQiLCJpbml0Q2FudmFzZXMiLCJpbWFnZSIsInZpZXdwb3J0IiwiY29udGFpbmVyIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsInRhZ3MiLCJvYmplY3RVUkxUb0Jsb2IiLCJyZWFkVG9CdWZmZXIiLCJmaW5kVGFnc0luQnVmZmVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRhdGFVcmwiLCJhdG9iIiwidmlldyIsImJsb2IiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwiaHR0cCIsIkRPTkUiLCJzdGF0dXMiLCJmaWxlIiwic2VsZWN0ZWRUYWdzIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImV4aWZUYWdzIiwic2VsZWN0ZWRUYWciLCJleGlmVGFnIiwiZ2V0VWludDgiLCJyZWFkRVhJRkRhdGEiLCJnZXRVaW50MTYiLCJnZXRTdHJpbmdGcm9tQnVmZmVyIiwidGlmZk9mZnNldCIsImJpZ0VuZCIsImZpcnN0SUZET2Zmc2V0IiwiZ2V0VWludDMyIiwicmVhZFRhZ3MiLCJ0aWZmU3RhcnQiLCJkaXJTdGFydCIsInN0cmluZ3MiLCJlbnRyeU9mZnNldCIsInJlYWRUYWdWYWx1ZSIsIm51bVZhbHVlcyIsIm91dHN0ciIsIkltYWdlTG9hZGVyIiwibG9hZCIsImRpcmVjdG9yeSIsImh0bWxJbWFnZXNTcmNBcnJheSIsImh0bWxJbWFnZXNBcnJheSIsIm5vdExvYWRlZCIsImFkZEltYWdlIiwibG9hZGVkIiwibG9hZGVkSW1nIiwibm90bG9hZGVkSW1ncyIsImltZ05hbWUiLCJhZGRPbmxvYWRIYW5kbGVyIiwiaW5wdXRTdHJlYW1GYWN0b3J5IiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwiX2NhbGN1bGF0ZWRXaWR0aCIsIl9jYWxjdWxhdGVkSGVpZ2h0IiwiaW5pdFNpemUiLCJzZXRJbnB1dFN0cmVhbSIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsImJvb2wiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsImltZ3MiLCJvcmllbnRhdGlvbiIsInB1Ymxpc2hFdmVudCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiaW5kIiwiR2V0UGl4ZWxzIiwibWltZSIsIkJyb3dzZXJJbnB1dFN0cmVhbSIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIl9zdHJlYW1Db25maWciLCJfc3giLCJfc3kiLCJfY3R4IiwiZG9IYWxmU2FtcGxlIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJ0cmFuc2xhdGUiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwib25Qcm9jZXNzZWQiLCJ3b3JrZXJJbnRlcmZhY2VSZWFkeSIsImdlbmVyYXRlV29ya2VyQmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiYmxvYlVSTCIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsImFkanVzdFdvcmtlclBvb2wiLCJpbmNyZWFzZUJ5Iiwid29ya2Vyc1RvVGVybWluYXRlIiwidGVybWluYXRlIiwid29ya2VySW5pdGlhbGl6ZWQiLCJzZXR1cElucHV0U3RyZWFtIiwiSW5wdXRTdHJlYW0iLCJtb3ZlQm94IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXIiLCJtb3ZlTGluZSIsIk5vZGVJbnB1dFN0cmVhbSIsIk5vZGVGcmFtZUdyYWJiZXIiLCJCcm93c2VyRnJhbWVHcmFiYmVyIiwiZnJhbWVncmFiYmVyIiwiY2FudmFzQ29udGFpbmVyIiwiUVdvcmtlcnMiLCJpbml0aWFsaXplRGF0YSIsInJlYWR5Iiwib25VSVRocmVhZCIsIndvcmtlcnNVcGRhdGVkIiwibG9jYXRlQW5kRGVjb2RlIiwiX2luaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJfZ2V0Vmlld1BvcnQiLCJfaW5pdENhbnZhcyIsImlucHV0VHlwZSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsInN0b3BwZWQiLCJ0aW1lc3RhbXAiLCJ1cGRhdGUiLCJwZXJmb3JtYW5jZSIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsIl9jb250ZXh0IiwiUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UiLCJxdWFnZ2FJbnN0YW5jZSIsInByb21pc2UiLCJDb25maWciLCJpbml0SW5wdXRTdHJlYW0iLCJvbkRldGVjdGVkIiwib2ZmRGV0ZWN0ZWQiLCJvZmZQcm9jZXNzZWQiLCJyZWdpc3RlclJlc3VsdENvbGxlY3RvciIsImRlY29kZVNpbmdsZSIsInJlc3VsdENhbGxiYWNrIiwiZGVmYXVsdCIsIlJlc3VsdENvbGxlY3RvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7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QWEsQ0FBYixFQUFnQixDQUFoQixDQUhPLEVBSVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUpPLEVBS1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUxPLEVBTVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQU5PLEVBT1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVBPLEVBUVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVJPLEVBU1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVRPLEVBVVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVZPLEVBV1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVhPLEVBWVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVpPLEVBYVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWJPLEVBY1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWRPLEVBZVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWZPLEVBZ0JQLENBQUMs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LElBQVAsQ0FBWSxXQUFaLEVBQXlCLFVBQUM5UCxNQUFELEVBQVk7QUFDakMwdkUsMEJBQWMsQ0FBQ3o0QixJQUFmOztBQUNBLGdCQUFJazVCLGNBQUosRUFBb0I7QUFDaEJBLDRCQUFjLENBQUNyNUUsSUFBZixDQUFvQixJQUFwQixFQUEwQmtKLE1BQTFCO0FBQ0g7O0FBQ0RncUIsbUJBQU8sQ0FBQ2hxQixNQUFELENBQVA7QUFDSCxXQU5ELEVBTUcsSUFOSDtBQU9BMHZFLHdCQUFjLENBQUMxM0QsS0FBZjtBQUNILFNBVEQsRUFTRyxJQVRILEVBU1MwM0QsY0FUVDtBQVVILE9BWEQsQ0FXRSxPQUFPMTlELEdBQVAsRUFBWTtBQUNWaVksY0FBTSxDQUFDalksR0FBRCxDQUFOO0FBQ0g7QUFDSixLQWZNLENBQVA7QUFnQkgsR0F4SDJCOztBQXlINUI7QUFDQTtBQUNBLE1BQUlvK0QsT0FBSixHQUFjO0FBQ1YsV0FBT1gsdUJBQVA7QUFDSCxHQTdIMkI7O0FBOEg1QnZmLGVBQWEsRUFBYkEsY0E5SDRCO0FBK0g1QnFlLGNBQVksRUFBWkEsYUEvSDRCO0FBZ0k1QnZyRCxZQUFVLEVBQVZBLDhCQWhJNEI7QUFpSTVCbFksY0FBWSxFQUFaQSxnQ0FqSTRCO0FBa0k1QnVsRSxpQkFBZSxFQUFmQSxnQkFBZUE7QUFsSWEsQ0FBaEM7QUFxSWVaLG1HQUFmLEUsQ0FDQSIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwNSk7XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBFUFNJTE9OOiByZXF1aXJlKCcuL2Vwc2lsb24nKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBmcm9tVmFsdWVzOiByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgc2V0OiByZXF1aXJlKCcuL3NldCcpXG4gICwgZXF1YWxzOiByZXF1aXJlKCcuL2VxdWFscycpXG4gICwgZXhhY3RFcXVhbHM6IHJlcXVpcmUoJy4vZXhhY3RFcXVhbHMnKVxuICAsIGFkZDogcmVxdWlyZSgnLi9hZGQnKVxuICAsIHN1YnRyYWN0OiByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiAgLCBzdWI6IHJlcXVpcmUoJy4vc3ViJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgbXVsOiByZXF1aXJlKCcuL211bCcpXG4gICwgZGl2aWRlOiByZXF1aXJlKCcuL2RpdmlkZScpXG4gICwgZGl2OiByZXF1aXJlKCcuL2RpdicpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCByb3RhdGU6IHJlcXVpcmUoJy4vcm90YXRlJylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgbm9ybWFsaXplOiByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG4gICwgZG90OiByZXF1aXJlKCcuL2RvdCcpXG4gICwgY3Jvc3M6IHJlcXVpcmUoJy4vY3Jvc3MnKVxuICAsIGxlcnA6IHJlcXVpcmUoJy4vbGVycCcpXG4gICwgcmFuZG9tOiByZXF1aXJlKCcuL3JhbmRvbScpXG4gICwgdHJhbnNmb3JtTWF0MjogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQyJylcbiAgLCB0cmFuc2Zvcm1NYXQyZDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQyZCcpXG4gICwgdHJhbnNmb3JtTWF0MzogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQzJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIGZvckVhY2g6IHJlcXVpcmUoJy4vZm9yRWFjaCcpXG4gICwgbGltaXQ6IHJlcXVpcmUoJy4vbGltaXQnKVxufVxuIiwiLy8gVE9ETzogY2x1c3Rlci5qcyBhbmQgY3ZfdXRpbHMuanMgYXJlIHByZXR0eSB0aWdodGx5IGludGVydHdpbmVkLCBtYWtpbmcgZm9yIGEgY29tcGxleCBjb252ZXJzaW9uXG4vLyBpbnRvIHR5cGVzY3JpcHQuIGJlIHdhcm5lZC4gOi0pXG5cbmltcG9ydCB7IGNsb25lLCBkb3QgfSBmcm9tICdnbC12ZWMyJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmUsIGRvdCB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUocG9pbnQsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvaW50TWFwID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAgICAgbGV0IGk7IGxldFxuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBhZGQocG9pbnQpO1xuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRzKG90aGVyUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcbiAgICAgICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50KG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IGNsb25lIGFzIHYyY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGNsb25lIGFzIHYzY2xvbmUgfSBmcm9tICdnbC12ZWMzJztcbmltcG9ydCBDbHVzdGVyMiBmcm9tICcuL2NsdXN0ZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmU6IHYyY2xvbmUgfTtcbmNvbnN0IHZlYzMgPSB7IGNsb25lOiB2M2Nsb25lIH07XG5cbi8qKlxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXG4gKiBAcGFyYW0geSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4gSW1hZ2VSZWZlcmVuY2Uge3gseX0gQ29vcmRpbmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VSZWYoeCwgeSkge1xuICAgIGNvbnN0IHRoYXQgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHRvVmVjMigpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLmNsb25lKFt0aGlzLngsIHRoaXMueV0pO1xuICAgICAgICB9LFxuICAgICAgICB0b1ZlYzMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVjMy5jbG9uZShbdGhpcy54LCB0aGlzLnksIDFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmQoKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueCArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueCAtIDAuNSk7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueSArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueSAtIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB0aGF0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIGludGVncmFsIGltYWdlIG9mIGEgZ2l2ZW4gZ3JheXNjYWxlIGltYWdlLlxuICogQHBhcmFtIGltYWdlRGF0YUNvbnRhaW5lciB7SW1hZ2VEYXRhQ29udGFpbmVyfSB0aGUgaW1hZ2UgdG8gYmUgaW50ZWdyYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDsgbGV0IHBvc0EgPSAwOyBsZXQgcG9zQiA9IDA7IGxldCBwb3NDID0gMDsgbGV0IHBvc0QgPSAwOyBsZXQgeDsgbGV0XG4gICAgICAgIHk7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3QgY29sdW1uXG4gICAgcG9zQiA9IHdpZHRoO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSArPSB3aWR0aDtcbiAgICAgICAgcG9zQiArPSB3aWR0aDtcbiAgICB9XG5cbiAgICBwb3NBID0gMDtcbiAgICBwb3NCID0gMTtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSsrO1xuICAgICAgICBwb3NCKys7XG4gICAgfVxuXG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHBvc0EgPSB5ICogd2lkdGggKyAxO1xuICAgICAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcbiAgICAgICAgcG9zQyA9IHkgKiB3aWR0aDtcbiAgICAgICAgcG9zRCA9ICh5IC0gMSkgKiB3aWR0aDtcbiAgICAgICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0FdXG4gICAgICAgICAgICAgICAgKz0gaW1hZ2VEYXRhW3Bvc0FdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NDXSAtIGludGVncmFsSW1hZ2VEYXRhW3Bvc0RdO1xuICAgICAgICAgICAgcG9zQSsrO1xuICAgICAgICAgICAgcG9zQisrO1xuICAgICAgICAgICAgcG9zQysrO1xuICAgICAgICAgICAgcG9zRCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgLy8gc3VtIHVwIGZpcnN0IHJvd1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW2ldO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtpXSA9IHN1bTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB2ID0gMTsgdiA8IGhlaWdodDsgdisrKSB7XG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgICAgc3VtICs9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XTtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IHN1bSArIGludGVncmFsSW1hZ2VEYXRhWyh2IC0gMSkgKiB3aWR0aCArIHVdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhOyBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTsgY29uc3RcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0YXJnZXREYXRhW2xlbmd0aF0gPSBpbWFnZURhdGFbbGVuZ3RoXSA8IHRocmVzaG9sZCA/IDEgOiAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpIHtcbiAgICBpZiAoIWJpdHNQZXJQaXhlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgYml0c1BlclBpeGVsID0gODtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZURhdGE7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuICAgIGNvbnN0IGJ1Y2tldENudCA9IDEgPDwgYml0c1BlclBpeGVsO1xuICAgIGNvbnN0IGhpc3QgPSBuZXcgSW50MzJBcnJheShidWNrZXRDbnQpO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGhpc3RbaW1hZ2VEYXRhW2xlbmd0aF0gPj4gYml0U2hpZnRdKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBsaW5lO1xuICAgIGxldCBsZWZ0ID0gbGluZVswXTtcbiAgICBsZXQgY2VudGVyID0gbGluZVsxXTtcbiAgICBsZXQgcmlnaHQ7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHJpZ2h0ID0gbGluZVtpICsgMV07XG4gICAgICAgIC8vICAtMSA0IC0xIGtlcm5lbFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgbGluZVtpIC0gMV0gPSAoKChjZW50ZXIgKiAyKSAtIGxlZnQgLSByaWdodCkpICYgMjU1O1xuICAgICAgICBsZWZ0ID0gY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSByaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsID0gOCkge1xuICAgIGxldCBoaXN0O1xuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcblxuICAgIGZ1bmN0aW9uIHB4KGluaXQsIGVuZCkge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaSAqIGhpc3RbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZVRocmVzaG9sZCgpIHtcbiAgICAgICAgY29uc3QgdmV0ID0gWzBdO1xuICAgICAgICBsZXQgcDE7XG4gICAgICAgIGxldCBwMjtcbiAgICAgICAgbGV0IHAxMjtcbiAgICAgICAgbGV0IG0xO1xuICAgICAgICBsZXQgbTI7XG4gICAgICAgIGxldCBtMTI7XG4gICAgICAgIGNvbnN0IG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuXG4gICAgICAgIGhpc3QgPSBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBtYXg7IGsrKykge1xuICAgICAgICAgICAgcDEgPSBweCgwLCBrKTtcbiAgICAgICAgICAgIHAyID0gcHgoayArIDEsIG1heCk7XG4gICAgICAgICAgICBwMTIgPSBwMSAqIHAyO1xuICAgICAgICAgICAgaWYgKHAxMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAxMiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtMSA9IG14KDAsIGspICogcDI7XG4gICAgICAgICAgICBtMiA9IG14KGsgKyAxLCBtYXgpICogcDE7XG4gICAgICAgICAgICBtMTIgPSBtMSAtIG0yO1xuICAgICAgICAgICAgdmV0W2tdID0gbTEyICogbTEyIC8gcDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheUhlbHBlci5tYXhJbmRleCh2ZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xuICAgIHJldHVybiB0aHJlc2hvbGQgPDwgYml0U2hpZnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyKTtcblxuICAgIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKTtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xufVxuXG4vLyBsb2NhbCB0aHJlc2hvbGRpbmdcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmluYXJ5SW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcik7XG5cbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDsgbGV0IHY7IGxldCB1OyBjb25zdCBrZXJuZWwgPSAzOyBsZXQgQTsgbGV0IEI7IGxldCBDOyBsZXQgRDsgbGV0IGF2ZzsgY29uc3RcbiAgICAgICAgc2l6ZSA9IChrZXJuZWwgKiAyICsgMSkgKiAoa2VybmVsICogMiArIDEpO1xuXG4gICAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcbiAgICBmb3IgKHYgPSAwOyB2IDw9IGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygoKGhlaWdodCAtIDEpIC0gdikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjbGVhciBvdXQgbGVmdCAmIHJpZ2h0IGJvcmRlclxuICAgIGZvciAodiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPD0ga2VybmVsOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2ID0ga2VybmVsICsgMTsgdiA8IGhlaWdodCAtIGtlcm5lbCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSBrZXJuZWwgKyAxOyB1IDwgd2lkdGggLSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgQSA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgQiA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBDID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgICAgICAgIEQgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBzdW0gPSBEIC0gQyAtIEIgKyBBO1xuICAgICAgICAgICAgYXZnID0gc3VtIC8gKHNpemUpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA+IChhdmcgKyA1KSA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2x1c3Rlcihwb2ludHMsIHRocmVzaG9sZCwgcHJvcGVydHkpIHtcbiAgICBsZXQgaTsgbGV0IGs7IGxldCB0aGlzQ2x1c3RlcjsgbGV0IHBvaW50OyBjb25zdFxuICAgICAgICBjbHVzdGVycyA9IFtdO1xuXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcHJvcGVydHkgPSAncmFkJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUb0NsdXN0ZXIobmV3UG9pbnQpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjbHVzdGVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdGhpc0NsdXN0ZXIgPSBjbHVzdGVyc1trXTtcbiAgICAgICAgICAgIGlmICh0aGlzQ2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXNDbHVzdGVyLmFkZChuZXdQb2ludCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZWFjaCBjbG91ZFxuICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBDbHVzdGVyMi5jcmVhdGVQb2ludChwb2ludHNbaV0sIGksIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFhZGRUb0NsdXN0ZXIocG9pbnQpKSB7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKENsdXN0ZXIyLmNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG5leHBvcnQgY29uc3QgVHJhY2VyID0ge1xuICAgIHRyYWNlKHBvaW50cywgdmVjKSB7XG4gICAgICAgIGxldCBpdGVyYXRpb247XG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgICAgbGV0IHRvcCA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjZW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgY3VycmVudFBvcyA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoaWR4LCBmb3J3YXJkKSB7XG4gICAgICAgICAgICBsZXQgdG87XG4gICAgICAgICAgICBsZXQgdG9JZHg7XG4gICAgICAgICAgICBsZXQgcHJlZGljdGVkUG9zO1xuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkWCA9IDE7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRZID0gTWF0aC5hYnModmVjWzFdIC8gMTApO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHBvcywgcHJlZGljdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy54ID4gKHByZWRpY3RlZC54IC0gdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy54IDwgKHByZWRpY3RlZC54ICsgdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55ID4gKHByZWRpY3RlZC55IC0gdGhyZXNob2xkWSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55IDwgKHByZWRpY3RlZC55ICsgdGhyZXNob2xkWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgaW5kZXggaXMgd2l0aGluIHRoZSB2ZWMgc3BlY2lmaWNhdGlvbnNcbiAgICAgICAgICAgIC8vIGlmIG5vdCwgY2hlY2sgYXMgbG9uZyBhcyB0aGUgdGhyZXNob2xkIGlzIG1ldFxuXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gcG9pbnRzW2lkeF07XG4gICAgICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54ICsgdmVjWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyB2ZWNbMV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggLSB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyBpZHggKyAxIDogaWR4IC0gMTtcbiAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgd2hpbGUgKHRvICYmIChmb3VuZCA9IG1hdGNoKHRvLCBwcmVkaWN0ZWRQb3MpKSAhPT0gdHJ1ZSAmJiAoTWF0aC5hYnModG8ueSAtIGZyb20ueSkgPCB2ZWNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gdG9JZHggKyAxIDogdG9JZHggLSAxO1xuICAgICAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gdG9JZHggOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgICAgICAgICAgLy8gcmFuZG9tbHkgc2VsZWN0IHBvaW50IHRvIHN0YXJ0IHdpdGhcbiAgICAgICAgICAgIGNlbnRlclBvcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvaW50cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyB0cmFjZSBmb3J3YXJkXG4gICAgICAgICAgICB0b3AgPSBbXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCB0cnVlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlclBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIGZhbHNlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b3AubGVuZ3RoID4gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRElMQVRFID0gMTtcbmV4cG9ydCBjb25zdCBFUk9ERSA9IDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICAgIGxldCB2O1xuICAgIGxldCB1O1xuICAgIGNvbnN0IGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3Qgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgeVN0YXJ0MTtcbiAgICBsZXQgeVN0YXJ0MjtcbiAgICBsZXQgeFN0YXJ0MTtcbiAgICBsZXQgeFN0YXJ0MjtcblxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPiAwID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcm9kZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA9PT0gNSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGxldCB7IGxlbmd0aCB9ID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gaW1hZ2VXcmFwcGVyO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHN1bSArPSBkYXRhW2xlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XG4gICAgbGV0IGk7IGxldCBtaW5JZHggPSAwOyBsZXQgbWluID0gMDsgY29uc3QgcXVldWUgPSBbXTsgbGV0IHNjb3JlOyBsZXQgaGl0OyBsZXRcbiAgICAgICAgcG9zO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldID0ge1xuICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICBpdGVtOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XG4gICAgICAgIGlmIChzY29yZSA+IG1pbikge1xuICAgICAgICAgICAgaGl0ID0gcXVldWVbbWluSWR4XTtcbiAgICAgICAgICAgIGhpdC5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgaGl0Lml0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGZvciAocG9zID0gMDsgcG9zIDwgdG9wOyBwb3MrKykge1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtwb3NdLnNjb3JlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHF1ZXVlW3Bvc10uc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIG1pbklkeCA9IHBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tSW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCBjdHgsIGFycmF5KSB7XG4gICAgY3R4LmRyYXdJbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCk7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21Db250ZXh0KGN0eCwgc2l6ZSwgb2Zmc2V0LCBhcnJheSkge1xuICAgIGNvbnN0IGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSwgc2l6ZS54LCBzaXplLnkpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjYW52YXNEYXRhLCBzaXplLCBvdXRBcnJheSkge1xuICAgIGxldCB0b3BSb3dJZHggPSAwO1xuICAgIGxldCBib3R0b21Sb3dJZHggPSBzaXplLng7XG4gICAgY29uc3QgZW5kSWR4ID0gTWF0aC5mbG9vcihjYW52YXNEYXRhLmxlbmd0aCAvIDQpO1xuICAgIGNvbnN0IG91dFdpZHRoID0gc2l6ZS54IC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICBjb25zdCBpbldpZHRoID0gc2l6ZS54O1xuICAgIGxldCBpO1xuXG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbWdJZHhdID0gKFxuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMV1cbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMl0pKSAvIDQ7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xuICAgIGNvbnN0IGwgPSAoaW1hZ2VEYXRhLmxlbmd0aCAvIDQpIHwgMDtcbiAgICBjb25zdCBzaW5nbGVDaGFubmVsID0gY29uZmlnICYmIGNvbmZpZy5zaW5nbGVDaGFubmVsID09PSB0cnVlO1xuXG4gICAgaWYgKHNpbmdsZUNoYW5uZWwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSBpbWFnZURhdGFbaSAqIDQgKyAwXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaywgY2FudmFzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY29tcHV0ZUdyYXkoZGF0YSwgYXJyYXkpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGFycmF5LCB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQsXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBAcGFyYW0gaW5JbWcge0ltYWdlV3JhcHBlcn0gaW5wdXQgaW1hZ2UgdG8gYmUgc2FtcGxlZFxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbGZTYW1wbGUoaW5JbWdXcmFwcGVyLCBvdXRJbWdXcmFwcGVyKSB7XG4gICAgY29uc3QgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBvdXRJbWcgPSBvdXRJbWdXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IGluV2lkdGg7XG4gICAgY29uc3QgZW5kSWR4ID0gaW5JbWcubGVuZ3RoO1xuICAgIGNvbnN0IG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoaW5JbWdbdG9wUm93SWR4XSArIGluSW1nW3RvcFJvd0lkeCArIDFdICsgaW5JbWdbYm90dG9tUm93SWR4XSArIGluSW1nW2JvdHRvbVJvd0lkeCArIDFdKSAvIDQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggKz0gMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCArPSBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiID0gWzAsIDAsIDBdKSB7XG4gICAgY29uc3QgaCA9IGhzdlswXTtcbiAgICBjb25zdCBzID0gaHN2WzFdO1xuICAgIGNvbnN0IHYgPSBoc3ZbMl07XG4gICAgY29uc3QgYyA9IHYgKiBzO1xuICAgIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSk7XG4gICAgY29uc3QgbSA9IHYgLSBjO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuXG4gICAgaWYgKGggPCA2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgZyA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBnID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICAgICAgZyA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgICAgICBnID0geDtcbiAgICAgICAgYiA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMF0gPSAoKHIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlsxXSA9ICgoZyArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZXR1cm4gcmdiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVEaXZpc29ycyhuKSB7XG4gICAgY29uc3QgbGFyZ2VEaXZpc29ycyA9IFtdO1xuICAgIGNvbnN0IGRpdmlzb3JzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IE1hdGguc3FydChuKSArIDE7IGkrKykge1xuICAgICAgICBpZiAobiAlIGkgPT09IDApIHtcbiAgICAgICAgICAgIGRpdmlzb3JzLnB1c2goaSk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gbiAvIGkpIHtcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XG59XG5cbmZ1bmN0aW9uIF9jb21wdXRlSW50ZXJzZWN0aW9uKGFycjEsIGFycjIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycjFbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKGFycjFbaV0gPiBhcnIyW2pdKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhdGNoU2l6ZShwYXRjaFNpemUsIGltZ1NpemUpIHtcbiAgICBjb25zdCBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCk7XG4gICAgY29uc3QgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpO1xuICAgIGNvbnN0IHdpZGVTaWRlID0gTWF0aC5tYXgoaW1nU2l6ZS54LCBpbWdTaXplLnkpO1xuICAgIGNvbnN0IGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNNYXAgPSB7XG4gICAgICAgICd4LXNtYWxsJzogNSxcbiAgICAgICAgc21hbGw6IDQsXG4gICAgICAgIG1lZGl1bTogMyxcbiAgICAgICAgbGFyZ2U6IDIsXG4gICAgICAgICd4LWxhcmdlJzogMSxcbiAgICB9O1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW07XG4gICAgY29uc3QgbnJPZlBhdGNoZXMgPSBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdO1xuICAgIGNvbnN0IGRlc2lyZWRQYXRjaFNpemUgPSBNYXRoLmZsb29yKHdpZGVTaWRlIC8gbnJPZlBhdGNoZXMpO1xuICAgIGxldCBvcHRpbWFsUGF0Y2hTaXplO1xuXG4gICAgZnVuY3Rpb24gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGRpdmlzb3JzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGZvdW5kID0gZGl2aXNvcnNbTWF0aC5mbG9vcihkaXZpc29ycy5sZW5ndGggLyAyKV07XG5cbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XVxuICAgICAgICAgICAgJiYgZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kID4gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4IC0gMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmb3VuZCwgeTogZm91bmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGNvbW1vbik7XG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyh3aWRlU2lkZSkpO1xuICAgICAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpbWFsUGF0Y2hTaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSksXG4gICAgICAgIHVuaXQ6IHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSA/ICclJyA6ICclJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZXhwb3J0IGNvbnN0IF9kaW1lbnNpb25zQ29udmVydGVycyA9IHtcbiAgICB0b3AoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSA6IG51bGw7XG4gICAgfSxcbiAgICByaWdodChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggLSAoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgYm90dG9tKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgLSAoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpIDogbnVsbDtcbiAgICB9LFxuICAgIGxlZnQoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0geyB3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9O1xuXG4gICAgY29uc3QgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmVhW2tleV07XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWQgPSBfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XShwYXJzZWQsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGN1bGF0ZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3g6IHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc3k6IHBhcnNlZEFyZWEudG9wLFxuICAgICAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc2g6IHBhcnNlZEFyZWEuYm90dG9tIC0gcGFyc2VkQXJlYS50b3AsXG4gICAgfTtcbn1cbiIsImltcG9ydCB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG4vLyBUT0RPOiBYWVBvc2l0aW9uIHNob3VsZCBiZSBhbiBYWU9iamVjdCwgYnV0IHRoYXQgYnJlYWtzIFhZRGVmaW5pdGlvbiwgd2hpY2ggYnJlYWtzIGRyYXdQYXRoKCkgYmVsb3cuXG5kZWNsYXJlIGludGVyZmFjZSBYWVBvc2l0aW9uIHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG5kZWNsYXJlIGludGVyZmFjZSBDYW52YXNTdHlsZSB7XG4gICAgY29sb3I6IHN0cmluZztcbiAgICBsaW5lV2lkdGg6IG51bWJlcjtcbn1cblxuLy8gWFlEZWZpbml0aW9uIHRlbGxzIHVzIHdoaWNoIGNvbXBvbmVudCBvZiBhIGdpdmVuIGFycmF5IG9yIG9iamVjdCBpcyB0aGUgXCJYXCIgYW5kIHdoaWNoIGlzIHRoZSBcIllcIi5cbi8vIFVzdWFsbHkgdGhpcyBpcyAwIGZvciBYIGFuZCAxIGZvciBZLCBidXQgbWlnaHQgYmUgdXNlZCBhcyAneCcgZm9yIHggYW5kICd5JyBmb3IgWS5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZRGVmaW5pdGlvbiB7XG4gICAgeDoga2V5b2YgWFlQb3NpdGlvbjtcbiAgICB5OiBrZXlvZiBYWVBvc2l0aW9uO1xufVxuXG5kZWNsYXJlIHR5cGUgUGF0aCA9IEFycmF5PFhZUG9zaXRpb24+O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZHJhd1JlY3QocG9zOiBYWVBvc2l0aW9uLCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCAxO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHBvcy54LCBwb3MueSwgc2l6ZS54LCBzaXplLnkpO1xuICAgIH0sXG4gICAgZHJhd1BhdGgocGF0aDogUGF0aCwgZGVmOiBYWURlZmluaXRpb24sIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjdHguY2FudmFzLndpZHRoLCBjdHguY2FudmFzLmhlaWdodClcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBhdGhbMF1bZGVmLnhdLCBwYXRoWzBdW2RlZi55XSk7XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwYXRoW2pdW2RlZi54XSwgcGF0aFtqXVtkZWYueV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgZHJhd0ltYWdlKGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPiwgc2l6ZTogWFlTaXplLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjYW52YXNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLngsIHNpemUueSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gY2FudmFzRGF0YTtcbiAgICAgICAgbGV0IGNhbnZhc0RhdGFQb3MgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGltYWdlRGF0YVBvcyA9IGltYWdlRGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNhbnZhc0RhdGFQb3MgLyBpbWFnZURhdGFQb3MgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW1hZ2VEYXRhUG9zLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW1hZ2VEYXRhW2ltYWdlRGF0YVBvc107XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBUeXBlZEFycmF5IH0gZnJvbSBcIi4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0OiBmdW5jdGlvbihhcnI6IFR5cGVkQXJyYXkgfCBBcnJheTxhbnk+LCB2YWw6IGFueSkge1xuICAgICAgICAvLyBhcnIuZmlsbCh2YWwpO1xuICAgICAgICBsZXQgbCA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIGFycltsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaHVmZmxlcyB0aGUgY29udGVudCBvZiBhbiBhcnJheVxuICAgICAqL1xuICAgIHNodWZmbGU6IGZ1bmN0aW9uKGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgaSA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSk7XG4gICAgICAgICAgICBjb25zdCB4ID0gYXJyW2ldO1xuICAgICAgICAgICAgYXJyW2ldID0gYXJyW2pdO1xuICAgICAgICAgICAgYXJyW2pdID0geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICB0b1BvaW50TGlzdDogZnVuY3Rpb24oYXJyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xuICAgICAgICBjb25zdCByb3dzID0gYXJyLnJlZHVjZSgocCwgbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gYFske24uam9pbignLCcpfV1gO1xuICAgICAgICAgICAgcC5wdXNoKHJvdyk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSwgW10gYXMgQXJyYXk8c3RyaW5nPik7XG4gICAgICAgIHJldHVybiBgWyR7cm93cy5qb2luKCcsXFxyXFxuJyl9XWA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGVsZW1lbnRzIHdoaWNoJ3Mgc2NvcmUgaXMgYmlnZ2VyIHRoYW4gdGhlIHRocmVzaG9sZFxuICAgICAqL1xuICAgIHRocmVzaG9sZDogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+LCB0aHJlc2hvbGQ6IG51bWJlciwgc2NvcmVGdW5jOiAoKHNjb3JlOiBudW1iZXIpID0+IG51bWJlcikpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBhcnIucmVkdWNlKChwcmV2OiBBcnJheTxudW1iZXI+LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NvcmVGdW5jLmFwcGx5KGFyciwgW25leHRdKSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfSxcblxuICAgIG1heEluZGV4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gYXJyW21heF0pIHtcbiAgICAgICAgICAgICAgICBtYXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oYXJyOiBBcnJheTxhbnk+KSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH0sXG5cbiAgICBzdW06IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55PiB8IFR5cGVkQXJyYXkpOiBudW1iZXIge1xuICAgICAgICBsZXQgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW0gKz0gYXJyW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgeyBoc3YycmdiIH0gZnJvbSAnLi9jdl91dGlscyc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IHtcbiAgICBYWVNpemUsXG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICAgIFR5cGVkQXJyYXksXG4gICAgV3JhcHBlckluZGV4TWFwcGluZyxcbiAgICBNb21lbnQsXG4gICAgU3BhcnNlSW1hZ2VXcmFwcGVyLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmUgfTtcblxudHlwZSBQb3NpdGl2ZU51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGFzc2VydE51bWJlclBvc2l0aXZlKHZhbDogbnVtYmVyKTogYXNzZXJ0cyB2YWwgaXMgUG9zaXRpdmVOdW1iZXIge1xuICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyLCByZWNlaXZlZCAke3ZhbH1gKTtcbiAgICB9XG59XG5cbmNsYXNzIEltYWdlV3JhcHBlciBpbXBsZW1lbnRzIFNwYXJzZUltYWdlV3JhcHBlciB7XG4gICAgZGF0YTogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj47XG5cbiAgICBzaXplOiBYWVNpemU7XG5cbiAgICBpbmRleE1hcHBpbmc/OiBXcmFwcGVySW5kZXhNYXBwaW5nO1xuXG4gICAgLy8gUmVwcmVzZW50cyBhIGJhc2ljIGltYWdlIGNvbWJpbmluZyB0aGUgZGF0YSBhbmQgc2l6ZS4gSW4gYWRkaXRpb24sIHNvbWUgbWV0aG9kcyBmb3JcbiAgICAvLyBtYW5pcHVsYXRpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4uXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHNpemU6IFhZU2l6ZSxcbiAgICAgICAgZGF0YT86IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LFxuICAgICAgICBBcnJheVR5cGU6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8IEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5LFxuICAgICAgICBpbml0aWFsaXplPzogYm9vbGVhbixcbiAgICApIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgKEFycmF5VHlwZSkoc2l6ZS54ICogc2l6ZS55KTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdCh0aGlzLmRhdGEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIC8vIHRlc3RzIGlmIGEgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbWFnZSwgZXh0ZW5kZWQgb3V0IGJ5IGEgYm9yZGVyIG9uIGVhY2ggc2lkZVxuICAgIGluSW1hZ2VXaXRoQm9yZGVyKGltZ1JlZjogWFlTaXplLCBib3JkZXI6IFBvc2l0aXZlTnVtYmVyID0gMCk6IGJvb2xlYW4ge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShib3JkZXIpO1xuICAgICAgICAvLyBUT0RPOiBjb2RlXzEyOCBzdGFydHMgZmFpbGluZyBtaXNlcmFibHkgd2hlbiBpIG9ubHkgYWxsb3cgaW1nUmVmIHRvIGNvbnRhaW4gcG9zaXRpdmUgbnVtYmVycy5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBtZSwgd2h5IGRvZXMgaXQgZ28gbmVnYXRpdmU/ICBUZXN0cyBhcmUgbm90IGFmZmVjdGVkIGJ5XG4gICAgICAgIC8vIHJldHVybmluZyBmYWxzZSwgYnV0IHRoZSB3aG9sZSBjb2RlXzEyOCByZWFkZXIgYmxvd3MgdXAgd2hlbiBpIHRocm93IG9uIG5lZ2F0aXZlIGltZ1JlZi5cbiAgICAgICAgLy8gYXNzZXJ0TnVtYmVyUG9zaXRpdmUoaW1nUmVmLngpO1xuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueSk7XG4gICAgICAgIHJldHVybiAoaW1nUmVmLnggPj0gMClcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi54IDwgKHRoaXMuc2l6ZS54ICsgKGJvcmRlciAqIDIpKSlcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA8ICh0aGlzLnNpemUueSArIChib3JkZXIgKiAyKSkpO1xuICAgIH1cblxuICAgIC8vIENvcHkgZnJvbSBUSElTIEltYWdlV3JhcHBlciB0byB0aGUgbmV3IGltYWdlV3JhcHBlciBwYXJhbWV0ZXIsIHN0YXJ0aW5nIGF0IGZyb20sIHN0b3BwaW5nIGF0XG4gICAgLy8gZW5kIG9mIG5ldyBpbWFnZVdyYXBwZXIgc2l6ZS5cbiAgICBzdWJJbWFnZUFzQ29weShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciwgZnJvbTogWFlTaXplKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS54KTtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS55KTtcbiAgICAgICAgY29uc3QgeyB4OiBzaXplWCwgeTogc2l6ZVkgfSA9IGltYWdlV3JhcHBlci5zaXplO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemVYOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhW3kgKiBzaXplWCArIHhdID0gdGhpcy5kYXRhWyhmcm9tLnkgKyB5KSAqIHRoaXMuc2l6ZS54ICsgZnJvbS54ICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlV3JhcHBlcjtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiByZWFsbHkgcHJvYmFibHkgc2hvdWxkIGNhbGwgaW50byBJbWFnZVdyYXBwZXIgc29tZXdoZXJlIHRvIG1ha2VcbiAgICAgICAgLy8gc3VyZSB0aGF0IGFsbCBvZiBpdCdzIHBhcmFtZXRlcnMgYXJlIHNldCBwcm9wZXJseSwgc29tZXRoaW5nIGxpa2VcbiAgICAgICAgLy8gSW1hZ2VXcmFwcGVyLlVwZGF0ZUZyb20oKVxuICAgICAgICAvLyB0aGF0IG1pZ2h0IHRha2UgYSBwcm92aWRlZCBkYXRhIGFuZCBzaXplLCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3Mgbm8gaW52YWxpZCBpbmRleE1hcHBpbmdcbiAgICAgICAgLy8gaGFuZ2luZyBhcm91bmQsIGFuZCBzdWNoLlxuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2VcbiAgICBnZXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UgKHNhZmUsIHdoYXRldmVyIHRoYXRcbiAgICAvLyBtZWFucylcbiAgICBnZXRTYWZlKHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgLy8gY2FjaGUgaW5kZXhNYXBwaW5nIGJlY2F1c2UgaWYgd2UncmUgdXNpbmcgaXQgb25jZSwgd2UnbGwgcHJvYmFibHkgbmVlZCBpdCBhIGJ1bmNoIG1vcmVcbiAgICAgICAgLy8gdG9vXG4gICAgICAgIGlmICghdGhpcy5pbmRleE1hcHBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLng7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZS55OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2ldID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2kgKyB0aGlzLnNpemUueV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbKHRoaXMuaW5kZXhNYXBwaW5nLnlbeSArIHRoaXMuc2l6ZS55XSkgKiB0aGlzLnNpemUueCArIHRoaXMuaW5kZXhNYXBwaW5nLnhbeCArIHRoaXMuc2l6ZS54XV07XG4gICAgfVxuXG4gICAgLy8gU2V0cyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gZ3JheXNjYWxlIHZhbHVlXG4gICAgc2V0KHg6IG51bWJlciwgeTogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gdmFsdWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgYm9yZGVyIG9mIHRoZSBpbWFnZSAoMSBwaXhlbCkgdG8gemVyb1xuICAgIHplcm9Cb3JkZXIoKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgY29uc3QgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0gPSB0aGlzLnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gdGhpcy5kYXRhWyhoZWlnaHQgLSAxKSAqIHdpZHRoICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaSAqIHdpZHRoXSA9IHRoaXMuZGF0YVtpICogd2lkdGggKyAod2lkdGggLSAxKV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiBpcyBlbnRpcmVseSB0b28gbGFyZ2UgZm9yIG1lIHRvIHJlYXNvbiBvdXQgcmlnaHQgYXQgdGhpcyBtb21lbnQgdGhhdCBpJ20gaGFuZGxpbmdcbiAgICAvLyBhbGwgdGhlIHJlc3Qgb2YgaXQsIHNvIHRoaXMgaXMgYSB2ZXJiYXRpbSBjb3B5IG9mIHRoZSBqYXZhc2NyaXB0IHNvdXJjZSwgd2l0aCBvbmx5IHR3ZWFrc1xuICAgIC8vIG5lY2Vzc2FyeSB0byBnZXQgaXQgdG8gcnVuLCBubyB0aG91Z2h0IHB1dCBpbnRvIGl0IHlldC5cbiAgICBtb21lbnRzKGxhYmVsQ291bnQ6IG51bWJlcik6IEFycmF5PE1vbWVudD4ge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXM7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgIGxldCB2YWw7XG4gICAgICAgIGxldCB5c3E7XG4gICAgICAgIGNvbnN0IGxhYmVsU3VtOiBBcnJheTxNb21lbnQ+ID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgIGxldCBtdTExO1xuICAgICAgICBsZXQgbXUwMjtcbiAgICAgICAgbGV0IG11MjA7XG4gICAgICAgIGxldCB4XztcbiAgICAgICAgbGV0IHlfO1xuICAgICAgICBsZXQgdG1wO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgY29uc3QgeyBQSSB9ID0gTWF0aDtcbiAgICAgICAgY29uc3QgUElfNCA9IFBJIC8gNDtcblxuICAgICAgICBpZiAobGFiZWxDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxTdW1baV0gPSB7XG4gICAgICAgICAgICAgICAgbTAwOiAwLFxuICAgICAgICAgICAgICAgIG0wMTogMCxcbiAgICAgICAgICAgICAgICBtMTA6IDAsXG4gICAgICAgICAgICAgICAgbTExOiAwLFxuICAgICAgICAgICAgICAgIG0wMjogMCxcbiAgICAgICAgICAgICAgICBtMjA6IDAsXG4gICAgICAgICAgICAgICAgdGhldGE6IDAsXG4gICAgICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgeXNxID0geSAqIHk7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVt2YWwgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAwICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMSArPSB5O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTExICs9IHggKiB5O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDIgKz0geXNxO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVtpXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICAgIGlmICghaXNOYU4obGFiZWwubTAwKSAmJiBsYWJlbC5tMDAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB4XyA9IGxhYmVsLm0xMCAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgICAgICB5XyA9IGxhYmVsLm0wMSAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgICAgICBtdTExID0gbGFiZWwubTExIC8gbGFiZWwubTAwIC0geF8gKiB5XztcbiAgICAgICAgICAgICAgICBtdTAyID0gbGFiZWwubTAyIC8gbGFiZWwubTAwIC0geV8gKiB5XztcbiAgICAgICAgICAgICAgICBtdTIwID0gbGFiZWwubTIwIC8gbGFiZWwubTAwIC0geF8gKiB4XztcbiAgICAgICAgICAgICAgICB0bXAgPSAobXUwMiAtIG11MjApIC8gKDIgKiBtdTExKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAwLjUgKiBNYXRoLmF0YW4odG1wKSArIChtdTExID49IDAgPyBQSV80IDogLVBJXzQpICsgUEk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhID0gKHRtcCAqIDE4MCAvIFBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsLnRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSArPSAxODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XG4gICAgICAgICAgICAgICAgbGFiZWwudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3ModG1wKSwgTWF0aC5zaW4odG1wKV0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIFVpbnQ4Q2xhbXBlZEFycmF5IGNvbnRhaW5pbmcgdGhpcyBncmF5c2NhbGUgaW1hZ2UgY29udmVydGVkIHRvIFJHQkEgZm9ybVxuICAgIGdldEFzUkdCQShzY2FsZSA9IDEuMCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQgKiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55KTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0KHgsIHkpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDBdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMV0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAyXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSB0aGlzIEltYWdlV3JhcHBlciBpbiBhIGdpdmVuIENhbnZhcyBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgc2NhbGVcbiAgICBzaG93KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlID0gMS4wKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEFzUkdCQShzY2FsZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSBuZXcgSW1hZ2VEYXRhKGRhdGEsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKG5ld0ZyYW1lLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5cyBhIHNwZWNpZmllZCBTdWJJbWFnZSBhcmVhIGluIGEgZ2l2ZW4gY2FudmFzLiBUaGlzIGRpZmZlcnMgZHJhc3RpY2FsbHkgZnJvbVxuICAgIC8vIGNyZWF0aW5nIGEgbmV3IFN1YkltYWdlIGFuZCB1c2luZyBpdCdzIHNob3coKSBtZXRob2QuIFdoeT8gSSBkb24ndCBoYXZlIHRoZSBhbnN3ZXIgdG8gdGhhdFxuICAgIC8vIHlldC4gIEkgc3VzcGVjdCB0aGUgSFNWL1JHQiBvcGVyYXRpb25zIGludm9sdmVkIGhlcmUgYXJlIG1ha2luZyBpdCBzaWduaWZpY2FudGx5IGRpZmZlcmVudCxcbiAgICAvLyBidXQgdW50aWwgSSBjYW4gdmlzdWFsaXplIHRoZXNlIGZ1bmN0aW9ucyBzaWRlIGJ5IHNpZGUsIEknbSBqdXN0IGdvaW5nIHRvIGNvcHkgdGhlIGV4aXN0aW5nXG4gICAgLy8gaW1wbGVtZW50YXRpb24uXG4gICAgb3ZlcmxheShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBpblNjYWxlOiBudW1iZXIsIGZyb206IFhZU2l6ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFNjYWxlID0gKGluU2NhbGUgPCAwIHx8IGluU2NhbGUgPiAzNjApID8gMzYwIDogaW5TY2FsZTtcbiAgICAgICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgICAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IHdoaXRlUmdiID0gWzI1NSwgMjU1LCAyNTVdO1xuICAgICAgICBjb25zdCBibGFja1JnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YShmcm9tLngsIGZyb20ueSwgdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBmcmFtZTtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSB0aGlzLmRhdGE7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgaHN2WzBdID0gdGhpcy5kYXRhW2xlbmd0aF0gKiBhZGp1c3RlZFNjYWxlO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICByZXN1bHQgPSBoc3ZbMF0gPD0gMCA/IHdoaXRlUmdiIDogaHN2WzBdID49IDM2MCA/IGJsYWNrUmdiIDogaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBsZW5ndGggKiA0O1xuICAgICAgICAgICAgW2RhdGFbcG9zXSwgZGF0YVtwb3MgKyAxXSwgZGF0YVtwb3MgKyAyXV0gPSByZXN1bHQ7XG4gICAgICAgICAgICBkYXRhW3BvcyArIDNdID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoZnJhbWUsIGZyb20ueCwgZnJvbS55KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlV3JhcHBlcjtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZVwiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGxldCBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgeDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgICAgICAgIGlmICgoaW1hZ2VEYXRhW3Bvc10gPT09IGNvbG9yKSAmJiAoKGxhYmVsRGF0YVtwb3NdID09PSAwKSB8fCAobGFiZWxEYXRhW3Bvc10gPT09IGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDEpICUgODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgRnYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IEN2O1xuICAgICAgICAgICAgbGV0IFA7XG4gICAgICAgICAgICBsZXQgbGRpcjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY3g6IHN4LFxuICAgICAgICAgICAgICAgIGN5OiBzeSxcbiAgICAgICAgICAgICAgICBkaXI6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgRnYgPSB2ZXJ0ZXgyRChzeCwgc3ksIGN1cnJlbnQuZGlyKTtcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDYpICUgODtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gJ2dsLW1hdDInO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xuaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcblxuXG5sZXQgX2NvbmZpZztcbmxldCBfY3VycmVudEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbEltYWdlV3JhcHBlcjtcbmxldCBfc3ViSW1hZ2VXcmFwcGVyO1xubGV0IF9sYWJlbEltYWdlV3JhcHBlcjtcbmxldCBfcGF0Y2hHcmlkO1xubGV0IF9wYXRjaExhYmVsR3JpZDtcbmxldCBfaW1hZ2VUb1BhdGNoR3JpZDtcbmxldCBfYmluYXJ5SW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaFNpemU7XG5jb25zdCBfY2FudmFzQ29udGFpbmVyID0ge1xuICAgIGN0eDoge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbiAgICBkb206IHtcbiAgICAgICAgYmluYXJ5OiBudWxsLFxuICAgIH0sXG59O1xuY29uc3QgX251bVBhdGNoZXMgPSB7IHg6IDAsIHk6IDAgfTtcbmxldCBfaW5wdXRJbWFnZVdyYXBwZXI7XG5sZXQgX3NrZWxldG9uaXplcjtcblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB5OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gMiB8IDAsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xuICAgIH1cblxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBfbnVtUGF0Y2hlcy54ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3BhdGNoU2l6ZS54IHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnkgPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfcGF0Y2hTaXplLnkgfCAwO1xuXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSwgdW5kZWZpbmVkLCBVaW50OEFycmF5LCBmYWxzZSk7XG5cbiAgICBfbGFiZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuXG4gICAgY29uc3Qgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcbiAgICBfc3ViSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgMCwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSk7XG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLFxuICAgICAgICB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoXG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiBnbG9iYWwsXG4gICAgICAgIHsgc2l6ZTogX3BhdGNoU2l6ZS54IH0sXG4gICAgICAgIHNrZWxldG9uSW1hZ2VEYXRhLFxuICAgICk7XG5cbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB4OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLngpIHwgMCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXG4gICAgfSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG4gICAgX3BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAoX2NvbmZpZy51c2VXb3JrZXIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSAnYmluYXJ5QnVmZmVyJztcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcnKS5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkpO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICBsZXQgb3ZlckF2ZztcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IHRyYW5zTWF0O1xuICAgIGxldCBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgYm94O1xuICAgIGxldCBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hlcykge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAncmVkJyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XG4gICAgb3ZlckF2ZyA9IChvdmVyQXZnICogMTgwIC8gTWF0aC5QSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgIGlmIChvdmVyQXZnIDwgMCkge1xuICAgICAgICBvdmVyQXZnICs9IDE4MDtcbiAgICB9XG5cbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcbiAgICB0cmFuc01hdCA9IG1hdDIuY29weShtYXQyLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xuICAgICAgICAgICAgICAgIG1pbnggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdID4gbWF4eCkge1xuICAgICAgICAgICAgICAgIG1heHggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdIDwgbWlueSkge1xuICAgICAgICAgICAgICAgIG1pbnkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xuICAgICAgICAgICAgICAgIG1heHkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIoYm94W2pdLCBib3hbal0sIHRyYW5zTWF0KTtcbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd0JCKSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIuc2NhbGUoYm94W2pdLCBib3hbal0sIHNjYWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiaW5hcnkgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gYmluYXJpemVJbWFnZSgpIHtcbiAgICBvdHN1VGhyZXNob2xkKF9jdXJyZW50SW1hZ2VXcmFwcGVyLCBfYmluYXJ5SW1hZ2VXcmFwcGVyKTtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcykge1xuICAgICAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNob3coX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAyNTUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBpbWFnZVxuICogZXh0cmFjdCBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRjaGVzKCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBtb21lbnRzO1xuICAgIGxldCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBsZXQgcmFzdGVyaXplcjtcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xuICAgIGxldCBwYXRjaDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgX251bVBhdGNoZXMueDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcbiAgICAgICAgICAgIHggPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCAqIGk7XG4gICAgICAgICAgICB5ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnkgKiBqO1xuXG4gICAgICAgICAgICAvLyBzZXBlcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgc2tlbGV0b25pemUoeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIFJhc3Rlcml6ZSwgZmluZCBpbmRpdmlkdWFsIGJhcnNcbiAgICAgICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xuICAgICAgICAgICAgcmFzdGVyaXplciA9IFJhc3Rlcml6ZXIuY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgcmFzdGVyUmVzdWx0ID0gcmFzdGVyaXplci5yYXN0ZXJpemUoMCk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgX2xhYmVsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCBNYXRoLmZsb29yKDM2MCAvIHJhc3RlclJlc3VsdC5jb3VudCksXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0ZvdW5kUGF0Y2hlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBzdW07XG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xuICAgIGxldCB0b3BMYWJlbHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xuICAgIH1cbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID4gMCkge1xuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcCgodmFsLCBpZHgpID0+ICh7XG4gICAgICAgIHZhbCxcbiAgICAgICAgbGFiZWw6IGlkeCArIDEsXG4gICAgfSkpO1xuXG4gICAgbGFiZWxIaXN0LnNvcnQoKGEsIGIpID0+IGIudmFsIC0gYS52YWwpO1xuXG4gICAgLy8gZXh0cmFjdCB0b3AgYXJlYXMgd2l0aCBhdCBsZWFzdCA2IHBhdGNoZXMgcHJlc2VudFxuICAgIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoKGVsKSA9PiBlbC52YWwgPj0gNSk7XG5cbiAgICByZXR1cm4gdG9wTGFiZWxzO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHN1bTtcbiAgICBjb25zdCBwYXRjaGVzID0gW107XG4gICAgbGV0IHBhdGNoO1xuICAgIGxldCBib3g7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcExhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgICAgIHBhdGNoZXMubGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA9PT0gdG9wTGFiZWxzW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3N1bV07XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib3ggPSBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXM7XG59XG5cbi8qKlxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG1vbWVudHNcbiAqL1xuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xuICAgIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcbiAgICBjb25zdCB0b3BDbHVzdGVyID0gdG9wR2VuZXJpYyhjbHVzdGVycywgMSwgKGUpID0+IGUuZ2V0UG9pbnRzKCkubGVuZ3RoKTtcbiAgICBsZXQgcG9pbnRzID0gW107IGNvbnN0XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIGlmICh0b3BDbHVzdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaV0ucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNrZWxldG9uaXplKHgsIHkpIHtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcbiAgICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XG5cbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93U2tlbGV0b24pIHtcbiAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDM2MCwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhbmQgZGVzY3JpYmVzIHRob3NlIHBhdGNoZXMgd2hpY2ggc2VlbSB0byBjb250YWluIGEgYmFyY29kZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge0FycmF5fSBtb21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUGF0Y2gobW9tZW50cywgcGF0Y2hQb3MsIHgsIHkpIHtcbiAgICBsZXQgaztcbiAgICBsZXQgYXZnO1xuICAgIGNvbnN0IGVsaWdpYmxlTW9tZW50cyA9IFtdO1xuICAgIGxldCBtYXRjaGluZ01vbWVudHM7XG4gICAgbGV0IHBhdGNoO1xuICAgIGNvbnN0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGNvbnN0IG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcblxuICAgIGlmIChtb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxuICAgICAgICBpZiAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xuICAgICAgICAgICAgYXZnID0gMDtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc2ltaWxhcml0eSBvZiB0aGUgbW9tZW50c1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGF2ZyArPSBtYXRjaGluZ01vbWVudHNba10ucmFkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHR3byBvZiB0aGUgbW9tZW50cyBhcmUgYWxsb3dlZCBub3QgdG8gZml0IGludG8gdGhlIGVxdWF0aW9uXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBhdGNoIHRvIHRoZSBzZXRcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID49IChlbGlnaWJsZU1vbWVudHMubGVuZ3RoIC8gNCkgKiAzXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiBtb21lbnRzLmxlbmd0aCAvIDQpIHtcbiAgICAgICAgICAgICAgICBhdmcgLz0gbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhdGNoUG9zWzFdICogX251bVBhdGNoZXMueCArIHBhdGNoUG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRzOiBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHJhZDogYXZnLFxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhdGNoZXNGb3VuZC5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIGZpbmRzIHBhdGNoZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2hhcmUgdGhlIHNhbWUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaGVzRm91bmRcbiAqL1xuZnVuY3Rpb24gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKSB7XG4gICAgbGV0IGxhYmVsID0gMDtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjk1O1xuICAgIGxldCBjdXJySWR4ID0gMDtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZ1bmN0aW9uIG5vdFlldFByb2Nlc3NlZCgpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2ldID09PSAwICYmIF9wYXRjaEdyaWQuZGF0YVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcGF0Y2hMYWJlbEdyaWQubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgY3VycmVudFBhdGNoO1xuICAgICAgICBsZXQgaWR4O1xuICAgICAgICBsZXQgZGlyO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXG4gICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNpbWlsYXJpdHk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XG4gICAgICAgICAgICBmb3IgKGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICB3aGlsZSAoKGN1cnJJZHggPSBub3RZZXRQcm9jZXNzZWQoKSkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbGFiZWwrKztcbiAgICAgICAgdHJhY2UoY3VycklkeCk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaExhYmVscykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZSgpIHtcbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgICAgICBjb25zdCBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgY29uc3QgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XG4gICAgICAgIGxldCBwYXRjaFNpemU7XG4gICAgICAgIGxldCB3aWR0aCA9IGlucHV0U3RyZWFtLmdldFdpZHRoKCk7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XG4gICAgICAgIGxldCBhcmVhO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoeyB4OiBhcmVhLnN4LCB5OiBhcmVhLnN5IH0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB3aWR0aCA9IGFyZWEuc3c7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcmVhLnNoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3Iod2lkdGggKiB0aGlzSGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgfTtcblxuICAgICAgICBwYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoY29uZmlnLnBhdGNoU2l6ZSwgc2l6ZSk7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXRjaC1TaXplOiAke0pTT04uc3RyaW5naWZ5KHBhdGNoU2l6ZSl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCkpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLnkpKTtcblxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgZGltZW5zaW9ucyBkbyBub3QgY29tcGx5IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3M6IFdpZHRoICgke1xuICAgICAgICAgICAgd2lkdGh9IClhbmQgaGVpZ2h0ICgke2hlaWdodFxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcbiAgICB9LFxufTtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGZyb2I6IHJlcXVpcmUoJy4vZnJvYicpXG4gICwgbGR1OiByZXF1aXJlKCcuL2xkdScpXG59XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgQmlnSW50NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiYmlnaW50NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgQmlnVWludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ3VpbnQ2NFwiXG4gICAgfVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiXG4gIH1cbiAgcmV0dXJuIFwiZ2VuZXJpY1wiXG59XG5cbnZhciBDQUNIRURfQ09OU1RSVUNUT1JTID0ge1xuICBcImZsb2F0MzJcIjpbXSxcbiAgXCJmbG9hdDY0XCI6W10sXG4gIFwiaW50OFwiOltdLFxuICBcImludDE2XCI6W10sXG4gIFwiaW50MzJcIjpbXSxcbiAgXCJ1aW50OFwiOltdLFxuICBcInVpbnQxNlwiOltdLFxuICBcInVpbnQzMlwiOltdLFxuICBcImFycmF5XCI6W10sXG4gIFwidWludDhfY2xhbXBlZFwiOltdLFxuICBcImJpZ2ludDY0XCI6IFtdLFxuICBcImJpZ3VpbnQ2NFwiOiBbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICBpZiAoZXJyb3JMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICB2YXIgZXJyb3JMaXN0ZW5lcjtcblxuICAgIC8vIEFkZGluZyBhbiBlcnJvciBsaXN0ZW5lciBpcyBub3Qgb3B0aW9uYWwgYmVjYXVzZVxuICAgIC8vIGlmIGFuIGVycm9yIGlzIHRocm93biBvbiBhbiBldmVudCBlbWl0dGVyIHdlIGNhbm5vdFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBhY3R1YWwgZXZlbnQgd2UgYXJlIHdhaXRpbmcgd2lsbFxuICAgIC8vIGJlIGZpcmVkLiBUaGUgcmVzdWx0IGNvdWxkIGJlIGEgc2lsZW50IHdheSB0byBjcmVhdGVcbiAgICAvLyBtZW1vcnkgb3IgZmlsZSBkZXNjcmlwdG9yIGxlYWtzLCB3aGljaCBpcyBzb21ldGhpbmdcbiAgICAvLyB3ZSBzaG91bGQgYXZvaWQuXG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IDAuMDAwMDAxXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IDBcbiAgICBvdXRbMV0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc3VidHJhY3RcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGl2aWRlXG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWREaXN0YW5jZVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZW5ndGhcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWRMZW5ndGhcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgcmV0dXJuIHgqeCArIHkqeVxufSIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IDBcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gMFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemU7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW5cbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlblxuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3VidHJhY3Q7XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGl2aWRlO1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsImNvbnN0IENWVXRpbHMgPSByZXF1aXJlKCcuLi9jb21tb24vY3ZfdXRpbHMnKTtcbmNvbnN0IE5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5Jyk7XG5jb25zdCBJbnRlcnAyRCA9IHJlcXVpcmUoJ25kYXJyYXktbGluZWFyLWludGVycG9sYXRlJykuZDI7XG5cbmNvbnN0IEZyYW1lR3JhYmJlciA9IHt9O1xuXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0U3RyZWFtKSB7XG4gICAgY29uc3QgX3RoYXQgPSB7fTtcbiAgICBjb25zdCBfdmlkZW9TaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKTtcbiAgICBjb25zdCBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKTtcbiAgICBjb25zdCBfc2l6ZSA9IENWVXRpbHMuaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpO1xuICAgIGNvbnN0IF90b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgbGV0IF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpO1xuICAgIGNvbnN0IF9ncmF5RGF0YSA9IG5ldyBVaW50OEFycmF5KF92aWRlb1NpemUueCAqIF92aWRlb1NpemUueSk7XG4gICAgY29uc3QgX2NhbnZhc0RhdGEgPSBuZXcgVWludDhBcnJheShfY2FudmFzU2l6ZS54ICogX2NhbnZhc1NpemUueSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgIGNvbnN0IF9ncmF5SW1hZ2VBcnJheSA9IE5kYXJyYXkoX2dyYXlEYXRhLCBbX3ZpZGVvU2l6ZS55LCBfdmlkZW9TaXplLnhdKS50cmFuc3Bvc2UoMSwgMCk7XG4gICAgY29uc3QgX2NhbnZhc0ltYWdlQXJyYXkgPSBOZGFycmF5KF9jYW52YXNEYXRhLCBbX2NhbnZhc1NpemUueSwgX2NhbnZhc1NpemUueF0pLnRyYW5zcG9zZSgxLCAwKTtcbiAgICBjb25zdCBfdGFyZ2V0SW1hZ2VBcnJheSA9IF9jYW52YXNJbWFnZUFycmF5XG4gICAgICAgIC5oaShfdG9wUmlnaHQueCArIF9zaXplLngsIF90b3BSaWdodC55ICsgX3NpemUueSlcbiAgICAgICAgLmxvKF90b3BSaWdodC54LCBfdG9wUmlnaHQueSk7XG4gICAgY29uc3QgX3N0ZXBTaXplWCA9IF92aWRlb1NpemUueCAvIF9jYW52YXNTaXplLng7XG4gICAgY29uc3QgX3N0ZXBTaXplWSA9IF92aWRlb1NpemUueSAvIF9jYW52YXNTaXplLnk7XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmFtZUdyYWJiZXInLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB2aWRlb1NpemU6IF9ncmF5SW1hZ2VBcnJheS5zaGFwZSxcbiAgICAgICAgICAgIGNhbnZhc1NpemU6IF9jYW52YXNJbWFnZUFycmF5LnNoYXBlLFxuICAgICAgICAgICAgc3RlcFNpemU6IFtfc3RlcFNpemVYLCBfc3RlcFNpemVZXSxcbiAgICAgICAgICAgIHNpemU6IF90YXJnZXRJbWFnZUFycmF5LnNoYXBlLFxuICAgICAgICAgICAgdG9wUmlnaHQ6IF90b3BSaWdodCxcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIGdpdmVuIGFycmF5IGFzIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCk7XG5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlQW5kQ3JvcChmcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIF90aGF0LnNjYWxlQW5kQ3JvcCA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgIC8vIDEuIGNvbXB1dGUgZnVsbC1zaXplZCBncmF5IGltYWdlXG4gICAgICAgIENWVXRpbHMuY29tcHV0ZUdyYXkoZnJhbWUuZGF0YSwgX2dyYXlEYXRhKTtcblxuICAgICAgICAvLyAyLiBpbnRlcnBvbGF0ZVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IF9jYW52YXNTaXplLnk7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBfY2FudmFzU2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgICAgIF9jYW52YXNJbWFnZUFycmF5LnNldCh4LCB5LCAoSW50ZXJwMkQoX2dyYXlJbWFnZUFycmF5LCB4ICogX3N0ZXBTaXplWCwgeSAqIF9zdGVwU2l6ZVkpKSB8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGFyZ2V0SW1hZ2VBcnJheSBtdXN0IGJlIGVxdWFsIHRvIHRhcmdldFNpemVcbiAgICAgICAgaWYgKF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzBdICE9PSBfc2l6ZS54XG4gICAgICAgICAgICB8fCBfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZVsxXSAhPT0gX3NpemUueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZXMgZG8gbm90IG1hdGNoIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gY3JvcFxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IF9zaXplLnk7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBfc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICBfZGF0YVt5ICogX3NpemUueCArIHhdID0gX3RhcmdldEltYWdlQXJyYXkuZ2V0KHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGF0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZUdyYWJiZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgYW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtUXVhdDogcmVxdWlyZSgnLi90cmFuc2Zvcm1RdWF0JylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxufVxuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwiaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5cbi8qKlxuICogaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vVGlwcy80MDcxNzIvQ29ubmVjdGVkLUNvbXBvbmVudC1MYWJlbGluZy1hbmQtVmVjdG9yaXphdGlvblxuICovXG5jb25zdCBSYXN0ZXJpemVyID0ge1xuICAgIGNyZWF0ZUNvbnRvdXIyRCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcjogbnVsbCxcbiAgICAgICAgICAgIGluZGV4OiBudWxsLFxuICAgICAgICAgICAgZmlyc3RWZXJ0ZXg6IG51bGwsXG4gICAgICAgICAgICBpbnNpZGVDb250b3VyczogbnVsbCxcbiAgICAgICAgICAgIG5leHRwZWVyOiBudWxsLFxuICAgICAgICAgICAgcHJldnBlZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBDT05UT1VSX0RJUjoge1xuICAgICAgICBDV19ESVI6IDAsXG4gICAgICAgIENDV19ESVI6IDEsXG4gICAgICAgIFVOS05PV05fRElSOiAyLFxuICAgIH0sXG4gICAgRElSOiB7XG4gICAgICAgIE9VVFNJREVfRURHRTogLTMyNzY3LFxuICAgICAgICBJTlNJREVfRURHRTogLTMyNzY2LFxuICAgIH0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgICAgICBjb25zdCB0cmFjZXIgPSBUcmFjZXIuY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFzdGVyaXplKGRlcHRobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3I7XG4gICAgICAgICAgICAgICAgbGV0IGJjO1xuICAgICAgICAgICAgICAgIGxldCBsYztcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICBsZXQgY3g7XG4gICAgICAgICAgICAgICAgbGV0IGN5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yTWFwID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleDtcbiAgICAgICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgICAgICBsZXQgY2M7XG4gICAgICAgICAgICAgICAgbGV0IHNjO1xuICAgICAgICAgICAgICAgIGxldCBwb3M7XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgaTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0MDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sb3JNYXBbMF0gPSBpbWFnZURhdGFbMF07XG4gICAgICAgICAgICAgICAgY2MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAoY3kgPSAxOyBjeSA8IGhlaWdodCAtIDE7IGN5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY3ggPSAxOyBjeCA8IHdpZHRoIC0gMTsgY3grKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gY3kgKiB3aWR0aCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBpbWFnZURhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT09IGJjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYyA9IGNvbm5lY3RlZENvdW50ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2xjXSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlci5jb250b3VyVHJhY2luZyhjeSwgY3gsIGxjLCBjb2xvciwgUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IGNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb250b3VyVHJhY2luZyhjeSwgY3gsIFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFLCBjb2xvciwgbGFiZWxpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhsYWJlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoc2MgIT09IG51bGwpICYmIHNjLmluZGV4ICE9PSBsYWJlbGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gc2MuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYy5pbnNpZGVDb250b3VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBpbWFnZURhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxhYmVsRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbbGFiZWxpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2MuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYyxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvbm5lY3RlZENvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgICAgICBkcmF3Q29udG91cihjYW52YXMsIGZpcnN0Q29udG91cikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBxID0gZmlyc3RDb250b3VyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcDtcblxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBpcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IGlxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHEgPSBwcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHEuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5VTktOT1dOX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBxLmZpcnN0VmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHAgIT09IHEuZmlyc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJhc3Rlcml6ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cbi8qIEBwcmVzZXJ2ZSBBU00gQkVHSU4gKi9cbmZ1bmN0aW9uIFNrZWxldG9uaXplcihzdGRsaWIsIGZvcmVpZ24sIGJ1ZmZlcikge1xuICAgICd1c2UgYXNtJztcblxuICAgIGNvbnN0IGltYWdlcyA9IG5ldyBzdGRsaWIuVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHNpemUgPSBmb3JlaWduLnNpemUgfCAwO1xuICAgIGNvbnN0IHsgaW11bCB9ID0gc3RkbGliLk1hdGg7XG5cbiAgICBmdW5jdGlvbiBlcm9kZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHYgPSAwO1xuICAgICAgICBsZXQgdSA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA9PSAoNSB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciB8PSAwO1xuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgLSAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIHwgKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIHN1bSA9ICgoc3VtIHwgMCkgKyAoaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHN1bSB8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG4gICAgICAgIHZhbHVlIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB2ID0gMDtcbiAgICAgICAgbGV0IHUgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVtY3B5KHNyY0ltYWdlUHRyLCBkc3RJbWFnZVB0cikge1xuICAgICAgICBzcmNJbWFnZVB0ciB8PSAwO1xuICAgICAgICBkc3RJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhkc3RJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IChpbWFnZXNbKHNyY0ltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvQm9yZGVyKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBsZXQgeSA9IDA7XG5cbiAgICAgICAgZm9yICh4ID0gMDsgKHggfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHgpIHwgMF0gPSAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICgoeSArIHNpemUpIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZWxldG9uaXplKCkge1xuICAgICAgICBjb25zdCBzdWJJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBlcm9kZWRJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCB0ZW1wSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgc2tlbEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gMDtcblxuICAgICAgICBlcm9kZWRJbWFnZVB0ciA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuICAgICAgICB0ZW1wSW1hZ2VQdHIgPSAoZXJvZGVkSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xuICAgICAgICBza2VsSW1hZ2VQdHIgPSAodGVtcEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcblxuICAgICAgICAvLyBpbml0IHNrZWwtaW1hZ2VcbiAgICAgICAgaW5pdChza2VsSW1hZ2VQdHIsIDApO1xuICAgICAgICB6ZXJvQm9yZGVyKHN1YkltYWdlUHRyKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlcm9kZShzdWJJbWFnZVB0ciwgZXJvZGVkSW1hZ2VQdHIpO1xuICAgICAgICAgICAgZGlsYXRlKGVyb2RlZEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgc3VidHJhY3Qoc3ViSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIGJpdHdpc2VPcihza2VsSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgc2tlbEltYWdlUHRyKTtcbiAgICAgICAgICAgIG1lbWNweShlcm9kZWRJbWFnZVB0ciwgc3ViSW1hZ2VQdHIpO1xuICAgICAgICAgICAgc3VtID0gY291bnROb25aZXJvKHN1YkltYWdlUHRyKSB8IDA7XG4gICAgICAgICAgICBkb25lID0gKChzdW0gfCAwKSA9PSAwIHwgMCk7XG4gICAgICAgIH0gd2hpbGUgKCFkb25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2tlbGV0b25pemUsXG4gICAgfTtcbn1cbi8qIEBwcmVzZXJ2ZSBBU00gRU5EICovXG5leHBvcnQgZGVmYXVsdCBTa2VsZXRvbml6ZXI7XG4vKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwYXRoICAgICAgICAgID0gcmVxdWlyZSgncGF0aCcpXG52YXIgbmRhcnJheSAgICAgICA9IHJlcXVpcmUoJ25kYXJyYXknKVxudmFyIEdpZlJlYWRlciAgICAgPSByZXF1aXJlKCdvbWdnaWYnKS5HaWZSZWFkZXJcbnZhciBwYWNrICAgICAgICAgID0gcmVxdWlyZSgnbmRhcnJheS1wYWNrJylcbnZhciB0aHJvdWdoICAgICAgID0gcmVxdWlyZSgndGhyb3VnaCcpXG52YXIgcGFyc2VEYXRhVVJJICA9IHJlcXVpcmUoJ2RhdGEtdXJpLXRvLWJ1ZmZlcicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRJbWFnZSh1cmwsIGNiKSB7XG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKVxuICBpbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiXG4gIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodFxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApXG4gICAgdmFyIHBpeGVscyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodClcbiAgICBjYihudWxsLCBuZGFycmF5KG5ldyBVaW50OEFycmF5KHBpeGVscy5kYXRhKSwgW2ltZy53aWR0aCwgaW1nLmhlaWdodCwgNF0sIFs0LCA0KmltZy53aWR0aCwgMV0sIDApKVxuICB9XG4gIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgY2IoZXJyKVxuICB9XG4gIGltZy5zcmMgPSB1cmxcbn1cblxuLy9BbmltYXRlZCBnaWYgbG9hZGluZ1xuZnVuY3Rpb24gaGFuZGxlR2lmKGRhdGEsIGNiKSB7XG4gIHZhciByZWFkZXJcbiAgdHJ5IHtcbiAgICByZWFkZXIgPSBuZXcgR2lmUmVhZGVyKGRhdGEpXG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgY2IoZXJyKVxuICAgIHJldHVyblxuICB9XG4gIGlmKHJlYWRlci5udW1GcmFtZXMoKSA+IDApIHtcbiAgICB2YXIgbnNoYXBlID0gW3JlYWRlci5udW1GcmFtZXMoKSwgcmVhZGVyLmhlaWdodCwgcmVhZGVyLndpZHRoLCA0XVxuICAgIHZhciBuZGF0YSA9IG5ldyBVaW50OEFycmF5KG5zaGFwZVswXSAqIG5zaGFwZVsxXSAqIG5zaGFwZVsyXSAqIG5zaGFwZVszXSlcbiAgICB2YXIgcmVzdWx0ID0gbmRhcnJheShuZGF0YSwgbnNoYXBlKVxuICAgIHRyeSB7XG4gICAgICBmb3IodmFyIGk9MDsgaTxyZWFkZXIubnVtRnJhbWVzKCk7ICsraSkge1xuICAgICAgICByZWFkZXIuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQShpLCBuZGF0YS5zdWJhcnJheShcbiAgICAgICAgICByZXN1bHQuaW5kZXgoaSwgMCwgMCwgMCksXG4gICAgICAgICAgcmVzdWx0LmluZGV4KGkrMSwgMCwgMCwgMCkpKVxuICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2IobnVsbCwgcmVzdWx0LnRyYW5zcG9zZSgwLDIsMSkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5zaGFwZSA9IFtyZWFkZXIuaGVpZ2h0LCByZWFkZXIud2lkdGgsIDRdXG4gICAgdmFyIG5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobnNoYXBlWzBdICogbnNoYXBlWzFdICogbnNoYXBlWzJdKVxuICAgIHZhciByZXN1bHQgPSBuZGFycmF5KG5kYXRhLCBuc2hhcGUpXG4gICAgdHJ5IHtcbiAgICAgIHJlYWRlci5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKDAsIG5kYXRhKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2IobnVsbCwgcmVzdWx0LnRyYW5zcG9zZSgxLDApKVxuICB9XG59XG5cbmZ1bmN0aW9uIGh0dHBHaWYodXJsLCBjYikge1xuICB2YXIgeGhyICAgICAgICAgID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSlcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgaWYoeGhyLm92ZXJyaWRlTWltZVR5cGUpe1xuICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi9iaW5hcnknKVxuICB9XG4gIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgY2IoZXJyKVxuICB9XG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZih4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKVxuICAgIGhhbmRsZUdpZihkYXRhLCBjYilcbiAgICByZXR1cm5cbiAgfVxuICB4aHIuc2VuZCgpXG59XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKGJ1ZmZlclswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG4gPSBidWZmZXIubGVuZ3RoXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICByZXN1bHRbaV0gPSBidWZmZXIuZ2V0KGkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGFHaWYodXJsLCBjYikge1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnVmZmVyID0gcGFyc2VEYXRhVVJJKHVybClcbiAgICAgIGlmKGJ1ZmZlcikge1xuICAgICAgICBoYW5kbGVHaWYoY29weUJ1ZmZlcihidWZmZXIpLCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG5ldyBFcnJvcignRXJyb3IgcGFyc2luZyBkYXRhIFVSSScpKVxuICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBpeGVscyh1cmwsIHR5cGUsIGNiKSB7XG4gIGlmKCFjYikge1xuICAgIGNiID0gdHlwZVxuICAgIHR5cGUgPSAnJ1xuICB9XG4gIHZhciBleHQgPSBwYXRoLmV4dG5hbWUodXJsKVxuICBzd2l0Y2godHlwZSB8fCBleHQudG9VcHBlckNhc2UoKSkge1xuICAgIGNhc2UgJy5HSUYnOlxuICAgICAgaHR0cEdpZih1cmwsIGNiKVxuICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcih1cmwpKSB7XG4gICAgICAgIHVybCA9ICdkYXRhOicgKyB0eXBlICsgJztiYXNlNjQsJyArIHVybC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIH1cbiAgICAgIGlmKHVybC5pbmRleE9mKCdkYXRhOmltYWdlL2dpZjsnKSA9PT0gMCkge1xuICAgICAgICBkYXRhR2lmKHVybCwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0SW1hZ2UodXJsLCBjYilcbiAgICAgIH1cbiAgfVxufSIsIi8qXG4gKiB0eXBlZGVmcy5qc1xuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzIGFuZCBwcm92aWRlIHNvbWUgYmFzaWMgcG9seWZpbGxzXG4gKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgTWF0aC5pbXVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYWwgPSBhICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJsID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxuICAgICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuXG4ndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH07XG59XG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlc1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZFxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1pblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXhcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIHZlYzIgYnkgYW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBhbmdsZSkge1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSlcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV1cblxuICBvdXRbMF0gPSB4ICogYyAtIHkgKiBzXG4gIG91dFsxXSA9IHggKiBzICsgeSAqIGNcblxuICByZXR1cm4gb3V0XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnlcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXVxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3NcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxuICAgIG91dFswXSA9IG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycFxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb21cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MmRcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0M1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGxcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICAgIHN0cmlkZSA9IDJcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IDBcbiAgICB9XG4gICAgXG4gICAgaWYoY291bnQpIHtcbiAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBhLmxlbmd0aFxuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgdmVjWzBdID0gYVtpXVxuICAgICAgICB2ZWNbMV0gPSBhW2krMV1cbiAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgYVtpXSA9IHZlY1swXVxuICAgICAgICBhW2krMV0gPSB2ZWNbMV1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxpbWl0O1xuXG4vKipcbiAqIExpbWl0IHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIHZhbHVlIHVzZWQgZm9yIHRoZSBgbWF4YFxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSAge3ZlYzJ9IHRoZSB2ZWN0b3IgdG8gbGltaXRcbiAqIEBwYXJhbSAge051bWJlcn0gbWF4IHRoZSBtYXhpbXVtIG1hZ25pdHVkZSBmb3IgdGhlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsaW1pdChvdXQsIGEsIG1heCkge1xuICB2YXIgbVNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcblxuICBpZiAobVNxID4gbWF4ICogbWF4KSB7XG4gICAgdmFyIG4gPSBNYXRoLnNxcnQobVNxKTtcbiAgICBvdXRbMF0gPSBhWzBdIC8gbiAqIG1heDtcbiAgICBvdXRbMV0gPSBhWzFdIC8gbiAqIG1heDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ2xlXG5cbnZhciBmcm9tVmFsdWVzID0gcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG52YXIgZG90ID0gcmVxdWlyZSgnLi9kb3QnKVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgdmFyIHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKVxuICAgIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSlcbiBcbiAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKVxuICAgIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpXG4gXG4gICAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpXG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKVxuICAgIH0gICAgIFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICB2YXIgYjIgPSBiWzJdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgb3V0WzJdID0gYVsyXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgb3V0WzJdID0gLWFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICBvdXRbMl0gPSAxLjAgLyBhWzJdXG4gIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdXG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieVxuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYnhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcblxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMi4wKSAtIDEuMFxuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZVxuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxuICAgIG91dFsyXSA9IHogKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDM7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXVxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XVxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XVxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVF1YXQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeVxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXpcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieSA9IGJbMV1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICAgIHZhciBweiA9IGFbMl0gLSBielxuXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYnkgKyBweSAqIGNjIC0gcHogKiBzY1xuICAgIG91dFsyXSA9IGJ6ICsgcHkgKiBzYyArIHB6ICogY2NcblxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweiA9IGFbMl0gLSBielxuICAgIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcbiAgXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB6ICogc2MgKyBweCAqIGNjXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGJ6ICsgcHogKiBjYyAtIHB4ICogc2NcbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieSA9IGJbMV1cblxuICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB4ICogY2MgLSBweSAqIHNjXG4gICAgb3V0WzFdID0gYnkgKyBweCAqIHNjICsgcHkgKiBjY1xuICAgIG91dFsyXSA9IGFbMl1cbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGxcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gM1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldIFxuICAgICAgICAgICAgdmVjWzFdID0gYVtpKzFdIFxuICAgICAgICAgICAgdmVjWzJdID0gYVtpKzJdXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXSBcbiAgICAgICAgICAgIGFbaSsxXSA9IHZlY1sxXSBcbiAgICAgICAgICAgIGFbaSsyXSA9IHZlY1syXVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYVxufSIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5kZXRlcm1pbmFudFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIudHJhbnNwb3NlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhMVxuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYVsxXVxuICAgIG91dFszXSA9IGFbM11cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAYWxpYXMgbWF0Mi5tdWx0aXBseVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdXG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxXG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxXG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzXG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHlcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pZGVudGl0eVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGpvaW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuYWRqb2ludFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9ICBhWzBdXG4gIG91dFswXSA9ICBhWzNdXG4gIG91dFsxXSA9IC1hWzFdXG4gIG91dFsyXSA9IC1hWzJdXG4gIG91dFszXSA9ICBhMFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQGFsaWFzIG1hdDIucm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgcyA9IE1hdGguc2luKHJhZClcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpXG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHNcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogc1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjXG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmludmVydFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBhMyA9IGFbM11cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9ICBhMyAqIGRldFxuICBvdXRbMV0gPSAtYTEgKiBkZXRcbiAgb3V0WzJdID0gLWEyICogZGV0XG4gIG91dFszXSA9ICBhMCAqIGRldFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBhbGlhcyBtYXQyLnNjYWxlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHYwID0gdlswXSwgdjEgPSB2WzFdXG4gIG91dFswXSA9IGEwICogdjBcbiAgb3V0WzFdID0gYTEgKiB2MFxuICBvdXRbMl0gPSBhMiAqIHYxXG4gIG91dFszXSA9IGEzICogdjFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBhbGlhcyBtYXQyLmNvcHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXVxuICBvdXRbMV0gPSBhWzFdXG4gIG91dFsyXSA9IGFbMl1cbiAgb3V0WzNdID0gYVszXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb2JcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmZyb2JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coYVswXSwgMikgK1xuICAgIE1hdGgucG93KGFbMV0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzJdLCAyKSArXG4gICAgTWF0aC5wb3coYVszXSwgMilcbiAgKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBsZHVcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIubGR1XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cbmZ1bmN0aW9uIGxkdShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF1cbiAgVVswXSA9IGFbMF1cbiAgVVsxXSA9IGFbMV1cbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXVxuICByZXR1cm4gW0wsIEQsIFVdXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gaW90YShuKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gaVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpb3RhIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIG5kYXJyYXkgPSByZXF1aXJlKFwibmRhcnJheVwiKVxudmFyIGRvX2NvbnZlcnQgPSByZXF1aXJlKFwiLi9kb0NvbnZlcnQuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb252ZXJ0KGFyciwgcmVzdWx0KSB7XG4gIHZhciBzaGFwZSA9IFtdLCBjID0gYXJyLCBzeiA9IDFcbiAgd2hpbGUoQXJyYXkuaXNBcnJheShjKSkge1xuICAgIHNoYXBlLnB1c2goYy5sZW5ndGgpXG4gICAgc3ogKj0gYy5sZW5ndGhcbiAgICBjID0gY1swXVxuICB9XG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZGFycmF5KClcbiAgfVxuICBpZighcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gbmRhcnJheShuZXcgRmxvYXQ2NEFycmF5KHN6KSwgc2hhcGUpXG4gIH1cbiAgZG9fY29udmVydChyZXN1bHQsIGFycilcbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgnY3dpc2UtY29tcGlsZXInKSh7XCJhcmdzXCI6W1wiYXJyYXlcIixcInNjYWxhclwiLFwiaW5kZXhcIl0sXCJwcmVcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImJvZHlcIjp7XCJib2R5XCI6XCJ7XFxudmFyIF9pbmxpbmVfMV92PV9pbmxpbmVfMV9hcmcxXyxfaW5saW5lXzFfaVxcbmZvcihfaW5saW5lXzFfaT0wO19pbmxpbmVfMV9pPF9pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMTsrK19pbmxpbmVfMV9pKSB7XFxuX2lubGluZV8xX3Y9X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9pXV1cXG59XFxuX2lubGluZV8xX2FyZzBfPV9pbmxpbmVfMV92W19pbmxpbmVfMV9hcmcyX1tfaW5saW5lXzFfYXJnMl8ubGVuZ3RoLTFdXVxcbn1cIixcImFyZ3NcIjpbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjp0cnVlLFwicnZhbHVlXCI6ZmFsc2UsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcxX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoxfSx7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMl9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6NH1dLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltcIl9pbmxpbmVfMV9pXCIsXCJfaW5saW5lXzFfdlwiXX0sXCJwb3N0XCI6e1wiYm9keVwiOlwie31cIixcImFyZ3NcIjpbXSxcInRoaXNWYXJzXCI6W10sXCJsb2NhbFZhcnNcIjpbXX0sXCJmdW5jTmFtZVwiOlwiY29udmVydFwiLFwiYmxvY2tTaXplXCI6NjR9KVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNyZWF0ZVRodW5rID0gcmVxdWlyZShcIi4vbGliL3RodW5rLmpzXCIpXG5cbmZ1bmN0aW9uIFByb2NlZHVyZSgpIHtcbiAgdGhpcy5hcmdUeXBlcyA9IFtdXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QXJncyA9IFtdXG4gIHRoaXMuYXJyYXlCbG9ja0luZGljZXMgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3NcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIiB8fCAodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLmJsb2NrSW5kaWNlcykpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcImFycmF5XCJcbiAgICAgIHByb2MuYXJyYXlBcmdzLnB1c2goaSlcbiAgICAgIHByb2MuYXJyYXlCbG9ja0luZGljZXMucHVzaChhcmdfdHlwZS5ibG9ja0luZGljZXMgPyBhcmdfdHlwZS5ibG9ja0luZGljZXMgOiAwKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyBUaGUgZnVuY3Rpb24gYmVsb3cgaXMgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGEgY3dpc2UgZnVuY3Rpb24gb2JqZWN0LCBhbmQgZG9lcyB0aGUgZm9sbG93aW5nOlxuLy8gQSBmdW5jdGlvbiBvYmplY3QgaXMgY29uc3RydWN0ZWQgd2hpY2ggYWNjZXB0cyBhcyBhcmd1bWVudCBhIGNvbXBpbGF0aW9uIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24uXG4vLyBJdCBpcyB0aGlzIG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgZXZlbnR1YWxseSByZXR1cm5lZCBieSBjcmVhdGVUaHVuaywgYW5kIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9uZSB0aGF0IGFjdHVhbGx5XG4vLyBjaGVja3Mgd2hldGhlciBhIGNlcnRhaW4gcGF0dGVybiBvZiBhcmd1bWVudHMgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBhbmQgY29tcGlsZXMgbmV3IGxvb3BzIGFzIG5lZWRlZC5cbi8vIFRoZSBjb21waWxhdGlvbiBwYXNzZWQgdG8gdGhlIGZpcnN0IGZ1bmN0aW9uIG9iamVjdCBpcyB1c2VkIGZvciBjb21waWxpbmcgbmV3IGZ1bmN0aW9ucy5cbi8vIE9uY2UgdGhpcyBmdW5jdGlvbiBvYmplY3QgaXMgY3JlYXRlZCwgaXQgaXMgY2FsbGVkIHdpdGggY29tcGlsZSBhcyBhcmd1bWVudCwgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIGNvbXBpbGVcbi8vIGlzIGJvdW5kIHRvIFwicHJvY1wiIChlc3NlbnRpYWxseSBjb250YWluaW5nIGEgcHJlcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHVzZXIgYXJndW1lbnRzIHRvIGN3aXNlKS5cbi8vIFNvIGNyZWF0ZVRodW5rIHJvdWdobHkgd29ya3MgbGlrZSB0aGlzOlxuLy8gZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuLy8gICB2YXIgdGh1bmsgPSBmdW5jdGlvbihjb21waWxlQm91bmQpIHtcbi8vICAgICB2YXIgQ0FDSEVEID0ge31cbi8vICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXlzIGFuZCBzY2FsYXJzKSB7XG4vLyAgICAgICBpZiAoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cyBpbiBDQUNIRUQpIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c11cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdID0gY29tcGlsZUJvdW5kKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMpXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gZnVuYyhhcnJheXMgYW5kIHNjYWxhcnMpXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQxKHByb2MpKVxuLy8gfVxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUuanNcIilcblxuZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiLCBcInZhciBDQUNIRUQ9e31cIl1cbiAgdmFyIHZhcnMgPSBbXVxuICB2YXIgdGh1bmtOYW1lID0gcHJvYy5mdW5jTmFtZSArIFwiX2N3aXNlX3RodW5rXCJcbiAgXG4gIC8vQnVpbGQgdGh1bmtcbiAgY29kZS5wdXNoKFtcInJldHVybiBmdW5jdGlvbiBcIiwgdGh1bmtOYW1lLCBcIihcIiwgcHJvYy5zaGltQXJncy5qb2luKFwiLFwiKSwgXCIpe1wiXS5qb2luKFwiXCIpKVxuICB2YXIgdHlwZXNpZyA9IFtdXG4gIHZhciBzdHJpbmdfdHlwZXNpZyA9IFtdXG4gIHZhciBwcm9jX2FyZ3MgPSBbW1wiYXJyYXlcIixwcm9jLmFycmF5QXJnc1swXSxcIi5zaGFwZS5zbGljZShcIiwgLy8gU2xpY2Ugc2hhcGUgc28gdGhhdCB3ZSBvbmx5IHJldGFpbiB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlICh3aGljaCBnZXRzIHBhc3NlZCB0byB0aGUgY3dpc2Ugb3BlcmF0b3IgYXMgU1MpLlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF08MD8oXCIsXCIrcHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXStcIilcIik6XCIpXCJdLmpvaW4oXCJcIildXG4gIHZhciBzaGFwZUxlbmd0aENvbmRpdGlvbnMgPSBbXSwgc2hhcGVDb25kaXRpb25zID0gW11cbiAgLy8gUHJvY2VzcyBhcnJheSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgICBpZiAoaT4wKSB7IC8vIEdhdGhlciBjb25kaXRpb25zIHRvIGNoZWNrIGZvciBzaGFwZSBlcXVhbGl0eSAoaWdub3JpbmcgYmxvY2sgaW5kaWNlcylcbiAgICAgIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZS5sZW5ndGgrXCIgKyAoTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSktTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkpKVxuICAgICAgc2hhcGVDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiXT09PWFycmF5XCIgKyBqICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgKyBcIl1cIilcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5XG4gIGlmIChwcm9jLmFycmF5QXJncy5sZW5ndGggPiAxKSB7XG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUxlbmd0aENvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uYWxpdHkhJylcIilcbiAgICBjb2RlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoLVwiICsgTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIjsgc2hhcGVJbmRleC0tPjA7KSB7XCIpXG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUNvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUhJylcIilcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgLy8gUHJvY2VzcyBzY2FsYXIgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIHByb2NfYXJncy5wdXNoKFwic2NhbGFyXCIgKyBwcm9jLnNjYWxhckFyZ3NbaV0pXG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNhY2hlZCBmdW5jdGlvbiAoYW5kIGlmIG5vdCBwcmVzZW50LCBnZW5lcmF0ZSBpdClcbiAgdmFycy5wdXNoKFtcInR5cGU9W1wiLCBzdHJpbmdfdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKVxuICB2YXJzLnB1c2goXCJwcm9jPUNBQ0hFRFt0eXBlXVwiKVxuICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICBcbiAgY29kZS5wdXNoKFtcImlmKCFwcm9jKXtcIixcbiAgICAgICAgICAgICBcIkNBQ0hFRFt0eXBlXT1wcm9jPWNvbXBpbGUoW1wiLCB0eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0pfVwiLFxuICAgICAgICAgICAgIFwicmV0dXJuIHByb2MoXCIsIHByb2NfYXJncy5qb2luKFwiLFwiKSwgXCIpfVwiXS5qb2luKFwiXCIpKVxuXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHZlcnkgc2ltcGxlIGxvb3BzIGFuYWxvZ291cyB0byBob3cgeW91IHR5cGljYWxseSB0cmF2ZXJzZSBhcnJheXMgKHRoZSBvdXRlcm1vc3QgbG9vcCBjb3JyZXNwb25kcyB0byB0aGUgc2xvd2VzdCBjaGFuZ2luZyBpbmRleCwgdGhlIGlubmVybW9zdCBsb29wIHRvIHRoZSBmYXN0ZXN0IGNoYW5naW5nIGluZGV4KVxuLy8gVE9ETzogSWYgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIHN0cmlkZXMgKGFuZCBvZmZzZXRzKSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGRlY3JlYXNpbmcgdGhlIG51bWJlciBvZiBcInBvaW50ZXJzXCIgYW5kIHJlbGF0ZWQgdmFyaWFibGVzLiBUaGUgZHJhd2JhY2sgaXMgdGhhdCB0aGUgdHlwZSBzaWduYXR1cmUgd291bGQgYmVjb21lIG1vcmUgc3BlY2lmaWMgYW5kIHRoYXQgdGhlcmUgd291bGQgdGh1cyBiZSBsZXNzIHBvdGVudGlhbCBmb3IgY2FjaGluZywgYnV0IGl0IG1pZ2h0IHN0aWxsIGJlIHdvcnRoIGl0LCBlc3BlY2lhbGx5IHdoZW4gZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMgb2YgYXJndW1lbnRzLlxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkgeyAvLyBJdGVyYXRpb24gdmFyaWFibGVzXG4gICAgdmFycy5wdXNoKFtcImlcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL0NvbXB1dGUgc2NhbiBkZWx0YXNcbiAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgcGlkeCA9IGlkeFxuICAgICAgaWR4ID0gb3JkZXJbaV1cbiAgICAgIGlmKGkgPT09IDApIHsgLy8gVGhlIGlubmVybW9zdC9mYXN0ZXN0IGRpbWVuc2lvbidzIGRlbHRhIGlzIHNpbXBseSBpdHMgc3RyaWRlXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7IC8vIEZvciBvdGhlciBkaW1lbnNpb25zIHRoZSBkZWx0YSBpcyBiYXNpY2FsbHkgdGhlIHN0cmlkZSBtaW51cyBzb21ldGhpbmcgd2hpY2ggZXNzZW50aWFsbHkgXCJyZXdpbmRzXCIgdGhlIHByZXZpb3VzIChtb3JlIGlubmVyKSBkaW1lbnNpb25cbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9KHRcIixqLFwicFwiLGlkeCxcIi1zXCIscGlkeCxcIip0XCIsaixcInBcIixwaWR4LFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfSAgXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHsgLy8gU3RhcnQgYXQgbGFyZ2VzdCBzdHJpZGUgYW5kIHdvcmsgeW91ciB3YXkgaW53YXJkc1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vIEdlbmVyYXRlIFwib3V0ZXJcIiBsb29wcyB0aGF0IGxvb3Agb3ZlciBibG9ja3Mgb2YgZGF0YSwgYXBwbHlpbmcgXCJpbm5lclwiIGxvb3BzIHRvIHRoZSBibG9ja3MgYnkgbWFuaXB1bGF0aW5nIHRoZSBsb2NhbCB2YXJpYWJsZXMgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbm5lciBsb29wIG9ubHkgXCJzZWVzXCIgdGhlIGN1cnJlbnQgYmxvY2suXG4vLyBUT0RPOiBJZiB0aGlzIGlzIHVzZWQsIHRoZW4gdGhlIHByZXZpb3VzIGRlY2xhcmF0aW9uIChkb25lIGJ5IGdlbmVyYXRlQ3dpc2VPcCkgb2YgcyogaXMgZXNzZW50aWFsbHkgdW5uZWNlc3NhcnkuXG4vLyAgICAgICBJIGJlbGlldmUgdGhlIHMqIGFyZSBub3QgdXNlZCBlbHNld2hlcmUgKGluIHBhcnRpY3VsYXIsIEkgZG9uJ3QgdGhpbmsgdGhleSdyZSB1c2VkIGluIHRoZSBwcmUvcG9zdCBwYXJ0cyBhbmQgXCJzaGFwZVwiIGlzIGRlZmluZWQgaW5kZXBlbmRlbnRseSksIHNvIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2UgZGVmaW5pbmcgdGhlIHMqIGRlcGVuZGVudCBvbiB3aGF0IGxvb3AgbWV0aG9kIGlzIGJlaW5nIHVzZWQuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIGxvb3BzIGZvciB1bm1hdGNoZWQgZGltZW5zaW9uc1xuICAvLyBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgZGltZW5zaW9ucyBhcmUgdHJhdmVyc2VkIGlzIGZhaXJseSBhcmJpdHJhcnkgKGZyb20gc21hbGwgc3RyaWRlIHRvIGxhcmdlIHN0cmlkZSwgZm9yIHRoZSBmaXJzdCBhcmd1bWVudClcbiAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSBpZiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgbG9vcHMgYXJlIHBsYWNlZCB3b3VsZCBhbHNvIGJlIHNvbWVob3cgXCJvcHRpbWFsXCIgKGF0IHRoZSB2ZXJ5IGxlYXN0IHdlIHNob3VsZCBjaGVjayB0aGF0IGl0IHJlYWxseSBkb2Vzbid0IGh1cnQgdXMgaWYgdGhleSdyZSBub3QpLlxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpIC8vIEl0ZXJhdGUgYmFjayB0byBmcm9udFxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKSAvLyBFaXRoZXIgZGVjcmVhc2UgaiBieSBibG9ja1NpemUgKHMgPSBibG9ja1NpemUpLCBvciBzZXQgaXQgdG8gemVybyAoYWZ0ZXIgc2V0dGluZyBzID0gaikuXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG4vLyBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHByZWZpeCBvZiB0aGUgYXJyYXlzIGluIG9yZGVycy5cbi8vIEVhY2ggYXJyYXkgaW4gb3JkZXJzIGxpc3RzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb3JyZXNwb25kIG5kYXJyYXkgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBzdHJpZGUuXG4vLyBUaGlzIGlzIHRodXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhhdCBjYW4gYmUgZWZmaWNpZW50bHkgdHJhdmVyc2VkIGJ5IHNpbXBsZSBuZXN0ZWQgbG9vcHMgZm9yIGFsbCBhcnJheXMuXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuLy8gUmVwbGFjZXMgdmFyaWFibGUgbmFtZXMgYnkgZGlmZmVyZW50IG9uZXMsIGVpdGhlciBcImxvY2FsXCIgb25lcyAodGhhdCBhcmUgdGhlbiBmZXJyaWVkIGluIGFuZCBvdXQgb2YgdGhlIGdpdmVuIGFycmF5KSBvciBvbmVzIG1hdGNoaW5nIHRoZSBhcmd1bWVudHMgdGhhdCB0aGUgZnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgdWx0aW1hdGUgbG9vcCB3aWxsIGFjY2VwdC5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXggLy8gQWRkcyBvZmZzZXQgdG8gdGhlIFwicG9pbnRlclwiIGluIHRoZSBhcnJheVxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSA9PT0gMCkgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGp1c3QgYSBzaW5nbGUgdmFsdWUgZnJvbSB0aGlzIGFycmF5XG4gICAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkgeyAvLyBBcmd1bWVudC9hcnJheSB1c2VkIG9ubHkgb25jZSg/KVxuICAgICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMgYSBcImJsb2NrXCJcbiAgICAgICAgICB2YXIgcmVTdHJBcnIgPSBbY2FyZy5uYW1lXSwgcHRyU3RyQXJyID0gW3B0clN0cl1cbiAgICAgICAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0pOyBqKyspIHtcbiAgICAgICAgICAgIHJlU3RyQXJyLnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIilcbiAgICAgICAgICAgIHB0clN0ckFyci5wdXNoKFwiJFwiICsgKGorMSkgKyBcIip0XCIgKyBhcnJOdW0gKyBcImJcIiArIGopIC8vIE1hdGNoZWQgaW5kZXggdGltZXMgc3RyaWRlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZVN0ckFyci5qb2luKFwiXCIpLCBcImdcIilcbiAgICAgICAgICBwdHJTdHIgPSBwdHJTdHJBcnIuam9pbihcIitcIilcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIC8qaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBHZW5lcmljIGFycmF5cyBub3Qgc3VwcG9ydGVkIGluIGNvbWJpbmF0aW9uIHdpdGggYmxvY2tzIVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHByb2R1Y2UgYW55IGxvY2FsIHZhcmlhYmxlcywgZXZlbiBpZiB2YXJpYWJsZXMgYXJlIHVzZWQgbXVsdGlwbGUgdGltZXMuIEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGRvIHNvLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZSB0aGluZ3MgcXVpdGUgYSBiaXQuXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgLy8gQXJyYXlzIGdldCBwdXQgZmlyc3QgaW4gdHlwZXNpZywgYW5kIHRoZXJlIGFyZSB0d28gZW50cmllcyBwZXIgYXJyYXkgKGR0eXBlIGFuZCBvcmRlciksIHNvIHRoaXMgZ2V0cyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gdGhlIGZpcnN0IGFycmF5IGFyZy5cbiAgdmFyIGRpbWVuc2lvbiA9ICh0eXBlc2lnWzFdLmxlbmd0aCAtIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pKXwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICB9XG4gIFxuICAvL0RldGVybWluZSB3aGVyZSBibG9jayBhbmQgbG9vcCBpbmRpY2VzIHN0YXJ0IGFuZCBlbmRcbiAgdmFyIGJsb2NrQmVnaW4gPSBbXSwgYmxvY2tFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBleHBvc2VkIGFzIGJsb2Nrc1xuICB2YXIgbG9vcEJlZ2luID0gW10sIGxvb3BFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBpdGVyYXRlZCBvdmVyXG4gIHZhciBsb29wT3JkZXJzID0gW10gLy8gb3JkZXJzIHJlc3RyaWN0ZWQgdG8gdGhlIGxvb3AgaW5kaWNlc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldPDApIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKDApXG4gICAgICBsb29wRW5kLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrRW5kLnB1c2goZGltZW5zaW9uK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pIC8vIE5vbi1uZWdhdGl2ZVxuICAgICAgbG9vcEVuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0rZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKDApXG4gICAgICBibG9ja0VuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfVxuICAgIHZhciBuZXdPcmRlciA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b3JkZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobG9vcEJlZ2luW2ldPD1vcmRlcnNbaV1bal0gJiYgb3JkZXJzW2ldW2pdPGxvb3BFbmRbaV0pIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChvcmRlcnNbaV1bal0tbG9vcEJlZ2luW2ldKSAvLyBJZiB0aGlzIGlzIGEgbG9vcCBpbmRleCwgcHV0IGl0IGluIG5ld09yZGVyLCBzdWJ0cmFjdGluZyBsb29wQmVnaW4sIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBsb29wT3JkZXJzIGFyZSB1c2luZyBhIGNvbW1vbiBzZXQgb2YgaW5kaWNlcy5cbiAgICAgIH1cbiAgICB9XG4gICAgbG9vcE9yZGVycy5wdXNoKG5ld09yZGVyKVxuICB9XG5cbiAgLy9GaXJzdCBjcmVhdGUgYXJndW1lbnRzIGZvciBwcm9jZWR1cmVcbiAgdmFyIGFyZ2xpc3QgPSBbXCJTU1wiXSAvLyBTUyBpcyB0aGUgb3ZlcmFsbCBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGVcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRoZSBsaW1pdHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpIC8vIEFjdHVhbCBkYXRhIGFycmF5XG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpIC8vIFN0cmlkZXNcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSkgLy8gT2Zmc2V0IGluIHRoZSBhcnJheSBhdCB3aGljaCB0aGUgZGF0YSBzdGFydHMgKGFsc28gdXNlZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIGRhdGEpXG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgbG9vcGluZ1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsbG9vcEJlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgYmxvY2sgaXRlcmF0aW9uXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJiXCIsaixcIj10XCIsaSxcIltcIixibG9ja0JlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXG4gIH1cbiAgaWYocHJvYy5zaGFwZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpIC8vIE1ha2VzIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgYXZhaWxhYmxlIHRvIHRoZSB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIChzbyB5b3UgY2FuIHVzZSB3aWR0aC9oZWlnaHQgZm9yIGV4YW1wbGUpXG4gIH1cbiAgaWYocHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFByZXBhcmUgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgKGxvZ2ljYWwpIGluZGljZXMsIGluaXRpYWxpemVkIHRvIGRpbWVuc2lvbiB6ZXJvZXMuXG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7IC8vIE9mZnNldCBhcmd1bWVudHMgdXNlZCBmb3Igc3RlbmNpbCBvcGVyYXRpb25zXG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKGxvb3BPcmRlcnMpXG4gIGlmKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBjb2RlLnB1c2gob3V0ZXJGaWxsKG1hdGNoZWQsIGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKSAvLyBUT0RPOiBSYXRoZXIgdGhhbiBwYXNzaW5nIGxvb3BPcmRlcnNbMF0sIGl0IG1pZ2h0IGJlIGludGVyZXN0aW5nIHRvIGxvb2sgYXQgcGFzc2luZyBhbiBvcmRlciB0aGF0IHJlcHJlc2VudHMgdGhlIG1ham9yaXR5IG9mIHRoZSBhcmd1bWVudHMgZm9yIGV4YW1wbGUuXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGlubmVyRmlsbChsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIGN3aXNlIHJvdXRpbmUgZm9yIFwiLCB0eXBlc2lnLCBcIjpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICB2YXIgbG9vcE5hbWUgPSBbKHByb2MuZnVuY05hbWV8fFwidW5uYW1lZFwiKSwgXCJfY3dpc2VfbG9vcF9cIiwgb3JkZXJzWzBdLmpvaW4oXCJzXCIpLFwibVwiLG1hdGNoZWQsdHlwZVN1bW1hcnkoZHR5cGVzKV0uam9pbihcIlwiKVxuICB2YXIgZiA9IG5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixsb29wTmFtZSxcIihcIiwgYXJnbGlzdC5qb2luKFwiLFwiKSxcIil7XCIsIGNvZGUuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLCBsb29wTmFtZV0uam9pbihcIlwiKSlcbiAgcmV0dXJuIGYoKVxufVxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNXaXNlT3BcbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICBpZihjb21wYXJlKSB7XG4gICAgaWYoIXNvcnRlZCkge1xuICAgICAgbGlzdC5zb3J0KGNvbXBhcmUpXG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKVxuICB9XG4gIGlmKCFzb3J0ZWQpIHtcbiAgICBsaXN0LnNvcnQoKVxuICB9XG4gIHJldHVybiB1bmlxdWVfZXEobGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIvKiAoaWdub3JlZCkgKi8iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkYXRhVXJpVG9CdWZmZXI7XG5cbi8qKlxuICogUmV0dXJucyBhIGBCdWZmZXJgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgVVJJIGB1cmlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgRGF0YSBVUkkgdG8gdHVybiBpbnRvIGEgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IEJ1ZmZlciBpbnN0YW5jZSBmcm9tIERhdGEgVVJJXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRhdGFVcmlUb0J1ZmZlciAodXJpKSB7XG4gIGlmICghL15kYXRhXFw6L2kudGVzdCh1cmkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHVyaWAgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgRGF0YSBVUkkgKG11c3QgYmVnaW4gd2l0aCBcImRhdGE6XCIpJyk7XG4gIH1cblxuICAvLyBzdHJpcCBuZXdsaW5lc1xuICB1cmkgPSB1cmkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyk7XG5cbiAgLy8gc3BsaXQgdGhlIFVSSSB1cCBpbnRvIHRoZSBcIm1ldGFkYXRhXCIgYW5kIHRoZSBcImRhdGFcIiBwb3J0aW9uc1xuICB2YXIgZmlyc3RDb21tYSA9IHVyaS5pbmRleE9mKCcsJyk7XG4gIGlmICgtMSA9PT0gZmlyc3RDb21tYSB8fCBmaXJzdENvbW1hIDw9IDQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBkYXRhOiBVUkknKTtcblxuICAvLyByZW1vdmUgdGhlIFwiZGF0YTpcIiBzY2hlbWUgYW5kIHBhcnNlIHRoZSBtZXRhZGF0YVxuICB2YXIgbWV0YSA9IHVyaS5zdWJzdHJpbmcoNSwgZmlyc3RDb21tYSkuc3BsaXQoJzsnKTtcblxuICB2YXIgYmFzZTY0ID0gZmFsc2U7XG4gIHZhciBjaGFyc2V0ID0gJ1VTLUFTQ0lJJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCdiYXNlNjQnID09IG1ldGFbaV0pIHtcbiAgICAgIGJhc2U2NCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgwID09IG1ldGFbaV0uaW5kZXhPZignY2hhcnNldD0nKSkge1xuICAgICAgY2hhcnNldCA9IG1ldGFbaV0uc3Vic3RyaW5nKDgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCB0aGUgZW5jb2RlZCBkYXRhIHBvcnRpb24gYW5kIGRlY29kZSBVUkktZW5jb2RlZCBjaGFyc1xuICB2YXIgZGF0YSA9IHVuZXNjYXBlKHVyaS5zdWJzdHJpbmcoZmlyc3RDb21tYSArIDEpKTtcblxuICB2YXIgZW5jb2RpbmcgPSBiYXNlNjQgPyAnYmFzZTY0JyA6ICdhc2NpaSc7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcblxuICAvLyBzZXQgYC50eXBlYCBwcm9wZXJ0eSB0byBNSU1FIHR5cGVcbiAgYnVmZmVyLnR5cGUgPSBtZXRhWzBdIHx8ICd0ZXh0L3BsYWluJztcblxuICAvLyBzZXQgdGhlIGAuY2hhcnNldGAgcHJvcGVydHlcbiAgYnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuXG4gIHJldHVybiBidWZmZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpbnRlcnAxZChhcnIsIHgpIHtcbiAgdmFyIGl4ID0gTWF0aC5mbG9vcih4KVxuICAgICwgZnggPSB4IC0gaXhcbiAgICAsIHMwID0gMCA8PSBpeCAgICYmIGl4ICAgPCBhcnIuc2hhcGVbMF1cbiAgICAsIHMxID0gMCA8PSBpeCsxICYmIGl4KzEgPCBhcnIuc2hhcGVbMF1cbiAgICAsIHcwID0gczAgPyArYXJyLmdldChpeCkgICA6IDAuMFxuICAgICwgdzEgPSBzMSA/ICthcnIuZ2V0KGl4KzEpIDogMC4wXG4gIHJldHVybiAoMS4wLWZ4KSp3MCArIGZ4KncxXG59XG5cbmZ1bmN0aW9uIGludGVycDJkKGFyciwgeCwgeSkge1xuICB2YXIgaXggPSBNYXRoLmZsb29yKHgpXG4gICAgLCBmeCA9IHggLSBpeFxuICAgICwgczAgPSAwIDw9IGl4ICAgJiYgaXggICA8IGFyci5zaGFwZVswXVxuICAgICwgczEgPSAwIDw9IGl4KzEgJiYgaXgrMSA8IGFyci5zaGFwZVswXVxuICAgICwgaXkgPSBNYXRoLmZsb29yKHkpXG4gICAgLCBmeSA9IHkgLSBpeVxuICAgICwgdDAgPSAwIDw9IGl5ICAgJiYgaXkgICA8IGFyci5zaGFwZVsxXVxuICAgICwgdDEgPSAwIDw9IGl5KzEgJiYgaXkrMSA8IGFyci5zaGFwZVsxXVxuICAgICwgdzAwID0gczAmJnQwID8gYXJyLmdldChpeCAgLGl5ICApIDogMC4wXG4gICAgLCB3MDEgPSBzMCYmdDEgPyBhcnIuZ2V0KGl4ICAsaXkrMSkgOiAwLjBcbiAgICAsIHcxMCA9IHMxJiZ0MCA/IGFyci5nZXQoaXgrMSxpeSAgKSA6IDAuMFxuICAgICwgdzExID0gczEmJnQxID8gYXJyLmdldChpeCsxLGl5KzEpIDogMC4wXG4gIHJldHVybiAoMS4wLWZ5KSAqICgoMS4wLWZ4KSp3MDAgKyBmeCp3MTApICsgZnkgKiAoKDEuMC1meCkqdzAxICsgZngqdzExKVxufVxuXG5mdW5jdGlvbiBpbnRlcnAzZChhcnIsIHgsIHksIHopIHtcbiAgdmFyIGl4ID0gTWF0aC5mbG9vcih4KVxuICAgICwgZnggPSB4IC0gaXhcbiAgICAsIHMwID0gMCA8PSBpeCAgICYmIGl4ICAgPCBhcnIuc2hhcGVbMF1cbiAgICAsIHMxID0gMCA8PSBpeCsxICYmIGl4KzEgPCBhcnIuc2hhcGVbMF1cbiAgICAsIGl5ID0gTWF0aC5mbG9vcih5KVxuICAgICwgZnkgPSB5IC0gaXlcbiAgICAsIHQwID0gMCA8PSBpeSAgICYmIGl5ICAgPCBhcnIuc2hhcGVbMV1cbiAgICAsIHQxID0gMCA8PSBpeSsxICYmIGl5KzEgPCBhcnIuc2hhcGVbMV1cbiAgICAsIGl6ID0gTWF0aC5mbG9vcih6KVxuICAgICwgZnogPSB6IC0gaXpcbiAgICAsIHUwID0gMCA8PSBpeiAgICYmIGl6ICAgPCBhcnIuc2hhcGVbMl1cbiAgICAsIHUxID0gMCA8PSBpeisxICYmIGl6KzEgPCBhcnIuc2hhcGVbMl1cbiAgICAsIHcwMDAgPSBzMCYmdDAmJnUwID8gYXJyLmdldChpeCxpeSxpeikgICAgICAgOiAwLjBcbiAgICAsIHcwMTAgPSBzMCYmdDEmJnUwID8gYXJyLmdldChpeCxpeSsxLGl6KSAgICAgOiAwLjBcbiAgICAsIHcxMDAgPSBzMSYmdDAmJnUwID8gYXJyLmdldChpeCsxLGl5LGl6KSAgICAgOiAwLjBcbiAgICAsIHcxMTAgPSBzMSYmdDEmJnUwID8gYXJyLmdldChpeCsxLGl5KzEsaXopICAgOiAwLjBcbiAgICAsIHcwMDEgPSBzMCYmdDAmJnUxID8gYXJyLmdldChpeCxpeSxpeisxKSAgICAgOiAwLjBcbiAgICAsIHcwMTEgPSBzMCYmdDEmJnUxID8gYXJyLmdldChpeCxpeSsxLGl6KzEpICAgOiAwLjBcbiAgICAsIHcxMDEgPSBzMSYmdDAmJnUxID8gYXJyLmdldChpeCsxLGl5LGl6KzEpICAgOiAwLjBcbiAgICAsIHcxMTEgPSBzMSYmdDEmJnUxID8gYXJyLmdldChpeCsxLGl5KzEsaXorMSkgOiAwLjBcbiAgcmV0dXJuICgxLjAtZnopICogKCgxLjAtZnkpICogKCgxLjAtZngpKncwMDAgKyBmeCp3MTAwKSArIGZ5ICogKCgxLjAtZngpKncwMTAgKyBmeCp3MTEwKSkgKyBmeiAqICgoMS4wLWZ5KSAqICgoMS4wLWZ4KSp3MDAxICsgZngqdzEwMSkgKyBmeSAqICgoMS4wLWZ4KSp3MDExICsgZngqdzExMSkpXG59XG5cbmZ1bmN0aW9uIGludGVycE5kKGFycikge1xuICB2YXIgZCA9IGFyci5zaGFwZS5sZW5ndGh8MFxuICAgICwgaXggPSBuZXcgQXJyYXkoZClcbiAgICAsIGZ4ID0gbmV3IEFycmF5KGQpXG4gICAgLCBzMCA9IG5ldyBBcnJheShkKVxuICAgICwgczEgPSBuZXcgQXJyYXkoZClcbiAgICAsIGksIHRcbiAgZm9yKGk9MDsgaTxkOyArK2kpIHtcbiAgICB0ID0gK2FyZ3VtZW50c1tpKzFdXG4gICAgaXhbaV0gPSBNYXRoLmZsb29yKHQpXG4gICAgZnhbaV0gPSB0IC0gaXhbaV1cbiAgICBzMFtpXSA9ICgwIDw9IGl4W2ldICAgJiYgaXhbaV0gICA8IGFyci5zaGFwZVtpXSlcbiAgICBzMVtpXSA9ICgwIDw9IGl4W2ldKzEgJiYgaXhbaV0rMSA8IGFyci5zaGFwZVtpXSlcbiAgfVxuICB2YXIgciA9IDAuMCwgaiwgdywgaWR4XG5pX2xvb3A6XG4gIGZvcihpPTA7IGk8KDE8PGQpOyArK2kpIHtcbiAgICB3ID0gMS4wXG4gICAgaWR4ID0gYXJyLm9mZnNldFxuICAgIGZvcihqPTA7IGo8ZDsgKytqKSB7XG4gICAgICBpZihpICYgKDE8PGopKSB7XG4gICAgICAgIGlmKCFzMVtqXSkge1xuICAgICAgICAgIGNvbnRpbnVlIGlfbG9vcFxuICAgICAgICB9XG4gICAgICAgIHcgKj0gZnhbal1cbiAgICAgICAgaWR4ICs9IGFyci5zdHJpZGVbal0gKiAoaXhbal0gKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIXMwW2pdKSB7XG4gICAgICAgICAgY29udGludWUgaV9sb29wXG4gICAgICAgIH1cbiAgICAgICAgdyAqPSAxLjAgLSBmeFtqXVxuICAgICAgICBpZHggKz0gYXJyLnN0cmlkZVtqXSAqIGl4W2pdXG4gICAgICB9XG4gICAgfVxuICAgIHIgKz0gdyAqIGFyci5kYXRhW2lkeF1cbiAgfVxuICByZXR1cm4gclxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhcnIsIHgsIHksIHopIHtcbiAgc3dpdGNoKGFyci5zaGFwZS5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gMC4wXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGludGVycDFkKGFyciwgeClcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gaW50ZXJwMmQoYXJyLCB4LCB5KVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBpbnRlcnAzZChhcnIsIHgsIHksIHopXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpbnRlcnBOZC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cylcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZVxubW9kdWxlLmV4cG9ydHMuZDEgPSBpbnRlcnAxZFxubW9kdWxlLmV4cG9ydHMuZDIgPSBpbnRlcnAyZFxubW9kdWxlLmV4cG9ydHMuZDMgPSBpbnRlcnAzZFxuIiwiY29uc3QgQnJlc2VuaGFtID0ge307XG5cbmNvbnN0IFNsb3BlID0ge1xuICAgIERJUjoge1xuICAgICAgICBVUDogMSxcbiAgICAgICAgRE9XTjogLTEsXG4gICAgfSxcbn07XG4vKipcbiAqIFNjYW5zIGEgbGluZSBvZiB0aGUgZ2l2ZW4gaW1hZ2UgZnJvbSBwb2ludCBwMSB0byBwMiBhbmQgcmV0dXJucyBhIHJlc3VsdCBvYmplY3QgY29udGFpbmluZ1xuICogZ3JheS1zY2FsZSB2YWx1ZXMgKDAtMjU1KSBvZiB0aGUgdW5kZXJseWluZyBwaXhlbHMgaW4gYWRkaXRpb24gdG8gdGhlIG1pblxuICogYW5kIG1heCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VXcmFwcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEgVGhlIHN0YXJ0IHBvaW50IHt4LHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIgVGhlIGVuZCBwb2ludCB7eCx5fVxuICogQHJldHVybnMge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUgPSBmdW5jdGlvbiAoaW1hZ2VXcmFwcGVyLCBwMSwgcDIpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgbGV0IHgwID0gcDEueCB8IDA7XG4gICAgbGV0IHkwID0gcDEueSB8IDA7XG4gICAgbGV0IHgxID0gcDIueCB8IDA7XG4gICAgbGV0IHkxID0gcDIueSB8IDA7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IHN0ZWVwID0gTWF0aC5hYnMoeTEgLSB5MCkgPiBNYXRoLmFicyh4MSAtIHgwKTtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHk7XG4gICAgbGV0IHRtcDtcbiAgICBsZXQgeDtcbiAgICBjb25zdCBsaW5lID0gW107XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCB2YWw7XG4gICAgbGV0IG1pbiA9IDI1NTtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlYWQoYSwgYikge1xuICAgICAgICB2YWwgPSBpbWFnZURhdGFbYiAqIHdpZHRoICsgYV07XG4gICAgICAgIG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcbiAgICAgICAgbWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuICAgICAgICBsaW5lLnB1c2godmFsKTtcbiAgICB9XG5cbiAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgdG1wID0geDA7XG4gICAgICAgIHgwID0geTA7XG4gICAgICAgIHkwID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHgxO1xuICAgICAgICB4MSA9IHkxO1xuICAgICAgICB5MSA9IHRtcDtcbiAgICB9XG4gICAgaWYgKHgwID4geDEpIHtcbiAgICAgICAgdG1wID0geDA7XG4gICAgICAgIHgwID0geDE7XG4gICAgICAgIHgxID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHkwO1xuICAgICAgICB5MCA9IHkxO1xuICAgICAgICB5MSA9IHRtcDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geDEgLSB4MDtcbiAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgICBlcnJvciA9IChkZWx0YVggLyAyKSB8IDA7XG4gICAgeSA9IHkwO1xuICAgIGNvbnN0IHlTdGVwID0geTAgPCB5MSA/IDEgOiAtMTtcbiAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICByZWFkKHksIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciAtPSBkZWx0YVk7XG4gICAgICAgIGlmIChlcnJvciA8IDApIHtcbiAgICAgICAgICAgIHkgKz0geVN0ZXA7XG4gICAgICAgICAgICBlcnJvciArPSBkZWx0YVg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICBtaW4sXG4gICAgICAgIG1heCxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcmVzdWx0IGZyb20gZ2V0QmFyY29kZUxpbmUgaW50byBhIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogYWxzbyBjb25zaWRlcmluZyB0aGUgZnJlcXVlbmN5IGFuZCBzbG9wZSBvZiB0aGUgc2lnbmFsIGZvciBtb3JlIHJvYnVzdCByZXN1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLnRvQmluYXJ5TGluZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBjb25zdCB7IG1pbiB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbWF4IH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBsaW5lIH0gPSByZXN1bHQ7XG4gICAgbGV0IHNsb3BlO1xuICAgIGxldCBzbG9wZTI7XG4gICAgY29uc3QgY2VudGVyID0gbWluICsgKG1heCAtIG1pbikgLyAyO1xuICAgIGNvbnN0IGV4dHJlbWEgPSBbXTtcbiAgICBsZXQgY3VycmVudERpcjtcbiAgICBsZXQgZGlyO1xuICAgIGxldCB0aHJlc2hvbGQgPSAobWF4IC0gbWluKSAvIDEyO1xuICAgIGNvbnN0IHJUaHJlc2hvbGQgPSAtdGhyZXNob2xkO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuXG4gICAgLy8gMS4gZmluZCBleHRyZW1hXG4gICAgY3VycmVudERpciA9IGxpbmVbMF0gPiBjZW50ZXIgPyBTbG9wZS5ESVIuVVAgOiBTbG9wZS5ESVIuRE9XTjtcbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IDAsXG4gICAgICAgIHZhbDogbGluZVswXSxcbiAgICB9KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgc2xvcGUgPSAobGluZVtpICsgMV0gLSBsaW5lW2ldKTtcbiAgICAgICAgc2xvcGUyID0gKGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV0pO1xuICAgICAgICBpZiAoKHNsb3BlICsgc2xvcGUyKSA8IHJUaHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPCAoY2VudGVyICogMS41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XG4gICAgICAgIH0gZWxzZSBpZiAoKHNsb3BlICsgc2xvcGUyKSA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IChjZW50ZXIgKiAwLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXIgPSBjdXJyZW50RGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREaXIgIT09IGRpcikge1xuICAgICAgICAgICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgdmFsOiBsaW5lW2ldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50RGlyID0gZGlyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogbGluZS5sZW5ndGgsXG4gICAgICAgIHZhbDogbGluZVtsaW5lLmxlbmd0aCAtIDFdLFxuICAgIH0pO1xuXG4gICAgZm9yIChqID0gZXh0cmVtYVswXS5wb3M7IGogPCBleHRyZW1hWzFdLnBvczsgaisrKSB7XG4gICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gY2VudGVyID8gMCA6IDE7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGV4dHJlbWEgYW5kIGNvbnZlcnQgdG8gYmluYXJ5IGJhc2VkIG9uIGF2ZyBiZXR3ZWVuIG1pbm1heFxuICAgIGZvciAoaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZXh0cmVtYVtpICsgMV0udmFsID4gZXh0cmVtYVtpXS52YWwpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2ldLnZhbCArICgoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMykgKiAyKSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpICsgMV0udmFsICsgKChleHRyZW1hW2ldLnZhbCAtIGV4dHJlbWFbaSArIDFdLnZhbCkgLyAzKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gZXh0cmVtYVtpXS5wb3M7IGogPCBleHRyZW1hW2kgKyAxXS5wb3M7IGorKykge1xuICAgICAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiB0aHJlc2hvbGQgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBVc2VkIGZvciBkZXZlbG9wbWVudCBvbmx5XG4gKi9cbkJyZXNlbmhhbS5kZWJ1ZyA9IHtcbiAgICBwcmludEZyZXF1ZW5jeShsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMjU2O1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhpLCAyNTUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpLCAyNTUgLSBsaW5lW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgcHJpbnRQYXR0ZXJuKGxpbmUsIGNhbnZhcykge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgbGV0XG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY3R4LmZpbGxDb2xvciA9ICdibGFjayc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChpLCAwLCAxLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJyZXNlbmhhbTtcbiIsImltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuZXhwb3J0IGVudW0gQmFyY29kZURpcmVjdGlvbiB7XG4gICAgRm9yd2FyZCA9IDEsXG4gICAgUmV2ZXJzZSA9IC0xLFxufTtcblxuZXhwb3J0IHR5cGUgQmFyY29kZVJlYWRlclR5cGUgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBCYXJjb2RlRm9ybWF0ID0gc3RyaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVSZWFkZXJDb25maWcge1xuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg/OiBib29sZWFuLFxuICAgIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlclR5cGU+LFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlQ29ycmVjdGlvbiB7XG4gICAgYmFyOiBudW1iZXIsXG4gICAgc3BhY2U6IG51bWJlcixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0Q291bnRlcj86IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRDb3VudGVyPzogbnVtYmVyLFxuICAgIGVycm9yPzogbnVtYmVyLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlSW5mbyBleHRlbmRzIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgY29kZTogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZSB7XG4gICAgY29kZTogc3RyaW5nLFxuICAgIGNvZGVzZXQ/OiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxuICAgIGRlY29kZWRDb2Rlcz86IEFycmF5PHN0cmluZyB8IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPixcbiAgICBkaXJlY3Rpb24/OiBCYXJjb2RlRGlyZWN0aW9uLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZEluZm8/OiBCYXJjb2RlUG9zaXRpb24sXG4gICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24sXG4gICAgc3VwcGxlbWVudD86IEJhcmNvZGUsXG59O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFyY29kZVJlYWRlciB7XG4gICAgX3JvdzogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZyA9IHt9O1xuICAgIHN1cHBsZW1lbnRzOiBBcnJheTxCYXJjb2RlUmVhZGVyPiA9IFtdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMDtcbiAgICBGT1JNQVQ6IEJhcmNvZGVGb3JtYXQgPSAndW5rbm93bic7XG4gICAgQ09ORklHX0tFWVM6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcbiAgICAvLyBUT0RPOiBzaG91bGQgYWRkIEFMUEhBQkVUSF9TVFJJTkcsIEFMUEhBQkVULCBDSEFSQUNURVJfRU5DT0RJTkdTIHRvIGJhc2UgY2xhc3MsIGlmIHRoZXlcbiAgICAvLyBhcmUgdXNlZnVsIGluIG1vc3QgcmVhZGVycy5cblxuICAgIGFic3RyYWN0IF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbDtcblxuICAgIHN0YXRpYyBnZXQgRXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgU3RhcnROb3RGb3VuZEV4Y2VwdGlvbjogJ1N0YXJ0LUluZm8gd2FzIG5vdCBmb3VuZCEnLFxuICAgICAgICAgICAgQ29kZU5vdEZvdW5kRXhjZXB0aW9uOiAnQ29kZSBjb3VsZCBub3QgYmUgZm91bmQhJyxcbiAgICAgICAgICAgIFBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbjogJ1BhdHRlcm4gY291bGQgbm90IGJlIGZvdW5kISdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcblxuICAgICAgICB0aGlzLl9yb3cgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIGlmIChzdXBwbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9uZXh0VW5zZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBzdGFydDogbnVtYmVyID0gMCk6IG51bWJlciB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIF9tYXRjaFBhdHRlcm4oY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG1heFNpbmdsZUVycm9yPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgbGV0IHNpbmdsZUVycm9yID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBtb2R1bG8gPSAwO1xuICAgICAgICBsZXQgYmFyV2lkdGggPSAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc2NhbGVkID0gMDtcblxuICAgICAgICBtYXhTaW5nbGVFcnJvciA9IG1heFNpbmdsZUVycm9yIHx8IHRoaXMuU0lOR0xFX0NPREVfRVJST1IgfHwgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgbW9kdWxvICs9IGNvZGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1bSA8IG1vZHVsbykge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJXaWR0aCA9IHN1bSAvIG1vZHVsbztcbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xuICAgICAgICAgICAgc2luZ2xlRXJyb3IgPSBNYXRoLmFicyhjb3VudCAtIHNjYWxlZCkgLyBzY2FsZWQ7XG4gICAgICAgICAgICBpZiAoc2luZ2xlRXJyb3IgPiBtYXhTaW5nbGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgKz0gc2luZ2xlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yIC8gbW9kdWxvO1xuICAgIH1cblxuICAgIF9uZXh0U2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIF9jb3JyZWN0QmFycyhjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBudW1iZXIsIGluZGljZXM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgICBsZXQgdG1wID0gMDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xuICAgICAgICAgICAgaWYgKHRtcCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNvZGVQYXR0ZXJuKHBhdHRlcm46IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4nLCBwYXR0ZXJuKTtcbiAgICAgICAgdGhpcy5fcm93ID0gcGF0dGVybjtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4gY2FsbGluZyBkZWNvZGUnLCB0eXBlb2YgdGhpcywgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcy5GT1JNQVQsIEpTT04uc3RyaW5naWZ5KHRoaXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2RlY29kZSgpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3QgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXZlcnNlZCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5SZXZlcnNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZm9ybWF0ID0gdGhpcy5GT1JNQVQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX21hdGNoUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gMCA6IHN0YXJ0O1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfZmlsbENvdW50ZXJzKG9mZnNldDogbnVtYmVyID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdyksIGVuZDogbnVtYmVyID0gdGhpcy5fcm93Lmxlbmd0aCwgaXNXaGl0ZTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cblxuICAgIF90b0NvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSB8IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tzdGFydF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBBcnJheUhlbHBlci5pbml0KGNvdW50ZXJzLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhcmNvZGVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlQ29ycmVjdGlvbiwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBDb2RlMTI4UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgQ09ERV9TSElGVCA9IDk4O1xuICAgIENPREVfQyA9IDk5O1xuICAgIENPREVfQiA9IDEwMDtcbiAgICBDT0RFX0EgPSAxMDE7XG4gICAgU1RBUlRfQ09ERV9BID0gMTAzO1xuICAgIFNUQVJUX0NPREVfQiA9IDEwNDtcbiAgICBTVEFSVF9DT0RFX0MgPSAxMDU7XG4gICAgU1RPUF9DT0RFID0gMTA2O1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgICAgIFsyLCAxLCAyLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAxLCAzLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAxLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAyLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAzLCAxLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCA0LCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFs0LCAxLCAzLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCA0LCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAxLCA0LCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNjQ7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuICAgIEZPUk1BVCA9ICdjb2RlXzEyOCc7XG4gICAgTU9EVUxFX0lORElDRVMgPSB7IGJhcjogWzAsIDIsIDRdLCBzcGFjZTogWzEsIDMsIDVdIH07XG5cbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ycmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2NvcnJlY3QoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5iYXIsIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5zcGFjZSwgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IF9maW5kU3RhcnQgYW5kIGRlY29kZUNvZGUgc2hhcmUgc2ltaWxhciBjb2RlLCBjYW4gd2UgcmUtdXNlIHNvbWU/XG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gdGhpcy5TVEFSVF9DT0RFX0E7IGNvZGUgPD0gdGhpcy5TVEFSVF9DT0RFX0M7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAvLyAgICAgZG9uZSA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBtdWx0aXBsaWVyID0gMCxcbiAgICAgICAgLy8gICAgIGNoZWNrc3VtID0gMCxcbiAgICAgICAgLy8gICAgIGNvZGVzZXQsXG4gICAgICAgIC8vICAgICByYXdSZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIGRlY29kZWRDb2RlcyA9IFtdLFxuICAgICAgICAvLyAgICAgc2hpZnROZXh0ID0gZmFsc2UsXG4gICAgICAgIC8vICAgICB1bnNoaWZ0LFxuICAgICAgICAvLyAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG5cbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IHN0YXJ0SW5mby5jb3JyZWN0aW9uLmJhcixcbiAgICAgICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24uc3BhY2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIGxldCBjaGVja3N1bSA9IGNvZGUuY29kZTtcbiAgICAgICAgbGV0IGNvZGVzZXQgPSAoKGM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGNvZGUuY29kZSk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgIGxldCByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAwO1xuICAgICAgICBsZXQgcmF3UmVzdWx0OiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTsgLy8gVE9ETzogaSB0aGluayB0aGlzIHNob3VsZCBiZSBzdHJpbmcgb25seSwgYnV0IGl0IGNyZWF0ZXMgcHJvYmxlbXMgaWYgaXQgaXNcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgICAgICBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUhLmVuZCwgY29kZSEuY29ycmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gbXVsdGlwbGllciAqIGNvZGUuY29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlLmNvZGUgLSA2NCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSA8IDEwID8gJzAnICsgY29kZS5jb2RlIDogY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBjb2Rlc2V0ID09PSB0aGlzLkNPREVfQSA/IHRoaXMuQ09ERV9CIDogdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLmVuZCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoY29kZSkpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVja3N1bSAtPSBtdWx0aXBsaWVyICogcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICAgICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UocmVzdWx0Lmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0IGFzIG51bWJlcixcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmRJbmZvOiBjb2RlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbyk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkICs9IG5vcm1hbGl6ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuXG4vLyBjb25zdCBDT0RFX0xfU1RBUlQgPSAwO1xuY29uc3QgQ09ERV9HX1NUQVJUID0gMTA7XG5leHBvcnQgeyBDT0RFX0dfU1RBUlQgfTtcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMV07XG5jb25zdCBNSURETEVfUEFUVEVSTiA9IFsxLCAxLCAxLCAxLCAxXTtcbmV4cG9ydCB7IE1JRERMRV9QQVRURVJOIH07XG5jb25zdCBFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAyXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbMywgMiwgMSwgMV0sXG4gICAgWzIsIDIsIDIsIDFdLFxuICAgIFsyLCAxLCAyLCAyXSxcbiAgICBbMSwgNCwgMSwgMV0sXG4gICAgWzEsIDEsIDMsIDJdLFxuICAgIFsxLCAyLCAzLCAxXSxcbiAgICBbMSwgMSwgMSwgNF0sXG4gICAgWzEsIDMsIDEsIDJdLFxuICAgIFsxLCAyLCAxLCAzXSxcbiAgICBbMywgMSwgMSwgMl0sXG4gICAgWzEsIDEsIDIsIDNdLFxuICAgIFsxLCAyLCAyLCAyXSxcbiAgICBbMiwgMiwgMSwgMl0sXG4gICAgWzEsIDEsIDQsIDFdLFxuICAgIFsyLCAzLCAxLCAxXSxcbiAgICBbMSwgMywgMiwgMV0sXG4gICAgWzQsIDEsIDEsIDFdLFxuICAgIFsyLCAxLCAzLCAxXSxcbiAgICBbMywgMSwgMiwgMV0sXG4gICAgWzIsIDEsIDEsIDNdLFxuXTtcbmNvbnN0IENPREVfRlJFUVVFTkNZID0gWzAsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdO1xuLy8gY29uc3QgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuY29uc3QgQVZHX0NPREVfRVJST1IgPSAwLjQ4O1xuXG5jbGFzcyBFQU5SZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzEzJztcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XG4gICAgU1RPUF9QQVRURVJOID0gWzEsIDEsIDFdOyAvLyBUT0RPOiBkb2VzIHRoaXMgbmVlZCB0byBiZSBpbiB0aGUgY2xhc3M/XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc/OiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKHsgc3VwcGxlbWVudHM6IFtdIH0sIGNvbmZpZyksIHN1cHBsZW1lbnRzKTtcbiAgICB9XG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4sIHRyeUhhcmRlcjogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybicsIHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyLCBlcHNpbG9uKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCogbG9vcCBpPSR7b2Zmc2V0fSBsZW49JHt0aGlzLl9yb3cubGVuZ3RofSBpc1doaXRlPSR7aXNXaGl0ZX0gY291bnRlclBvcz0ke2NvdW50ZXJQb3N9YCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBtYXRjaFBhdHRlcm4nLCBlcnJvciwgY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24gJiYgYmVzdE1hdGNoLmVycm9yICYmIGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBjb3VudGVyLnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGZpbmRQYXR0ZXJuIGFuZCBkZWNvZGVDb2RlIGFwcGVhciB0byBzaGFyZSBxdWl0ZSBzaW1pbGFyIGNvZGUsIGNhbiBpdCBiZSByZWR1Y2VkP1xuICAgIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvZGVyYW5nZT86IG51bWJlcik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlJywgc3RhcnQsIGNvZGVyYW5nZSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGlmICghY29kZXJhbmdlKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBiZWZvcmUgbGVuZ3RoJyk7XG4gICAgICAgICAgICBjb2RlcmFuZ2UgPSBDT0RFX1BBVFRFUk4ubGVuZ3RoO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYWZ0ZXIgbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgY29kZXJhbmdlOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRTdGFydCcpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogc3RhcnRJbmZvPScsIEpTT04uc3RyaW5naWZ5KHN0YXJ0SW5mbykpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KTtcblxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBzdGFydEluZm8nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogY2FsY3VsYXRlRmlyc3REaWdpdCcsIGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENPREVfRlJFUVVFTkNZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ09ERV9GUkVRVUVOQ1lbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF5bG9hZCcsIGluQ29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIG91dENvZGUpO1xuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLT0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDAgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IHRoaXMuX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdERpZ2l0PScsIGZpcnN0RGlnaXQpO1xuICAgICAgICBpZiAoZmlyc3REaWdpdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGZpcnN0RGlnaXQpO1xuXG4gICAgICAgIGxldCBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIG91dENvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybj0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgaWYgKG1pZGRsZVBhdHRlcm4gPT09IG51bGwgfHwgIW1pZGRsZVBhdHRlcm4uZW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9kZWNvZGVDb2RlKG1pZGRsZVBhdHRlcm4hLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICAgICAgaWYgKCFtaWRkbGVQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCByZXN1bHQ9JywgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlZENvZGVzPScsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIHJldHVybiBtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArIChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpO1xuXG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZEVuZCcsIG9mZnNldCwgaXNXaGl0ZSk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBpc1doaXRlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBfY2hlY2tzdW0nLCByZXN1bHQpO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VtICo9IDM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY2hlY2tzdW0nLCBzdW0gJSAxMCA9PT0gMCk7XG4gICAgICAgIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kZWNvZGVFeHRlbnNpb25zKG9mZnNldDogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiwgc3RhcnQsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucycsIHRoaXMuc3VwcGxlbWVudHMpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhlcmUgYXJlICcsIHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoLCAnIHN1cHBsZW1lbnRzJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGV4dGVuc2lvbnMgbG9vcCcsIGksIHRoaXMuc3VwcGxlbWVudHNbaV0sIHRoaXMuc3VwcGxlbWVudHNbaV0uX2RlY29kZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUodGhpcy5fcm93LCBzdGFydEluZm8uZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJlc3VsdC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdC5kZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc3VwcGxlbWVudHNbaV0uRk9STUFULFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogZGVjb2RlRXh0ZW5zaW9ucyBlcnJvciBpbiAnLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCAnOiAnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVFeHRlbnNpb25zJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCByb3cpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgc3RhcnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KCk7XG4gICAgICAgIGxldCByZXN1bHRJbmZvOiBCYXJjb2RlIHwge30gPSB7fTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlUG9zaXRpb24gfCBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kXG4gICAgICAgIH07XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRFbmQoY29kZS5lbmQsIGZhbHNlKTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzdW1cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja3N1bShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGlzLnN1cHBsZW1lbnRzPScsIHRoaXMuc3VwcGxlbWVudHMpO1xuICAgICAgICBpZiAodGhpcy5zdXBwbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwbGVtZW50ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucyByZXR1cm5zJywgc3VwcGxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIXN1cHBsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50LmRlY29kZWRDb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0Q29kZSA9IHN1cHBsZW1lbnQuZGVjb2RlZENvZGVzW3N1cHBsZW1lbnQuZGVjb2RlZENvZGVzLmxlbmd0aCAtIDFdIGFzIEJhcmNvZGVJbmZvO1xuICAgICAgICAgICAgY29uc3QgZW5kSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKChsYXN0Q29kZS5lbmQgLSBsYXN0Q29kZS5zdGFydCkgLyAyKSB8IDApLFxuICAgICAgICAgICAgICAgIGVuZDogbGFzdENvZGUuZW5kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpICsgc3VwcGxlbWVudC5jb2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgLi4ucmVzdWx0SW5mbyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFQU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCwgMHgxMDksIDB4MDQ5LFxuICAgIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQywgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LFxuICAgIDB4MDQ2LCAweDAxNiwgMHgxODEsIDB4MEMxLCAweDFDMCwgMHgwOTEsIDB4MTkwLCAweDBEMCwgMHgwODUsIDB4MTg0LCAweDBDNCwgMHgwOTQsIDB4MEE4LCAweDBBMiwgMHgwOEEsIDB4MDJBLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MDk0O1xuXG5jbGFzcyBDb2RlMzlSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOSc7XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbN10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzhdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heE5hcnJvd1dpZHRoID0gMDtcbiAgICAgICAgbGV0IG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnM7XG4gICAgICAgIGxldCB3aWRlQmFyV2lkdGggPSAwO1xuXG4gICAgICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcbiAgICAgICAgICAgIG1heE5hcnJvd1dpZHRoID0gdGhpcy5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xuICAgICAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiBudW1XaWRlQmFycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlcnNbaV0gKiAyKSA+PSB3aWRlQmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBfZmluZE5leHRXaWR0aChjb3VudGVyczogVWludDE2QXJyYXksIGN1cnJlbnQ6IG51bWJlcikge1xuICAgICAgICBsZXQgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA8IG1pbldpZHRoICYmIGNvdW50ZXJzW2ldID4gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluV2lkdGg7XG4gICAgfTtcblxuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5TaXplID0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcblxuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBwYXR0ZXJuU2l6ZTtcbiAgICAgICAgaWYgKCh0cmFpbGluZ1doaXRlc3BhY2VFbmQgKiAzKSA+PSBwYXR0ZXJuU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcblxuICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgIGxldCBsYXN0U3RhcnQ6IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0LCBuZXh0U3RhcnQsIGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIElPUTogL1tJT1FdL2csXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXG59O1xuXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5X3Zpbic7XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAhIWNvZGU7XG4gICAgfVxuXG4gICAgLy8gQ3JpYmJlZCBmcm9tOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuX2RlY29kZShyb3csIHN0YXJ0KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5JT1EsICcnKTtcblxuICAgICAgICBpZiAoIWNvZGUubWF0Y2gocGF0dGVybnMuQVowOSkpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIEFaMDkgcGF0dGVybiBjb2RlOicsIGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzOVZJTlJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG4vLyBjb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODktJDovLitBQkNEJztcbmNvbnN0IEFMUEhBQkVUID0gWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF07XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID1cbiAgICBbMHgwMDMsIDB4MDA2LCAweDAwOSwgMHgwNjAsIDB4MDEyLCAweDA0MiwgMHgwMjEsIDB4MDI0LCAweDAzMCwgMHgwNDgsIDB4MDBjLCAweDAxOCxcbiAgICAgICAgMHgwNDUsIDB4MDUxLCAweDA1NCwgMHgwMTUsIDB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcbmNvbnN0IFNUQVJUX0VORCA9IFsweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBNSU5fRU5DT0RFRF9DSEFSUyA9IDQ7XG5jb25zdCBNQVhfQUNDRVBUQUJMRSA9IDIuMDtcbmNvbnN0IFBBRERJTkcgPSAxLjU7XG5cbmludGVyZmFjZSBUaHJlc2hvbGRTaXplIHtcbiAgICBzaXplOiBudW1iZXIsXG4gICAgY291bnRzOiBudW1iZXIsXG4gICAgbWluOiBudW1iZXIsXG4gICAgbWF4OiBudW1iZXIsXG59O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkIHtcbiAgICBzcGFjZToge1xuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXG4gICAgfSxcbiAgICBiYXI6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG59O1xuXG5jbGFzcyBOZXdDb2RhYmFyUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgX2NvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgRk9STUFUID0gJ2NvZGFiYXInO1xuXG4gICAgX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XG4gICAgfTtcblxuICAgIF90b1BhdHRlcm4ob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSA3O1xuICAgICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycztcblxuICAgICAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xuICAgICAgICBjb25zdCBzcGFjZVRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQgKyAxLCBlbmQpO1xuXG4gICAgICAgIGxldCBiaXRtYXNrID0gMSA8PCAobnVtQ291bnRlcnMgLSAxKTtcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IDA7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gYml0bWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdG1hc2sgPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgX2lzU3RhcnRFbmQocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoU1RBUlRfRU5EW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfc3VtQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oaSk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiAhPT0gLTEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICAgICAgICBzdGFydCArPSB0aGlzLl9zdW1Db3VudGVycygwLCBpKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKGksIGkgKyA4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICAgICAgICAgIGVuZENvdW50ZXI6IGkgKyA4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA3OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIF92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0Q291bnRlcjogbnVtYmVyLCBlbmRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgaWYgKChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKGVuZENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2NoYXJUb1BhdHRlcm4oY2hhcjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChBTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMHgwO1xuICAgIH07XG5cbiAgICBfdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcml6YXRpb246IFRocmVzaG9sZCA9IHtcbiAgICAgICAgICAgICAgICBzcGFjZToge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgICAgIGNhdC5zaXplICs9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGNhdC5jb3VudHMrKztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICAoWydzcGFjZScsICdiYXInXSBhcyBjb25zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5taW4gPVxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XG4gICAgICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWF4ID0gTWF0aC5jZWlsKChuZXdraW5kLndpZGUuc2l6ZSAqIE1BWF9BQ0NFUFRBQkxFICsgUEFERElORykgLyBuZXdraW5kLndpZGUuY291bnRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhdGVnb3JpemF0aW9uO1xuICAgIH07XG5cbiAgICBfdmFsaWRhdGVSZXN1bHQocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAwID8gdGhyZXNob2xkcy5iYXIgOiB0aHJlc2hvbGRzLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPCBjYXQubWluIHx8IHNpemUgPiBjYXQubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcblxuICAgICAgICB0aGlzLl9jb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycygpO1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcjtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihuZXh0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSA4O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgdGhpcy5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgICAgICAvLyB2ZXJpZnkgZW5kXG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAtIDIpIDwgTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA/IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA6IG5leHRTdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQuc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULCAvLyBUT0RPOiBpIHRoaW5rIGl0IHNob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gcmV0dXJuIGZvcm1hdCBmcm9tIHRoaXMsIGFzIGJhcmNvZGVfcmVhZGVyIGZvcmNlIHNldHMgdGhlIGZvcm1hdCBhbnl3YXlcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBOZXdDb2RhYmFyUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ1JlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ3VwY19hJztcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBFQU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gcmVzdWx0LmNvZGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ1JlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJULCBNSURETEVfUEFUVEVSTiB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIEVBTjhSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fOCc7XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBpbkNvZGU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFQU44UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5cbmNsYXNzIEVBTjJSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMic7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbignJykpICUgNCkgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjJSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuY2xhc3MgRUFONVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl81JztcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ0VSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIENPREVfRlJFUVVFTkNZID0gW1xuICAgICAgICBbIDU2LCA1MiwgNTAsIDQ5LCA0NCwgMzgsIDM1LCA0MiwgNDEsIDM3IF0sXG4gICAgICAgIFs3LCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XV07XG4gICAgU1RPUF9QQVRURVJOID0gWzEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDddO1xuICAgIEZPUk1BVCA9ICd1cGNfZSc7XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPSAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtIENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9ICgxIDw8ICg1IC0gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dENvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcblxuICAgIF9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeTogbnVtYmVyLCByZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgZm9yIChsZXQgbnJTeXN0ZW0gPSAwOyBuclN5c3RlbSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBuclN5c3RlbSsrKXtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQobnJTeXN0ZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2NvbnZlcnRUb1VQQ0EocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCB1cGNhID0gW3Jlc3VsdFswXV07XG4gICAgICAgIGNvbnN0IGxhc3REaWdpdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMl07XG5cbiAgICAgICAgaWYgKGxhc3REaWdpdCA8PSAyKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoW2xhc3REaWdpdCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMykge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA0KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSA0KSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgcmV0dXJuIHVwY2E7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdXBlci5fY2hlY2tzdW0odGhpcy5fY29udmVydFRvVVBDQShyZXN1bHQpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9maW5kRW5kKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ0VSZWFkZXI7XG4iLCIvLyBUT0RPOiBpMm9mNV9yZWFkZXIgYW5kIDJvZjVfcmVhZGVyIHNoYXJlIHZlcnkgc2ltaWxhciBjb2RlLCBtYWtlIHVzZSBvZiB0aGF0XG5cbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuXG5jbGFzcyBJMm9mNVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zODtcblxuICAgIFNUQVJUX1BBVFRFUk4gPSBbTiwgTiwgTiwgTl07XG4gICAgU1RPUF9QQVRURVJOID0gW04sIE4sIFddO1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgW04sIE4sIFcsIFcsIE5dLFxuICAgICAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICAgICAgW1csIFcsIE4sIE4sIE5dLFxuICAgICAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIFcsIFcsIE4sIE5dLFxuICAgICAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICAgICAgW04sIFcsIE4sIFcsIE5dLFxuICAgIF07XG4gICAgTUFYX0NPUlJFQ1RJT05fRkFDVE9SID0gNTtcbiAgICBGT1JNQVQgPSAnaTJvZjUnO1xuXG4gICAgY29uc3RydWN0b3Iob3B0czogQmFyY29kZVJlYWRlckNvbmZpZykge1xuICAgICAgICBzdXBlcihtZXJnZSh7IG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg6IGZhbHNlIH0sIG9wdHMpKTtcbiAgICAgICAgaWYgKG9wdHMubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiA9IDAuMzg7XG4gICAgICAgICAgICB0aGlzLkFWR19DT0RFX0VSUk9SID0gMC4wOTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IG9wdHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9tYXRjaFBhdHRlcm4oY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVyU3VtID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29kZVN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW8gPSB0aGlzLk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpb0ludmVyc2UgPSAxIC8gY29ycmVjdGlvblJhdGlvO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyU3VtW2kgJSAyXSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgICAgIGNvZGVTdW1baSAlIDJdICs9IGNvZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gY29kZVN1bVswXSAvIGNvdW50ZXJTdW1bMF07XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gY29kZVN1bVsxXSAvIGNvdW50ZXJTdW1bMV07XG5cbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzBdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzFdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IGNvcnJlY3Rpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldICo9IHRoaXMuYmFyU3BhY2VSYXRpb1tpICUgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFBhdHRlcm4uY2FsbCh0aGlzLCBjb3VudGVyLCBjb2RlKTtcbiAgICB9O1xuXG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpc1doaXRlID0gaXNXaGl0ZSB8fCBmYWxzZTtcbiAgICAgICAgdHJ5SGFyZGVyID0gdHJ5SGFyZGVyIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDEwO1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9maW5kRW5kKCkge1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4pO1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlUGFpcihjb3VudGVyUGFpcjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pIHtcbiAgICAgICAgY29uc3QgY29kZXM6IEFycmF5PEJhcmNvZGVJbmZvPiA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlclBhaXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXJQYWlyW2ldKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfTtcblxuICAgIF9kZWNvZGVDb2RlKGNvdW50ZXI6IEFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyUGFpciA9IFtbMCwgMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwLCAwXV07XG4gICAgICAgIGxldCBjb2RlczogQmFyY29kZUluZm9bXSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzBdW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclsxXVtpXSA9IGNvdW50ZXJzW3BvcyArIDFdICogdGhpcy5iYXJTcGFjZVJhdGlvWzFdO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXMgPSB0aGlzLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcbiAgICAgICAgICAgIGlmICghY29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tpXS5jb2RlICsgJycpO1xuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfTtcblxuICAgIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICAgICAgdmFyIGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlUG9zaXRpb24+KCk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XG4gICAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEkyb2Y1UmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFtXLCBOLCBXLCBOLCBOLCBOXTtcbmNvbnN0IFNUT1BfUEFUVEVSTiA9IFtXLCBOLCBOLCBOLCBXXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgW1csIE4sIE4sIE4sIFddLFxuICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgW04sIE4sIFcsIE4sIFddLFxuICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgW04sIE4sIE4sIFcsIFddLFxuICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICBbTiwgVywgTiwgVywgTl0sXG5dO1xuY29uc3QgU1RBUlRfUEFUVEVSTl9MRU5HVEggPSBTVEFSVF9QQVRURVJOLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG5cbmNsYXNzIFR3b09mRml2ZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG5cbiAgICBGT1JNQVQgPSAnMm9mNSc7XG5cbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG5cbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG5cbiAgICBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZSA9IGZhbHNlLCB0cnlIYXJkZXIgPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBsZXQgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gU1RBUlRfUEFUVEVSTl9MRU5HVEgpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICB9XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9maW5kRW5kKCkge1xuICAgICAgICAvLyBUT0RPOiByZXZlcnNlLCBmb2xsb3dlZCBieSBzb21lIGNhbGNzLCBmb2xsb3dlZCBieSBhbm90aGVyIHJldmVyc2U/IHJlYWxseT9cbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbiAgICB9XG5cbiAgICBfZGVjb2RlQ29kZShjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IENPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8+KSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChgJHtjb2RlLmNvZGV9YCk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUd29PZkZpdmVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgMHgxQTgsIDB4MUE0LCAweDFBMiwgMHgxOTQsIDB4MTkyLCAweDE4QSwgMHgxNjgsIDB4MTY0LCAweDE2MiwgMHgxMzQsXG4gICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgMHgxNkUsIDB4MTc2LCAweDFBRSwgMHgxMjYsIDB4MURBLCAweDFENiwgMHgxMzIsIDB4MTVFLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xuXG5jbGFzcyBDb2RlOTNSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XG4gICAgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVycy5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBNYXRoLnJvdW5kKGNvdW50ZXJzW2ldICogOSAvIHN1bSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCA8IDEgfHwgbm9ybWFsaXplZCA+IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9ybWFsaXplZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAocGF0dGVybiA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5RW5kKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlcikge1xuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIF9kZWNvZGVFeHRlbmRlZChjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2hhckFycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBuZXh0Q2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnRicgJiYgbmV4dENoYXIgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnVCcgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGNvZGVfOTNfcmVhZGVyIF9kZWNvZGVFeHRlbmRlZCBoaXQgZGVmYXVsdCBjYXNlLCB0aGlzIG1heSBiZSBhbiBlcnJvcicsIGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIF9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4sIGluZGV4OiBudW1iZXIsIG1heFdlaWdodDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5VG9DaGVjay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkU3VtcyA9IGFycmF5VG9DaGVjay5yZWR1Y2UoKHN1bSwgY2hhciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gKCgoaSAqIC0xKSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQUxQSEFCRVQuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArICh3ZWlnaHQgKiB2YWx1ZSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrQ2hhciA9IEFMUEhBQkVUWyh3ZWlnaHRlZFN1bXMgJSA0NyldO1xuICAgICAgICByZXR1cm4gY2hlY2tDaGFyID09PSBjaGFyQXJyYXlbaW5kZXhdLmNoYXJDb2RlQXQoMCk7XG4gICAgfTtcblxuICAgIF92ZXJpZnlDaGVja3N1bXMoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAyLCAyMClcbiAgICAgICAgICAgICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZz4gfCBudWxsID0gW107XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcbiAgICAgICAgbGV0IGxhc3RTdGFydDtcbiAgICAgICAgbGV0IGRlY29kZWRDaGFyOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgICAvLyB5ZXMsIHRoaXMgaXMgYW4gYXNzaWduIGluc2lkZSBhbiBpZi5cbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlOTNSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIEFFSU86IC9bQUVJT10vZyxcbiAgICBBWjA5OiAvW0EtWjAtOV0vLFxufTtcblxuY29uc3QgY29kZTMyc2V0ID0gJzAxMjM0NTY3ODlCQ0RGR0hKS0xNTlBRUlNUVVZXWFlaJztcblxuY2xhc3MgQ29kZTMyUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zMl9yZWFkZXInO1xuXG4gICAgX2RlY29kZUNvZGUzMihjb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKC9bXjAtOUJDREZHSEpLTE1OUFFSU1RVVldYWVpdLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSByZXMgKiAzMiArIGNvZGUzMnNldC5pbmRleE9mKGNvZGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlMzIgPSAnJyArIHJlcztcbiAgICAgICAgaWYgKGNvZGUzMi5sZW5ndGggPCA5KSB7XG4gICAgICAgICAgICBjb2RlMzIgPSAoJzAwMDAwMDAwMCcgKyBjb2RlMzIpLnNsaWNlKC05KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0EnICsgY29kZTMyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcbiAgICBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICEhY29kZTtcbiAgICB9XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5fZGVjb2RlKHJvdywgc3RhcnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZSA9IHJlc3VsdC5jb2RlO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLkFFSU8sICcnKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGUzMiA9IHRoaXMuX2RlY29kZUNvZGUzMihjb2RlKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghY29kZTMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlMzI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzJSZWFkZXI7XG4iLCJpbXBvcnQgQnJlc2VuaGFtIGZyb20gJy4vYnJlc2VuaGFtJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8xMjhfcmVhZGVyJztcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVZJTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyJztcbmltcG9ydCBDb2RhYmFyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RhYmFyX3JlYWRlcic7XG5pbXBvcnQgVVBDUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfcmVhZGVyJztcbmltcG9ydCBFQU44UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fOF9yZWFkZXInO1xuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl8yX3JlYWRlcic7XG5pbXBvcnQgRUFONVJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzVfcmVhZGVyJztcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfZV9yZWFkZXInO1xuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4uL3JlYWRlci9pMm9mNV9yZWFkZXInO1xuaW1wb3J0IFR3b09mRml2ZVJlYWRlciBmcm9tICcuLi9yZWFkZXIvMm9mNV9yZWFkZXInO1xuaW1wb3J0IENvZGU5M1JlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV85M19yZWFkZXInO1xuaW1wb3J0IENvZGUzMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zMl9yZWFkZXInO1xuXG5jb25zdCBSRUFERVJTID0ge1xuICAgIGNvZGVfMTI4X3JlYWRlcjogQ29kZTEyOFJlYWRlcixcbiAgICBlYW5fcmVhZGVyOiBFQU5SZWFkZXIsXG4gICAgZWFuXzVfcmVhZGVyOiBFQU41UmVhZGVyLFxuICAgIGVhbl8yX3JlYWRlcjogRUFOMlJlYWRlcixcbiAgICBlYW5fOF9yZWFkZXI6IEVBTjhSZWFkZXIsXG4gICAgY29kZV8zOV9yZWFkZXI6IENvZGUzOVJlYWRlcixcbiAgICBjb2RlXzM5X3Zpbl9yZWFkZXI6IENvZGUzOVZJTlJlYWRlcixcbiAgICBjb2RhYmFyX3JlYWRlcjogQ29kYWJhclJlYWRlcixcbiAgICB1cGNfcmVhZGVyOiBVUENSZWFkZXIsXG4gICAgdXBjX2VfcmVhZGVyOiBVUENFUmVhZGVyLFxuICAgIGkyb2Y1X3JlYWRlcjogSTJvZjVSZWFkZXIsXG4gICAgJzJvZjVfcmVhZGVyJzogVHdvT2ZGaXZlUmVhZGVyLFxuICAgIGNvZGVfOTNfcmVhZGVyOiBDb2RlOTNSZWFkZXIsXG4gICAgY29kZV8zMl9yZWFkZXI6IENvZGUzMlJlYWRlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICByZWdpc3RlclJlYWRlcjogKG5hbWUsIHJlYWRlcikgPT4ge1xuICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xuICAgIH0sXG4gICAgY3JlYXRlKGNvbmZpZywgaW5wdXRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgX2NhbnZhcyA9IHtcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9iYXJjb2RlUmVhZGVycyA9IFtdO1xuXG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgaW5pdENvbmZpZygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkZGVidWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcuZGV0ZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmZyZXF1ZW5jeScpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20uZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kuY2xhc3NOYW1lID0gJ2ZyZXF1ZW5jeSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LmZyZXF1ZW5jeSA9IF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5wYXR0ZXJuQnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybi5jbGFzc05hbWUgPSAncGF0dGVybkJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5wYXR0ZXJuID0gX2NhbnZhcy5kb20ucGF0dGVybi5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuZG9tLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgub3ZlcmxheSA9IF9jYW52YXMuZG9tLm92ZXJsYXkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcbiAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzLmZvckVhY2goKHJlYWRlckNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWFkZXI7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgc3VwcGxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWcuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0gcmVhZGVyQ29uZmlnLmNvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmVmb3JlIHJlZ2lzdGVyaW5nIHJlYWRlcjogJywgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxlbWVudHMgPSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3VwcGxlbWVudHMubWFwKChzdXBwbGVtZW50KSA9PiBuZXcgUkVBREVSU1tzdXBwbGVtZW50XSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyT2JqID0gbmV3IFJFQURFUlNbcmVhZGVyXShjb25maWd1cmF0aW9uLCBzdXBwbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogRXJyb3IgY29uc3RydWN0aW5nIHJlYWRlciAnLCByZWFkZXIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVnaXN0ZXJlZCBSZWFkZXJzOiAke19iYXJjb2RlUmVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChyZWFkZXIpID0+IEpTT04uc3RyaW5naWZ5KHsgZm9ybWF0OiByZWFkZXIuRk9STUFULCBjb25maWc6IHJlYWRlci5jb25maWcgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENvbmZpZygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLmZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4sXG4gICAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNbaV0ucHJvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4dGVuZCB0aGUgbGluZSBvbiBib3RoIGVuZHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBleHRlbmRMaW5lKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICB4OiBhbW91bnQgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluc2lkZSBpbWFnZVxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xuICAgICAgICAgICAgd2hpbGUgKGV4dCA+IDEgJiYgKCFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzBdKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVsxXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgZXh0IC09IE1hdGguY2VpbChleHQgLyAyKTtcbiAgICAgICAgICAgICAgICBleHRlbmRMaW5lKC1leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lKGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbMV1bMV0gLSBib3hbMF1bMV0pIC8gMiArIGJveFswXVsxXSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFszXVsxXSAtIGJveFsyXVsxXSkgLyAyICsgYm94WzJdWzFdLFxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGUobGluZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVMaW5lID0gQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lKGlucHV0SW1hZ2VXcmFwcGVyLCBsaW5lWzBdLCBsaW5lWzFdKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBfY2FudmFzLmN0eC5vdmVybGF5LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludEZyZXF1ZW5jeShiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCcmVzZW5oYW0udG9CaW5hcnlMaW5lKGJhcmNvZGVMaW5lKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgYmFyY29kZUxpbmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNsaWNlcyB0aGUgZ2l2ZW4gYXJlYSBhcGFydCBhbmQgdHJpZXMgdG8gZGV0ZWN0IGEgYmFyY29kZS1wYXR0ZXJuXG4gICAgICAgICAqIGZvciBlYWNoIHNsaWNlLiBJdCByZXR1cm5zIHRoZSBkZWNvZGVkIGJhcmNvZGUsIG9yIG51bGwgaWYgbm90aGluZyB3YXMgZm91bmRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYm94XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2lkZUxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyhib3hbMV1bMF0gLSBib3hbMF1bMF0sIDIpICsgTWF0aC5wb3coKGJveFsxXVsxXSAtIGJveFswXVsxXSksIDIpKTtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3Qgc2xpY2VzID0gMTY7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkaXI7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uO1xuICAgICAgICAgICAgY29uc3QgeGRpciA9IE1hdGguc2luKGxpbmVBbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNsaWNlcyAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgbGluZSBwZXJwZW5kaWN1bGFyIHRvIGFuZ2xlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIGRpciA9IHNpZGVMZW5ndGggLyBzbGljZXMgKiBpICogKGkgJSAyID09PSAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGRpciAqIHhkaXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGRpciAqIHlkaXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpXG4gICAgICAgICAgICAgICAgKyBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnggLSBsaW5lWzBdLngpLCAyKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVJbWFnZSA/IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVJbWFnZShpbWFnZVdyYXBwZXIpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpdGggdGhlIGhlbHAgb2YgdGhlIGNvbmZpZ3VyZWQgcmVhZGVycyAoQ29kZTEyOCBvciBFQU4pIHRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gZGV0ZWN0IGFcbiAgICAgICAgICogdmFsaWQgYmFyY29kZSBwYXR0ZXJuIHdpdGhpbiB0aGUgZ2l2ZW4gYXJlYS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJveCBUaGUgYXJlYSB0byBzZWFyY2ggaW5cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHJlc3VsdCB7Y29kZVJlc3VsdCwgbGluZSwgYW5nbGUsIHBhdHRlcm4sIHRocmVzaG9sZH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgICAgIGxldCBsaW5lO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gX2NhbnZhcy5jdHgub3ZlcmxheTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnLmRyYXdCb3VuZGluZ0JveCAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBjdHgsIHsgY29sb3I6ICdibHVlJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IGdldExpbmUoYm94KTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgbGluZUFuZ2xlID0gTWF0aC5hdGFuMihsaW5lWzFdLnkgLSBsaW5lWzBdLnksIGxpbmVbMV0ueCAtIGxpbmVbMF0ueCk7XG4gICAgICAgICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiByZXN1bHQgJiYgY29uZmlnLmRlYnVnLmRyYXdTY2FubGluZSAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgY3R4LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgYW5nbGU6IGxpbmVBbmdsZSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiByZXN1bHQuYmFyY29kZUxpbmUubGluZSxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHJlc3VsdC5iYXJjb2RlTGluZS50aHJlc2hvbGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTsgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJjb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlwbGUgfSA9IGNvbmZpZztcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib3ggPSBib3g7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGVGcm9tSW1hZ2UoaW5wdXRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVGcm9tSW1hZ2UoaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJFQURFUlNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVnaXN0ZXIgZXhpc3RpbmcgcmVhZGVyJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuIiwidHlwZSBFdmVudE5hbWUgPSBzdHJpbmc7XG5cbmludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICAgIGFzeW5jPzogYm9vbGVhbjtcbiAgICBjYWxsYmFjazogRnVuY3Rpb247XG4gICAgb25jZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBFdmVudERhdGEge1xuICAgIHN1YnNjcmliZXJzOiBBcnJheTxTdWJzY3JpcHRpb24+O1xufVxuXG5pbnRlcmZhY2UgRXZlbnRzIHtcbiAgICBba2V5OiBzdHJpbmddOiBFdmVudERhdGE7XG59XG5cbmludGVyZmFjZSBFdmVudEludGVyZmFjZSB7XG4gICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkO1xuICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHVuc3Vic2NyaWJlKGV2ZW50TmFtZT86IEV2ZW50TmFtZSwgY2FsbGJhY2s/OiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbik6IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBFdmVudEludGVyZmFjZSgpOiBFdmVudEludGVyZmFjZSB7XG4gICAgbGV0IGV2ZW50czogRXZlbnRzID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudChldmVudE5hbWU6IEV2ZW50TmFtZSk6IEV2ZW50RGF0YSB7XG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50c1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyRXZlbnRzKCk6IHZvaWQge1xuICAgICAgICBldmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLCBkYXRhOiBuZXZlcik6IHZvaWQge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9LCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0RXZlbnQoZXZlbnQpLnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgICAgIHJldHVybiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xuICAgICAgICB9LFxuICAgICAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3Vic2NyaWJlcnMgfSA9IGV2ZW50O1xuXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gISFzdWJzY3JpYmVyLm9uY2UpLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGVtIGZyb20gdGhlIHN1YnNjcmliZXJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhc3Vic2NyaWJlci5vbmNlKTtcblxuICAgICAgICAgICAgLy8gcHVibGlzaCB0aGUgcmVzdFxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgICAgIF9zdWJzY3JpYmUoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc3Vic2NyaWJlKGV2ZW50TmFtZT86IEV2ZW50TmFtZSwgY2FsbGJhY2s/OiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbik6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufSgpKTtcbiIsImNvbnN0IEVSUk9SX0RFU0MgPSAnVGhpcyBtYXkgbWVhbiB0aGF0IHRoZSB1c2VyIGhhcyBkZWNsaW5lZCBjYW1lcmEgYWNjZXNzLCBvciB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1lZGlhIEFQSXMuIElmIHlvdSBhcmUgcnVubmluZyBpbiBpT1MsIHlvdSBtdXN0IHVzZSBTYWZhcmkuJztcblxuaW50ZXJmYWNlIEVycm9yIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrPzogc3RyaW5nO1xuICAgIGNvZGU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEVycm9yKGBlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAtMTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPE1lZGlhU3RyZWFtPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEVycm9yKGBnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IC0xO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cbiIsImltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcbmltcG9ydCB7IGdldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9tZWRpYURldmljZXMnO1xuaW1wb3J0IHsgTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxubGV0IHN0cmVhbVJlZjogTWVkaWFTdHJlYW0gfCBudWxsO1xuXG5mdW5jdGlvbiB3YWl0Rm9yVmlkZW8odmlkZW86IEhUTUxWaWRlb0VsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAxMDtcblxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZpZGVvKCk6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh2aWRlby52aWRlb1dpZHRoID4gMTAgJiYgdmlkZW8udmlkZW9IZWlnaHQgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgKiBkZXY6IGNoZWNrVmlkZW8gZm91bmQgJHt2aWRlby52aWRlb1dpZHRofXB4IHggJHt2aWRlby52aWRlb0hlaWdodH1weGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVja1ZpZGVvLCA1MDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRlbXB0cy0tO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmlkZW8oKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUcmllcyB0byBhdHRhY2ggdGhlIGNhbWVyYS1zdHJlYW0gdG8gYSBnaXZlbiB2aWRlby1lbGVtZW50XG4gKiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGNvbnRlbnQgaXMgcmVhZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHZpZGVvXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluaXRDYW1lcmEodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBzdHJlYW1SZWYgPSBzdHJlYW07XG4gICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XG4gICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7IC8vIG5vdCBsaXN0ZWQgb24gTUROLi4uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdhaXRGb3JWaWRlbyh2aWRlbyk7XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBpY2sodmlkZW9Db25zdHJhaW50cywgWyd3aWR0aCcsICdoZWlnaHQnLCAnZmFjaW5nTW9kZScsXG4gICAgICAgICdhc3BlY3RSYXRpbycsICdkZXZpY2VJZCddKTtcblxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICYmIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gPiAwKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogQ29uc3RyYWludCBcXCdtaW5Bc3BlY3RSYXRpb1xcJyBpcyBkZXByZWNhdGVkOyBVc2UgXFwnYXNwZWN0UmF0aW9cXCcgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMuZmFjaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBub3JtYWxpemVkLmZhY2luZ01vZGUgPSB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnZmFjaW5nXFwnIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXCdmYWNpbmdNb2RlXFwnIGluc3RlYWRcXCcnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIFRPRE86ICMxOTIgSSBkb24ndCB0aGluayB0aGVyZSdzIGFueSBnb29kIHJlYXNvbiBwaWNrQ29uc3RyYWludHMgc2hvdWxkIHJldHVybiBhIFByb21pc2UsXG4vLyBJIHRoaW5rIGl0IHdhcyBqdXN0IHRoYXQgd2F5IHNvIGl0IGNvdWxkIGJlIGNoYWluZWQgdG8gb3RoZXIgZnVuY3Rpb25zIHRoYXQgZGlkIHJldHVybiBhIFByb21pc2UuXG4vLyBUaGF0J3Mgbm90IG5lY2Vzc2FyeSB3aXRoIGFzeW5jIGZ1bmN0aW9ucyBiZWluZyBhIHRoaW5nLCBzbyB0aGF0IHNob3VsZCBiZSBmaXhlZC5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQgPSB7fSk6IFByb21pc2U8TWVkaWFTdHJlYW1Db25zdHJhaW50cz4ge1xuICAgIGNvbnN0IHZpZGVvID0gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xuXG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLmRldmljZUlkICYmIHZpZGVvLmZhY2luZ01vZGUpIHtcbiAgICAgICAgZGVsZXRlIHZpZGVvLmZhY2luZ01vZGU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBhdWRpbzogZmFsc2UsIHZpZGVvIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlbnVtZXJhdGVWaWRlb0RldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG5cbiAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIHJldHVybiBkZXZpY2VzLmZpbHRlcigoZGV2aWNlOiBNZWRpYURldmljZUluZm8pID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVUcmFjaygpOiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbCB7XG4gICAgaWYgKCFzdHJlYW1SZWYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgIHJldHVybiB0cmFja3MgJiYgdHJhY2tzPy5sZW5ndGggPyB0cmFja3NbMF0gOiBudWxsO1xufVxuXG4vKipcbiAqIFVzZWQgZm9yIGFjY2Vzc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWN0aXZlIHN0cmVhbSB0cmFjayBhbmQgYXZhaWxhYmxlIHZpZGVvIGRldmljZXMuXG4gKi9cbmNvbnN0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzID0ge1xuICAgIGFzeW5jIHJlcXVlc3QodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsIHZpZGVvQ29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnN0cmFpbnRzID0gYXdhaXQgcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xuICAgICAgICByZXR1cm4gaW5pdENhbWVyYSh2aWRlbywgbmV3Q29uc3RyYWludHMpO1xuICAgIH0sXG4gICAgcmVsZWFzZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gVE9ETzogaSB3b25kZXIgaWYgdGVsbGluZyB0aGUgVmlkZW8gZWxlbWVudCB0byBwYXVzZSgpIGJlZm9yZSBjYWxsaW5nIE1lZGlhU3RyZWFtVHJhY2suc3RvcCgpIHdvdWxkIGFsbGV2aWF0ZSBzb21lIG9mIHRoZSBpc3N1ZXMgd2l0aCB0aGUgY2FtZXJhIGFwcGVhcmluZyB0byBzdGF5IG9wZW4gb24gQW5kcm9pZCBldmVuIGFmdGVyIHN0b3BwaW5nLlxuICAgICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYgJiYgc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJhY2tzWzBdLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xuICAgIH0sXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxuICAgIGdldEFjdGl2ZVN0cmVhbUxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrID8gdHJhY2subGFiZWwgOiAnJztcbiAgICB9LFxuICAgIGdldEFjdGl2ZVRyYWNrLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhSlNDYW1lcmFBY2Nlc3M7XG4iLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IHtcbiAgICBRdWFnZ2FKU0NvZGVSZXN1bHQsXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IsXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3JGaWx0ZXJGdW5jdGlvbixcbiAgICBYWVNpemUsXG4gICAgUXVhZ2dhSW1hZ2VEYXRhLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuZnVuY3Rpb24gY29udGFpbnMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LCBsaXN0OiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGxpc3QgJiYgbGlzdC5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKSBhcyBBcnJheTxrZXlvZiBRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xuICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiBpdGVtW2tleV0gPT09IGNvZGVSZXN1bHRba2V5XSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhc3Nlc0ZpbHRlcihcbiAgICBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsXG4gICAgZmlsdGVyOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkLFxuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgPyBmaWx0ZXIoY29kZVJlc3VsdCkgOiB0cnVlO1xufVxuXG5pbnRlcmZhY2UgUmVzdWx0Q29sbGVjdG9yIHtcbiAgICBhZGRSZXN1bHQ6IChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpID0+IHZvaWQ7XG4gICAgZ2V0UmVzdWx0czogKCkgPT4gQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0Pjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShjb25maWc6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yKTogUmVzdWx0Q29sbGVjdG9yIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICAgICAgY29uc3QgcmVzdWx0czogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PiA9IFtdO1xuICAgICAgICBsZXQgY2FwYWNpdHkgPSBjb25maWcuY2FwYWNpdHkgPz8gMjA7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBjb25maWcuY2FwdHVyZSA9PT0gdHJ1ZTtcblxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KTogYm9vbGVhbiB7XG4gICAgICAgICAgICByZXR1cm4gISFjYXBhY2l0eVxuICAgICAgICAgICAgICAgICYmIGNvZGVSZXN1bHRcbiAgICAgICAgICAgICAgICAmJiAhY29udGFpbnMoY29kZVJlc3VsdCwgY29uZmlnLmJsYWNrbGlzdCBhcyBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KVxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc0ZpbHRlcihjb2RlUmVzdWx0LCBjb25maWcuZmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRSZXN1bHQoZGF0YTogUXVhZ2dhSW1hZ2VEYXRhLCBpbWFnZVNpemU6IFhZU2l6ZSwgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KTogdm9pZCB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07IC8vIHRoaXMgaXMgJ2FueScgdG8gYXZvaWQgaGF2aW5nIHRvIGNvbnN0cnVjdCBhIHdob2xlIFF1YWdnYUpTQ29kZVJlc3VsdCA6fFxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHktLTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQgPSBjb2RlUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2VTaXplLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdJbWFnZShkYXRhLCBpbWFnZVNpemUsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZnJhbWUgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJlc3VsdHMoKTogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgRGV2Q29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICBuYW1lOiAnTGl2ZScsXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgLy8gb3IgdXNlclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgICAgICB9LFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBkcmF3Qm91bmRpbmdCb3g6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZyZXF1ZW5jeTogZmFsc2UsXG4gICAgICAgICAgICBkcmF3U2NhbmxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdHRlcm46IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgc2hvd0NhbnZhczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93Rm91bmRQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dTa2VsZXRvbjogZmFsc2UsXG4gICAgICAgICAgICBzaG93TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgYm94RnJvbVBhdGNoZXM6IHtcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZEJveDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0JCOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERldkNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IE5vZGVDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBQcm9kQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICBuYW1lOiAnTGl2ZScsXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgLy8gb3IgdXNlclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgICAgICB9LFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiA0LFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2RDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IERldkNvbmZpZyBmcm9tICcuL2NvbmZpZy5kZXYnO1xuaW1wb3J0IE5vZGVDb25maWcgZnJvbSAnLi9jb25maWcubm9kZSc7XG5pbXBvcnQgUHJvZENvbmZpZyBmcm9tICcuL2NvbmZpZy5wcm9kJztcblxuLy8gQHRzLWlnbm9yZSAvLyBUT0RPOiB0aGlzIHByb2R1Y2VzIGEgYml6YXJyZSB0eXBlc2NyaXB0IGVycm9yXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbmNvbnN0IFF1YWdnYUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSBFTlYuZGV2ZWxvcG1lbnRcbiAgICA/IERldkNvbmZpZ1xuICAgIDogRU5WLm5vZGVcbiAgICAgICAgPyBOb2RlQ29uZmlnXG4gICAgICAgIDogUHJvZENvbmZpZztcblxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tIFwiLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSBcImNvbW1vbi9pbWFnZV93cmFwcGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBRdWFnZ2FDb250ZXh0IHtcbiAgICBwdWJsaWMgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XG5cbiAgICBwdWJsaWMgaW5wdXRTdHJlYW06IGFueTtcblxuICAgIHB1YmxpYyBmcmFtZWdyYWJiZXI6IGFueTtcblxuICAgIHB1YmxpYyBpbnB1dEltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcjtcblxuICAgIHB1YmxpYyBzdG9wcGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgYm94U2l6ZTogYW55O1xuXG4gICAgcHVibGljIHJlc3VsdENvbGxlY3RvcjogYW55O1xuXG4gICAgcHVibGljIGRlY29kZXI6IGFueTtcblxuICAgIHB1YmxpYyB3b3JrZXJQb29sOiBhbnlbXSA9IFtdO1xuXG4gICAgcHVibGljIG9uVUlUaHJlYWQgPSB0cnVlO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNhbnZhc0NvbnRhaW5lciA9IG5ldyBDYW52YXNDb250YWluZXIoKTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0luZm8ge1xuICAgIGltYWdlOiBhbnk7XG4gICAgb3ZlcmxheTogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzQ29udGFpbmVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgY3R4OiBDYW52YXNJbmZvO1xuICAgIHB1YmxpYyByZWFkb25seSBkb206IENhbnZhc0luZm87XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgICAgICB0aGlzLmRvbSA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeSc7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5cbnR5cGUgQnVmZmVyUmV0dXJuID0ge1xuICAgIGlucHV0SW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXI7XG4gICAgLy8gYm94U2l6ZSBzaG91bGQgYmUgbGlrZSBbWyBudW1iZXIsIG51bWJlcl0sIC4uLl0gYnV0IGNsb25lJ3Mgc2lnbmF0dXJlIGRvZXNuJ3Qgc2VlbSB0byBhbGxvdyB0aGF0XG4gICAgYm94U2l6ZTogQXJyYXk8QXJyYXk8bnVtYmVyPj47XG59O1xuXG4vLyBUT0RPOiBuZWVkIHR5cGVzY3JpcHQgZGVmIGZvciBCYXJjb2RlTG9jYXRvclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoXG4gICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLFxuICAgIGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyIHwgdW5kZWZpbmVkLFxuICAgIGxvY2F0b3I6IGFueSxcbik6IEJ1ZmZlclJldHVybiB7XG4gICAgY29uc3QgaW5wdXRJbWFnZVdyYXBwZXIgPSBpbWFnZVdyYXBwZXIgfHwgbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksXG4gICAgICAgIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpLFxuICAgICAgICB0eXBlOiAnWFlTaXplJyxcbiAgICB9KTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYGltYWdlIHdyYXBwZXIgc2l6ZSAke2lucHV0SW1hZ2VXcmFwcGVyLnNpemV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJveFNpemUgPSBbXG4gICAgICAgIGNsb25lKFswLCAwXSksXG4gICAgICAgIGNsb25lKFswLCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgIGNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIDBdKSxcbiAgICBdO1xuICAgIEJhcmNvZGVMb2NhdG9yLmluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGxvY2F0b3IpO1xuICAgIHJldHVybiB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3UG9ydCh0YXJnZXQ/OiBFbGVtZW50IHwgc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbHJlYWR5IGEgRE9NIGVsZW1lbnRcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0Lm5vZGVOYW1lICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyBVc2UgJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCcgYXMgYSBmYWxsYmFjayBzZWxlY3RvciAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgY29uc3Qgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICcjaW50ZXJhY3RpdmUudmlld3BvcnQnO1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cbiIsImltcG9ydCB7IFF1YWdnYUNvbnRleHQsIENhbnZhc0NvbnRhaW5lciB9IGZyb20gJ1F1YWdnYUNvbnRleHQnO1xuaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XG5cbmZ1bmN0aW9uIGZpbmRPckNyZWF0ZUNhbnZhcyhzZWxlY3Rvcjogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZykge1xuICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBnZXRDYW52YXNBbmRDb250ZXh0KHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgY2FudmFzID0gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yLCBjbGFzc05hbWUpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICByZXR1cm4geyBjYW52YXMsIGNvbnRleHQgfTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhc2VzKGNhbnZhc1NpemU6IFhZU2l6ZSk6IENhbnZhc0NvbnRhaW5lciB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmltZ0J1ZmZlcicsICdpbWdCdWZmZXInKTtcbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGdldENhbnZhc0FuZENvbnRleHQoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJywgJ2RyYXdpbmdCdWZmZXInKTtcblxuICAgICAgICBpbWFnZS5jYW52YXMud2lkdGggPSBvdmVybGF5LmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgaW1hZ2UuY2FudmFzLmhlaWdodCA9IG92ZXJsYXkuY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemUueTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNhbnZhcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY29udGV4dCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNvbnRleHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdENhbnZhcyhjb250ZXh0OiBRdWFnZ2FDb250ZXh0KTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3UG9ydChjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50YXJnZXQpO1xuICAgIGNvbnN0IHR5cGUgPSBjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlO1xuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29udGFpbmVyID0gaW5pdENhbnZhc2VzKGNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIHsgZG9tOiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0sIGN0eDogeyBpbWFnZTogbnVsbCwgb3ZlcmxheTogbnVsbCB9IH07XG5cbiAgICBjb25zdCB7IGRvbSB9ID0gY29udGFpbmVyO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdJbWFnZVN0cmVhbScgJiYgIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5pbWFnZSkpIHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20uaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydC5jb250YWlucyhkb20ub3ZlcmxheSkpIHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20ub3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbiIsIi8vIE5PVEU6IChTT01FIE9GKSBUSElTIElTIEJST1dTRVIgT05MWSBDT0RFLiAgTm9kZSBkb2VzIG5vdCBoYXZlICdhdG9iJyBidWlsdCBpbiwgbm9yIFhNTEh0dHBSZXF1ZXN0LlxuLy8gSG93IGV4YWN0bHkgaXMgdGhpcyBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgaW4gUXVhZ2dhPyBEbyB3ZSBuZWVkIHRoZSBicm93c2VyIHNwZWNpZmljIGNvZGU/IERvIHdlXG4vLyBuZWVkIHRvIHBvcnQgYW55IHBhcnQgb2YgdGhpcyB0aGF0IGRvZXNuJ3Qgd29yayBpbiBOb2RlIHRvIG5vZGU/XG5cbi8vIFRhZ3Mgc2NyYXBlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcbmNvbnN0IEV4aWZUYWdzID0geyAweDAxMTI6ICdvcmllbnRhdGlvbicgfTtcbmV4cG9ydCBjb25zdCBBdmFpbGFibGVUYWdzID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLm1hcCgoa2V5KSA9PiBFeGlmVGFnc1trZXldKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5PYmplY3RVUkwoc3JjLCB0YWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGlmICgvXmJsb2I6L2kudGVzdChzcmMpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RVUkxUb0Jsb2Ioc3JjKVxuICAgICAgICAgICAgLnRoZW4ocmVhZFRvQnVmZmVyKVxuICAgICAgICAgICAgLnRoZW4oKGJ1ZmZlcikgPT4gZmluZFRhZ3NJbkJ1ZmZlcihidWZmZXIsIHRhZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoZGF0YVVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGFVcmwucmVwbGFjZSgvXmRhdGE6KFteO10rKTtiYXNlNjQsL2dtaSwgJycpO1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBsZW4gPSBiaW5hcnkubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2aWV3W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIHJlYWRUb0J1ZmZlcihibG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvYmplY3RVUkxUb0Jsb2IodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBodHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGh0dHAucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgKGh0dHAuc3RhdHVzID09PSAyMDAgfHwgaHR0cC5zdGF0dXMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaHR0cC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBodHRwLnNlbmQoKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5CdWZmZXIoZmlsZSwgc2VsZWN0ZWRUYWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGZpbGUpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZpbGUuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBleGlmVGFncyA9IHNlbGVjdGVkVGFncy5yZWR1Y2UoKHJlc3VsdCwgc2VsZWN0ZWRUYWcpID0+IHtcbiAgICAgICAgY29uc3QgZXhpZlRhZyA9IE9iamVjdC5rZXlzKEV4aWZUYWdzKS5maWx0ZXIoKHRhZykgPT4gRXhpZlRhZ3NbdGFnXSA9PT0gc2VsZWN0ZWRUYWcpWzBdO1xuICAgICAgICBpZiAoZXhpZlRhZykge1xuICAgICAgICAgICAgcmVzdWx0W2V4aWZUYWddID0gc2VsZWN0ZWRUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IG1hcmtlcjtcblxuICAgIGlmICgoZGF0YVZpZXcuZ2V0VWludDgoMCkgIT09IDB4RkYpIHx8IChkYXRhVmlldy5nZXRVaW50OCgxKSAhPT0gMHhEOCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAobWFya2VyID09PSAweEUxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEVYSUZEYXRhKGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBleGlmVGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkRVhJRkRhdGEoZmlsZSwgc3RhcnQsIGV4aWZUYWdzKSB7XG4gICAgaWYgKGdldFN0cmluZ0Zyb21CdWZmZXIoZmlsZSwgc3RhcnQsIDQpICE9PSAnRXhpZicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBzdGFydCArIDY7XG4gICAgbGV0IGJpZ0VuZDtcblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xuICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMkEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZmlsZS5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgIGlmIChmaXJzdElGRE9mZnNldCA8IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ3MgPSByZWFkVGFncyhmaWxlLCB0aWZmT2Zmc2V0LCB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQsIGV4aWZUYWdzLCBiaWdFbmQpO1xuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFncyhmaWxlLCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBzdHJpbmdzLCBiaWdFbmQpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gZmlsZS5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpO1xuICAgIGNvbnN0IHRhZ3MgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gZGlyU3RhcnQgKyBpICogMTIgKyAyO1xuICAgICAgICBjb25zdCB0YWcgPSBzdHJpbmdzW2ZpbGUuZ2V0VWludDE2KGVudHJ5T2Zmc2V0LCAhYmlnRW5kKV07XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHJlYWRUYWdWYWx1ZShmaWxlLCBlbnRyeU9mZnNldCwgdGlmZlN0YXJ0LCBkaXJTdGFydCwgYmlnRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpIHtcbiAgICBjb25zdCB0eXBlID0gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyAyLCAhYmlnRW5kKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBmaWxlLmdldFVpbnQzMihlbnRyeU9mZnNldCArIDQsICFiaWdFbmQpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUJ1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgb3V0c3RyID0gJyc7XG4gICAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgc3RhcnQgKyBsZW5ndGg7IG4rKykge1xuICAgICAgICBvdXRzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIuZ2V0VWludDgobikpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c3RyO1xufVxuIiwiaW1wb3J0IHsgZmluZFRhZ3NJbk9iamVjdFVSTCB9IGZyb20gJy4vZXhpZl9oZWxwZXInO1xuXG5jb25zdCBJbWFnZUxvYWRlciA9IHt9O1xuSW1hZ2VMb2FkZXIubG9hZCA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGNhbGxiYWNrLCBvZmZzZXQsIHNpemUsIHNlcXVlbmNlKSB7XG4gICAgY29uc3QgaHRtbEltYWdlc1NyY0FycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGNvbnN0IGh0bWxJbWFnZXNBcnJheSA9IG5ldyBBcnJheShodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgaW1nO1xuICAgIGxldCBudW07XG5cbiAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVswXSA9IGRpcmVjdG9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW0gPSAob2Zmc2V0ICsgaSk7XG4gICAgICAgICAgICBodG1sSW1hZ2VzU3JjQXJyYXlbaV0gPSBgJHtkaXJlY3Rvcnl9aW1hZ2UtJHsoYDAwJHtudW19YCkuc2xpY2UoLTMpfS5qcGdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQgPSBbXTtcbiAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZC5wdXNoKGltYWdlKTtcbiAgICB9O1xuICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQgPSBmdW5jdGlvbiAobG9hZGVkSW1nKSB7XG4gICAgICAgIGNvbnN0IG5vdGxvYWRlZEltZ3MgPSBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5vdGxvYWRlZEltZ3MubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChub3Rsb2FkZWRJbWdzW3hdID09PSBsb2FkZWRJbWcpIHtcbiAgICAgICAgICAgICAgICBub3Rsb2FkZWRJbWdzLnNwbGljZSh4LCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdOYW1lID0gaHRtbEltYWdlc1NyY0FycmF5W3ldLnN1YnN0cihodG1sSW1hZ2VzU3JjQXJyYXlbeV0ubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRJbWcuc3JjLmxhc3RJbmRleE9mKGltZ05hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5W3ldID0geyBpbWc6IGxvYWRlZEltZyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ltYWdlcyBsb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmaW5kVGFnc0luT2JqZWN0VVJMKGRpcmVjdG9yeSwgWydvcmllbnRhdGlvbiddKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigodGFncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5WzBdLnRhZ3MgPSB0YWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmFkZEltYWdlKGltZyk7XG4gICAgICAgIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICBpbWcuc3JjID0gaHRtbEltYWdlc1NyY0FycmF5W2ldO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpIHtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubG9hZGVkKHRoaXMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IChJbWFnZUxvYWRlcik7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi9pbWFnZV9sb2FkZXInO1xuaW1wb3J0IHsgWFlTaXplLCBQb2ludCB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgbGV0IF9jb25maWc6IHsgc2l6ZTogbnVtYmVyOyB0eXBlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGxldCBfY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBfY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfdG9wUmlnaHQ6IFBvaW50ID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnUG9pbnQnIH07XG4gICAgICAgIGNvbnN0IF9jYW52YXNTaXplOiBYWVNpemUgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdYWVNpemUnIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFNpemUoKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcblxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgX2NhbGN1bGF0ZWRIZWlnaHQgPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcblxuICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IF9jYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJywgKHR5cGVvZiBjb25maWcuc3JjICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcuc3JjIDogJycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLmVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZz8udHlwZSAhPT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjdXJyZW50VGltZScsIHRpbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBfZXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2FucmVjb3JkJykge1xuICAgICAgICAgICAgICAgICAgICBpbml0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHNpemUpIHtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gc2l6ZS54O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBzaXplLnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnB1dFN0cmVhbTtcbiAgICB9LFxuICAgIGNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhhdCA9IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk7XG4gICAgICAgIHRoYXQuZW5kZWQgPSBmdW5jdGlvbiBlbmRlZCgpOiBmYWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VTdHJlYW0oKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHNlcXVlbmNlOiBhbnkgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICBsZXQgZnJhbWVJZHggPSAwO1xuICAgICAgICBsZXQgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW1nQXJyYXk6IGFueVtdIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMTtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2VzKCk6IHZvaWQge1xuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBJbWFnZUxvYWRlci5sb2FkKGJhc2VVcmwsIChpbWdzOiBBcnJheTx7IHRhZ3M6IGFueTsgaW1nOiBIVE1MSW1hZ2VFbGVtZW50fT4pID0+IHtcbiAgICAgICAgICAgICAgICBpbWdBcnJheSA9IGltZ3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChpbWdzWzBdLnRhZ3MgJiYgaW1nc1swXS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IDA7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KCdjYW5yZWNvcmQnLCBbXSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LCBvZmZzZXQsIHNpemUsIF9jb25maWc/LnNlcXVlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hFdmVudChldmVudE5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xuICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MgYXMgYW55KTsgLy8gVE9ETzogdHlwZXNjcmlwdCBjb21wbGFpbnMgdGhhdCBhbnlbXSBpcyBub3QgdmFsaWQgZm9yIGEgc2Vjb25kIGFyZyBmb3IgYXBwbHk/IVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFueSBjb2RlIHNoYXJlZCB3aXRoIHRoZSBmaXJzdCBJbnB1dFN0cmVhbSBhYm92ZSBzaG91bGQgYmUgc2hhcmVkIG5vdCBjb3BpZWRcbiAgICAgICAgLy8gVE9ETzogcHVibGlzaEV2ZW50IG5lZWRzIGFjY2VzcyB0byBpbnB1dFN0cmVhbSwgYnV0IGlucHV0U3RyZWFtIG5lZWRzIGFjY2VzcyB0byBwdWJsaXNoRXZlbnRcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyB3aHkgaXQncyBhICd2YXInLCBzbyBpdCBob2lzdHMgYmFjay4gIFRoaXMgaXMgdWdseSwgYW5kIHNob3VsZCBiZSBjaGFuZ2VkLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXG4gICAgICAgIHZhciBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG5cbiAgICAgICAgICAgIHRyaWdnZXI6IHB1Ymxpc2hFdmVudCxcblxuICAgICAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKG5ld1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQobmV3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBzdHJlYW0uc3JjO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9hZEltYWdlcygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCkge30sXG5cbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbGF5KCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gdGltZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50SGFuZGxlcnMpLmZvckVhY2goKGluZCkgPT4gZGVsZXRlIF9ldmVudEhhbmRsZXJzW2luZF0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYW52YXNTaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBpbWdBcnJheT8uW2ZyYW1lSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSWR4IDwgKHNpemUgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZHgrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2VuZGVkJywgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnB1dFN0cmVhbUZhY3Rvcnk7XG4iLCIvLyBUT0RPOiBJdCdzIHByZXR0eSBsaWtlbHkgdGhhdCB0aGlzIHNoYXJlcyBjb2RlIHdpdGggdGhlIGJyb3dzZXIgdmVyc2lvbiwgaW52ZXN0aWdhdGUgdGhhdFxuaW1wb3J0IEdldFBpeGVscyBmcm9tICdnZXQtcGl4ZWxzJztcbmltcG9ydCB7IElucHV0U3RyZWFtRmFjdG9yeSwgSW5wdXRTdHJlYW0sIEV2ZW50SGFuZGxlckxpc3QgfSBmcm9tICcuL2lucHV0X3N0cmVhbS5kJztcbmltcG9ydCB7IFBvaW50LCBYWVNpemUgfSBmcm9tICcuLi8uLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgaW5wdXRTdHJlYW1GYWN0b3J5OiBJbnB1dFN0cmVhbUZhY3RvcnkgPSB7XG4gICAgY3JlYXRlVmlkZW9TdHJlYW0oKTogbmV2ZXIge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVZpZGVvU3RyZWFtIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9LFxuICAgIGNyZWF0ZUxpdmVTdHJlYW0oKTogbmV2ZXIge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUxpdmVTdHJlYW0gbm90IGF2YWlsYWJsZScpO1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VTdHJlYW0oKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBtaW1lOiBzdHJpbmc7IHNpemU6IG51bWJlcjsgc3JjOiBhbnkgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIFRPRE86IGZyYW1lIHNob3VsZCBiZSBhIHR5cGUgTmRBcnJheSwgYnV0IE5kQXJyYXkgZG9lc24ndCBoYXZlIHRzIGRlZmluaXRpb25zXG4gICAgICAgIC8vIFRPRE86IHRoZXJlIGlzIGEgdHMtbmRhcnJheSB0aGF0IG1pZ2h0IHdvcmssIHRob3VnaFxuICAgICAgICBsZXQgZnJhbWU6IGFueSA9IG51bGw7XG4gICAgICAgIGxldCBiYXNlVXJsOiBzdHJpbmc7XG4gICAgICAgIGNvbnN0IGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRIZWlnaHQ6IG51bWJlcjtcbiAgICAgICAgY29uc3QgX2V2ZW50TmFtZXMgPSBbJ2NhbnJlY29yZCcsICdlbmRlZCddO1xuICAgICAgICBjb25zdCBfZXZlbnRIYW5kbGVyczogRXZlbnRIYW5kbGVyTGlzdCA9IHt9O1xuICAgICAgICBjb25zdCBfdG9wUmlnaHQ6IFBvaW50ID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnUG9pbnQnIH07XG4gICAgICAgIGNvbnN0IF9jYW52YXNTaXplOiBYWVNpemUgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdYWVNpemUnIH07XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovIC8vIGZhbHNlIGVzbGludCBlcnJvcnM/IHdlaXJkLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgZnJhbWVJZHggPSAwO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbiAgICAgICAgICAgIEdldFBpeGVscyhiYXNlVXJsLCBfY29uZmlnPy5taW1lLCAoZXJyLCBwaXhlbHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyoqKiogcXVhZ2dhIGxvYWRJbWFnZXMgZXJyb3I6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBkZWNvZGluZyBwaXhlbHMgaW4gbG9hZEltYWdlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyogSW5wdXRTdHJlYW1Ob2RlIHBpeGVscy5zaGFwZScsIHBpeGVscy5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBmcmFtZSA9IHBpeGVscztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IHBpeGVscy5zaGFwZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gd2lkdGggLyBoZWlnaHQgPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF9jb25maWcuc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpXG4gICAgICAgICAgICAgICAgICAgIDogd2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfY29uZmlnLnNpemVcbiAgICAgICAgICAgICAgICAgICAgOiBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBjYWxjdWxhdGVkSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KCdjYW5yZWNvcmQnLCBbXSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hFdmVudChldmVudE5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcbiAgICAgICAgICAgIHRyaWdnZXI6IHB1Ymxpc2hFdmVudCxcblxuICAgICAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHcpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSB3O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBfY29uZmlnPy5zcmM7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgbG9hZEltYWdlcygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCkge30sXG5cbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbGF5KCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gdGltZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50SGFuZGxlcnMpLmZvckVhY2goKGluZCkgPT4gZGVsZXRlIF9ldmVudEhhbmRsZXJzW2luZF0pO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShzeikge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzei54O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBzei55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnB1dFN0cmVhbUZhY3Rvcnk7XG4iLCJpbXBvcnQgQnJvd3NlcklucHV0U3RyZWFtIGZyb20gJy4vaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9icm93c2VyJztcbmltcG9ydCBOb2RlSW5wdXRTdHJlYW0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtX25vZGUnO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbSB9IGZyb20gJy4vaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlcklucHV0U3RyZWFtO1xuZXhwb3J0IHsgTm9kZUlucHV0U3RyZWFtIH07XG5leHBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH07XG4iLCJpbXBvcnQgTm9kZUZyYW1lR3JhYmJlciBmcm9tICcuL2ZyYW1lX2dyYWJiZXJfbm9kZSc7XG5cbmltcG9ydCB7XG4gICAgaW1hZ2VSZWYsXG4gICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YSxcbiAgICBjb21wdXRlR3JheSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcblxuY29uc3QgVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG5cbmZ1bmN0aW9uIGFkanVzdENhbnZhc1NpemUoY2FudmFzLCB0YXJnZXRTaXplKSB7XG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gdGFyZ2V0U2l6ZS54KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRhcmdldFNpemUueDtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5oZWlnaHQgIT09IHRhcmdldFNpemUueSkge1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0U2l6ZS55O1xuICAgIH1cbn1cblxuY29uc3QgRnJhbWVHcmFiYmVyID0ge307XG5cbkZyYW1lR3JhYmJlci5jcmVhdGUgPSBmdW5jdGlvbiAoaW5wdXRTdHJlYW0sIGNhbnZhcykge1xuICAgIGNvbnN0IF90aGF0ID0ge307XG4gICAgY29uc3QgX3N0cmVhbUNvbmZpZyA9IGlucHV0U3RyZWFtLmdldENvbmZpZygpO1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKTtcbiAgICBjb25zdCBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKTtcbiAgICBjb25zdCBfc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgY29uc3QgX3N4ID0gdG9wUmlnaHQueDtcbiAgICBjb25zdCBfc3kgPSB0b3BSaWdodC55O1xuICAgIGxldCBfY2FudmFzO1xuICAgIGxldCBfY3R4ID0gbnVsbDtcbiAgICBsZXQgX2RhdGEgPSBudWxsO1xuXG4gICAgX2NhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBfY2FudmFzLndpZHRoID0gX2NhbnZhc1NpemUueDtcbiAgICBfY2FudmFzLmhlaWdodCA9IF9jYW52YXNTaXplLnk7XG4gICAgX2N0eCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmFtZUdyYWJiZXInLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzaXplOiBfc2l6ZSxcbiAgICAgICAgICAgIHRvcFJpZ2h0LFxuICAgICAgICAgICAgdmlkZW9TaXplOiBfdmlkZW9TaXplLFxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc1NpemUsXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5hdHRhY2hEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZyYW1lIGZyb20gdGhlIGlucHV0LXN0cmVhbSBhbmQgcHV0cyBpbnRvIHRoZSBmcmFtZS1idWZmZXIuXG4gICAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgX3RoYXQuZ3JhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZG9IYWxmU2FtcGxlID0gX3N0cmVhbUNvbmZpZy5oYWxmU2FtcGxlO1xuICAgICAgICBjb25zdCBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCk7XG4gICAgICAgIGxldCBkcmF3YWJsZSA9IGZyYW1lO1xuICAgICAgICBsZXQgZHJhd0FuZ2xlID0gMDtcbiAgICAgICAgbGV0IGN0eERhdGE7XG4gICAgICAgIGlmIChkcmF3YWJsZSkge1xuICAgICAgICAgICAgYWRqdXN0Q2FudmFzU2l6ZShfY2FudmFzLCBfY2FudmFzU2l6ZSk7XG4gICAgICAgICAgICBpZiAoX3N0cmVhbUNvbmZpZy50eXBlID09PSAnSW1hZ2VTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgZHJhd2FibGUgPSBmcmFtZS5pbWc7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRhZ3MgJiYgZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSA5MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gLTkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKF9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV9jYW52YXNTaXplLnkgLyAyLCAtX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnksIF9jYW52YXNTaXplLngpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKC1kcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKC1fY2FudmFzU2l6ZS54IC8gMiwgLV9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIDAsIDAsIF9jYW52YXNTaXplLngsIF9jYW52YXNTaXplLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHhEYXRhID0gX2N0eC5nZXRJbWFnZURhdGEoX3N4LCBfc3ksIF9zaXplLngsIF9zaXplLnkpLmRhdGE7XG4gICAgICAgICAgICBpZiAoZG9IYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjdHhEYXRhLCBfc2l6ZSwgX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlR3JheShjdHhEYXRhLCBfZGF0YSwgX3N0cmVhbUNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGF0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVHcmFiYmVyO1xuZXhwb3J0IHsgTm9kZUZyYW1lR3JhYmJlciB9O1xuIiwiLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcbiAqIHRvIHJlZmVyIHRvIHVudGlsIGl0IGlzIHJlLWltcGxlbWVudGVkLiBXZSBtYXkgYmUgYWJsZSB0byBmaXgvdXNlIHNvbWUgb2YgdGhpcy5cbiAqL1xuXG5pbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgaW50ZXJmYWNlIGZvciBGcmFtZUdyYWJiZXJcblxuaW50ZXJmYWNlIFFXb3JrZXJUaHJlYWQge1xuICAgIGltYWdlRGF0YTogVWludDhBcnJheTtcbiAgICBidXN5OiBib29sZWFuO1xuICAgIHdvcmtlcjogV29ya2VyO1xufVxuXG5sZXQgd29ya2VyUG9vbDogQXJyYXk8UVdvcmtlclRocmVhZD4gPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVdvcmtlcnMoZnJhbWVHcmFiYmVyOiBhbnkpIHtcbiAgICBsZXQgYXZhaWxhYmxlV29ya2VyOiBRV29ya2VyVGhyZWFkO1xuICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCkge1xuICAgICAgICBhdmFpbGFibGVXb3JrZXIgPSB3b3JrZXJQb29sLmZpbHRlcigod29ya2VyVGhyZWFkKSA9PiAhd29ya2VyVGhyZWFkLmJ1c3kpWzBdO1xuICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XG4gICAgICAgICAgICBmcmFtZUdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChmcmFtZUdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLmJ1c3kgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zvcldvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIHdvcmtlckludGVyZmFjZShmYWN0b3J5KSB7XG4gICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIFF1YWdnYSA9IGZhY3RvcnkoKS5kZWZhdWx0O1xuICAgICAgICBpZiAoIVF1YWdnYSkge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7ICdldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuLy8gQHRzLWlnbm9yZVxuICAgIHZhciBpbWFnZVdyYXBwZXI7XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBmdW5jdGlvbiBvblByb2Nlc3NlZChyZXN1bHQpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAncHJvY2Vzc2VkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmtlckludGVyZmFjZVJlYWR5KCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdpbml0aWFsaXplZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4vLyBAdHMtaWdub3JlXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmNtZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyID0gbmV3IFF1YWdnYS5JbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXG4gICAgICAgICAgICAgICAgeTogZS5kYXRhLnNpemUueSxcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgd29ya2VySW50ZXJmYWNlUmVhZHksIGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdwcm9jZXNzJykge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIFF1YWdnYS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdyZWdpc3RlclJlYWRlcicpIHtcbiAgICAgICAgICAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcihlLmRhdGEubmFtZSwgZS5kYXRhLnJlYWRlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gICAgdmFyIGJsb2IsXG4gICAgICAgIGZhY3RvcnlTb3VyY2U7XG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgX19mYWN0b3J5U291cmNlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZmFjdG9yeVNvdXJjZSA9IF9fZmFjdG9yeVNvdXJjZV9fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICBibG9iID0gbmV3IEJsb2IoWycoJyArIHdvcmtlckludGVyZmFjZS50b1N0cmluZygpICsgJykoJyArIGZhY3RvcnlTb3VyY2UgKyAnKTsnXSxcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcblxuICAgIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW06IGFueSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG5cbiAgICBjb25zdCB3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQgPSB7XG4gICAgICAgIHdvcmtlcixcbiAgICAgICAgaW1hZ2VEYXRhOiBuZXcgVWludDhBcnJheShpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpLFxuICAgICAgICBidXN5OiB0cnVlLFxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHdvcmtlclRocmVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IGhvdyB0byB0aHJlYWQgcHVibGlzaFJlc3VsdCBpbnRvIGhlcmU/XG4gICAgICAgICAgICAvLyBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgZXJyb3I6ICcgKyBlLmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICBzaXplOiB7IHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpIH0sXG4gICAgICAgIGltYWdlRGF0YTogd29ya2VyVGhyZWFkLmltYWdlRGF0YSxcbiAgICAgICAgY29uZmlnOiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSxcbiAgICB9LCBbd29ya2VyVGhyZWFkLmltYWdlRGF0YS5idWZmZXJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFdvcmtlclBvb2woY2FwYWNpdHk6IG51bWJlciwgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtPzogYW55LCBjYj86IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgaW5jcmVhc2VCeSA9IGNhcGFjaXR5IC0gd29ya2VyUG9vbC5sZW5ndGg7XG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDAgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9IGVsc2UgaWYgKGluY3JlYXNlQnkgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1Rlcm1pbmF0ZSA9IHdvcmtlclBvb2wuc2xpY2UoaW5jcmVhc2VCeSk7XG4gICAgICAgIHdvcmtlcnNUb1Rlcm1pbmF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciB0ZXJtaW5hdGVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlclBvb2wuc2xpY2UoMCwgaW5jcmVhc2VCeSk7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdvcmtlckluaXRpYWxpemVkID0gKHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCkgPT4ge1xuICAgICAgICAgICAgd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICBpZiAod29ya2VyUG9vbC5sZW5ndGggPj0gY2FwYWNpdHkgJiYgY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jcmVhc2VCeTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdFdvcmtlcihjb25maWcsIGlucHV0U3RyZWFtLCB3b3JrZXJJbml0aWFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPikge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAnc2V0UmVhZGVycycsIHJlYWRlcnMgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IGFueSkge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAncmVnaXN0ZXJSZWFkZXInLCBuYW1lLCByZWFkZXIgfSkpO1xufVxuIiwiaW1wb3J0IHsgSW5wdXRTdHJlYW1UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBJbnB1dFN0cmVhbSh0eXBlOiBJbnB1dFN0cmVhbVR5cGUgPSAnTGl2ZVN0cmVhbScsIHZpZXdwb3J0OiBFbGVtZW50IHwgbnVsbCwgSW5wdXRTdHJlYW06IGFueSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdWaWRlb1N0cmVhbSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSW1hZ2VTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZUltYWdlU3RyZWFtKCkgfTtcbiAgICAgICAgY2FzZSAnTGl2ZVN0cmVhbSc6IHtcbiAgICAgICAgICAgIGxldCB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gPSB2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAqIHNldHVwSW5wdXRTdHJlYW0gaW52YWxpZCB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZpZGVvOiBudWxsLCBpbnB1dFN0cmVhbTogbnVsbCB9O1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5leHBvcnQgdHlwZSBCb3ggPSBBcnJheTxbIG51bWJlciwgbnVtYmVyIF0+O1xuXG5leHBvcnQgdHlwZSBMaW5lID0gWyBQb2ludCwgUG9pbnQgXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVCb3goYm94OiBCb3gsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IGNvcm5lciA9IGJveC5sZW5ndGg7XG4gICAgd2hpbGUgKGNvcm5lci0tKSB7XG4gICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XG4gICAgICAgIGJveFtjb3JuZXJdWzFdICs9IHlPZmZzZXQ7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUxpbmUobGluZTogTGluZSwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzBdLnkgKz0geU9mZnNldDtcbiAgICBsaW5lWzFdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgeyBRdWFnZ2FDb250ZXh0IH0gZnJvbSAnLi4vUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgX2luaXRCdWZmZXJzIGZyb20gJy4vaW5pdEJ1ZmZlcnMnO1xuaW1wb3J0IF9nZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4uL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBfaW5pdENhbnZhcyBmcm9tICcuL2luaXRDYW52YXMnO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcbmltcG9ydCBCcm93c2VySW5wdXRTdHJlYW0sIHsgTm9kZUlucHV0U3RyZWFtIH0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtX2ZhY3RvcnknO1xuaW1wb3J0IEJyb3dzZXJGcmFtZUdyYWJiZXIsIHsgTm9kZUZyYW1lR3JhYmJlciB9IGZyb20gJy4uL2lucHV0L2ZyYW1lX2dyYWJiZXInO1xuaW1wb3J0ICogYXMgUVdvcmtlcnMgZnJvbSAnLi9xd29ya2VyJztcbmltcG9ydCBzZXR1cElucHV0U3RyZWFtIGZyb20gJy4vc2V0dXBJbnB1dFN0cmVhbSc7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4uL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IHsgQmFyY29kZUluZm8gfSBmcm9tICcuLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IHsgbW92ZUxpbmUsIG1vdmVCb3ggfSBmcm9tICcuL3RyYW5zZm9ybSc7XG5pbXBvcnQgeyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5cbmNvbnN0IElucHV0U3RyZWFtID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBOb2RlSW5wdXRTdHJlYW0gOiBCcm93c2VySW5wdXRTdHJlYW07XG5jb25zdCBGcmFtZUdyYWJiZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IE5vZGVGcmFtZUdyYWJiZXIgOiBCcm93c2VyRnJhbWVHcmFiYmVyO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFnZ2Ege1xuICAgIGNvbnRleHQ6IFF1YWdnYUNvbnRleHQgPSBuZXcgUXVhZ2dhQ29udGV4dCgpO1xuXG4gICAgaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfSA9IF9pbml0QnVmZmVycyhcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIGltYWdlV3JhcHBlcixcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubG9jYXRvcixcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgICAgIHRoaXMuY29udGV4dC5ib3hTaXplID0gYm94U2l6ZTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0QnVmZmVycyhpbWFnZVdyYXBwZXIpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2RlciA9IEJhcmNvZGVEZWNvZGVyLmNyZWF0ZSh0aGlzLmNvbnRleHQuY29uZmlnLmRlY29kZXIsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZ2V0Vmlld1BvcnQoKTogRWxlbWVudCB8IG51bGwge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtO1xuICAgICAgICByZXR1cm4gX2dldFZpZXdQb3J0KHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmVhZHkoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLnBsYXkoKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBpbml0Q2FudmFzKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfaW5pdENhbnZhcyh0aGlzLmNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3R4LCBkb20gfSA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UgPSBkb20uaW1hZ2U7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkgPSBkb20ub3ZlcmxheTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHguaW1hZ2UgPSBjdHguaW1hZ2U7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4Lm92ZXJsYXkgPSBjdHgub3ZlcmxheTtcbiAgICB9XG5cbiAgICBjYW5SZWNvcmQgPSAoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQmFyY29kZUxvY2F0b3IuY2hlY2tJbWFnZUNvbnN0cmFpbnRzKHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRvcik7XG4gICAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyID0gRnJhbWVHcmFiYmVyLmNyZWF0ZShcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8ubnVtT2ZXb3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeShjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgaW5pdElucHV0U3RyZWFtKGNhbGxiYWNrOiAoZXJyPzogRXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlOiBpbnB1dFR5cGUsIGNvbnN0cmFpbnRzIH0gPSB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtO1xuICAgICAgICBjb25zdCB7IHZpZGVvLCBpbnB1dFN0cmVhbSB9ID0gc2V0dXBJbnB1dFN0cmVhbShpbnB1dFR5cGUsIHRoaXMuZ2V0Vmlld1BvcnQoKSwgSW5wdXRTdHJlYW0pO1xuXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdMaXZlU3RyZWFtJyAmJiB2aWRlbykge1xuICAgICAgICAgICAgQ2FtZXJhQWNjZXNzLnJlcXVlc3QodmlkZW8sIGNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGlucHV0U3RyZWFtLnRyaWdnZXIoJ2NhbnJlY29yZCcpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBjYWxsYmFjayhlcnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldEF0dHJpYnV0ZSgncHJlbG9hZCcsICdhdXRvJyk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldElucHV0U3RyZWFtKHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pO1xuICAgICAgICBpbnB1dFN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdjYW5yZWNvcmQnLCB0aGlzLmNhblJlY29yZC5iaW5kKHVuZGVmaW5lZCwgY2FsbGJhY2spKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0gPSBpbnB1dFN0cmVhbTtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0JveGVzKCk6IEFycmF5PEFycmF5PG51bWJlcj4+IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdGUgPyBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKVxuICAgICAgICAgICAgOiBbW1xuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzBdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsxXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMl0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzNdKSxcbiAgICAgICAgICAgIF1dO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG5lZWQgYSB0eXBlc2NyaXB0IHR5cGUgZm9yIHJlc3VsdCBoZXJlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgdHJhbnNmb3JtUmVzdWx0KHJlc3VsdDogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSB0b3BSaWdodC54O1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gdG9wUmlnaHQueTtcblxuICAgICAgICBpZiAoeE9mZnNldCA9PT0gMCAmJiB5T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBCYXJjb2RlSW5mbyBtYXkgbm90IGJlIHRoZSByaWdodCB0eXBlIGhlcmUuXG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZm9yRWFjaCgoYmFyY29kZTogQmFyY29kZUluZm8pID0+IHRoaXMudHJhbnNmb3JtUmVzdWx0KGJhcmNvZGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGluZSAmJiByZXN1bHQubGluZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIG1vdmVMaW5lKHJlc3VsdC5saW5lLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYm94KSB7XG4gICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3gsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3hlcyAmJiByZXN1bHQuYm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQuYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3hlc1tpXSwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+KTogdm9pZCB7XG4gICAgICAgIGlmICghaW1hZ2VEYXRhIHx8ICF0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgZGF0YSBzdHJ1Y3R1cmUgaG9sZHMgYSBcImJhcmNvZGVzXCIgcmVzdWx0LCBpZiBhbnkuLi5cbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZpbHRlcigoYmFyY29kZTogUXVhZ2dhSlNSZXN1bHRPYmplY3QpID0+IGJhcmNvZGUuY29kZVJlc3VsdClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoYmFyY29kZTogUXVhZ2dhSlNSZXN1bHRPYmplY3QpID0+IHRoaXMuYWRkUmVzdWx0KGJhcmNvZGUsIGltYWdlRGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdChcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKSxcbiAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGhhc0NvZGVSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEocmVzdWx0ICYmIChyZXN1bHQuYmFyY29kZXNcbiAgICAgICAgICAgID8gcmVzdWx0LmJhcmNvZGVzLnNvbWUoKGJhcmNvZGUpID0+IGJhcmNvZGUuY29kZVJlc3VsdClcbiAgICAgICAgICAgIDogcmVzdWx0LmNvZGVSZXN1bHQpKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIHB1Ymxpc2hSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSBudWxsLCBpbWFnZURhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IHJlc3VsdFRvUHVibGlzaDogQXJyYXk8UXVhZ2dhSlNSZXN1bHRPYmplY3Q+IHwgUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsID0gcmVzdWx0O1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLmFkZFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQuYmFyY29kZXMgfHwgcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ3Byb2Nlc3NlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvZGVSZXN1bHQocmVzdWx0IGFzIFF1YWdnYUpTUmVzdWx0T2JqZWN0KSkge1xuICAgICAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ2RldGVjdGVkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2F0ZUFuZERlY29kZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldEJvdW5kaW5nQm94ZXMoKTtcbiAgICAgICAgaWYgKGJveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVSZXN1bHQgPSB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykgfHwge307XG4gICAgICAgICAgICBkZWNvZGVSZXN1bHQuYm94ZXMgPSBib3hlcztcbiAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChkZWNvZGVSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21JbWFnZSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGltYWdlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGltYWdlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXJzVXBkYXRlZCA9IFFXb3JrZXJzLnVwZGF0ZVdvcmtlcnModGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlcik7XG4gICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpO1xuICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzdGFydENvbnRpbnVvdXNVcGRhdGUoKTogdm9pZCB7XG4gICAgICAgIGxldCBuZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAxMDAwIC8gKHRoaXMuY29udGV4dC5jb25maWc/LmZyZXF1ZW5jeSB8fCA2MCk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCB8fCB0aW1lc3RhbXA7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IGRlbGF5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld0ZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBuZXdGcmFtZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuXG4gICAgc3RhcnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCAmJiB0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGludW91c1VwZGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbCgwKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtICYmIHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IFF1YWdnYUpTUmVhZGVyQ29uZmlnKTogdm9pZCB7XG4gICAgICAgIEJhcmNvZGVEZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgIH1cbn1cbiIsImltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmVzdWx0Q29sbGVjdG9yIGZyb20gJy4vYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3InO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL2NvbmZpZy9jb25maWcnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcblxuY29uc3QgaW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cbmNvbnN0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2IgPSAoZXJyKSA9PiB7IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzk6IHBlbmRpbmcgcmVzdHJ1Y3R1cmUgaW4gSXNzdWUgIzE3OSwgd2UgYXJlIHRlbXAgZGlzYWJsaW5nIHdvcmtlcnNcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zdGFydCgpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zdG9wKCk7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uRGV0ZWN0ZWQgY2FsbGVkIHdpdGggaW52YWxpZCBjYWxsYmFjaywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKCdkZXRlY3RlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdkZXRlY3RlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdvYmplY3QnIHx8ICFjYWxsYmFjay5jYWxsYmFjaykpKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vblByb2Nlc3NlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZlByb2Nlc3NlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgc2V0UmVhZGVyczogZnVuY3Rpb24gKHJlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFyZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5zZXRSZWFkZXJzIGNhbGxlZCB3aXRoIG5vIHJlYWRlcnMsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiAobmFtZSwgcmVhZGVyKSB7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIgY2FsbGVkIHdpdGggbm8gbmFtZSwgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIgY2FsbGVkIHdpdGggbm8gcmVhZGVyLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgfSxcbiAgICByZWdpc3RlclJlc3VsdENvbGxlY3RvcjogZnVuY3Rpb24gKHJlc3VsdENvbGxlY3Rvcikge1xuICAgICAgICBpZiAocmVzdWx0Q29sbGVjdG9yICYmIHR5cGVvZiByZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfY29udGV4dC5yZXN1bHRDb2xsZWN0b3IgPSByZXN1bHRDb2xsZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBfY29udGV4dC5jYW52YXNDb250YWluZXI7XG4gICAgfSxcbiAgICBkZWNvZGVTaW5nbGU6IGZ1bmN0aW9uIChjb25maWcsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHF1YWdnYUluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xuICAgICAgICBjb25maWcgPSBtZXJnZSh7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgICAgICAgICBzcmM6IGNvbmZpZy5zcmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtT2ZXb3JrZXJzOiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1ZykgPyAwIDogMSxcbiAgICAgICAgICAgIGxvY2F0b3I6IHtcbiAgICAgICAgICAgICAgICBoYWxmU2FtcGxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3NTogcmVzdHJ1Y3R1cmUgd29ya2VyIHN1cHBvcnQgc28gdGhhdCBpdCB3aWxsIHdvcmsgd2l0aCB0eXBlc2NyaXB0IHVzaW5nIHdvcmtlci1sb2FkZXJcbiAgICAgICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9sb2FkZXJzL3dvcmtlci1sb2FkZXIvXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd29ya2VycyByZXF1aXJlIFdvcmtlciBhbmQgQmxvYiBzdXBwb3J0IHByZXNlbnRseSwgc28gaWYgbm8gQmxvYiBvciBXb3JrZXIgdGhlbiBzZXRcbiAgICAgICAgLy8gd29ya2VycyB0byAwLlxuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDAgJiYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBubyBXb3JrZXIgYW5kL29yIEJsb2Igc3VwcG9ydCAtIGZvcmNpbmcgbnVtT2ZXb3JrZXJzIHRvIDAnKTtcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdChjb25maWcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRzLm9uY2UoJ3Byb2Nlc3NlZCcsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdENhbGxiYWNrLmNhbGwobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfSwgbnVsbCwgcXVhZ2dhSW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gYWRkIHRoZSB1c3VhbGx5IGV4cGVjdGVkIFwiZGVmYXVsdFwiIGZvciB1c2Ugd2l0aCByZXF1aXJlLCBidWlsZCBzdGVwIHdvbid0IGFsbG93IHVzIHRvXG4gICAgLy8gd3JpdGUgdG8gbW9kdWxlLmV4cG9ydHMgc28gZG8gaXQgaGVyZS5cbiAgICBnZXQgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlO1xuICAgIH0sXG4gICAgQmFyY29kZVJlYWRlcixcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4vLyBleHBvcnQgQmFyY29kZVJlYWRlciBhbmQgb3RoZXIgdXRpbGl0aWVzIGZvciBleHRlcm5hbCBwbHVnaW5zXG5leHBvcnQge1xuICAgIEJhcmNvZGVEZWNvZGVyLFxuICAgIEJhcmNvZGVSZWFkZXIsXG4gICAgQ2FtZXJhQWNjZXNzLFxuICAgIEltYWdlRGVidWcsXG4gICAgSW1hZ2VXcmFwcGVyLFxuICAgIFJlc3VsdENvbGxlY3Rvcixcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9